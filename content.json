{"meta":{"title":"joont blog","subtitle":null,"description":"joont blog","author":"joont","url":"https://joont92.github.io"},"pages":[],"posts":[{"title":"실행계획","slug":"db/실행계획","date":"2017-11-27T14:06:02.296Z","updated":"2017-11-27T14:06:02.296Z","comments":true,"path":"2017/11/27/db/실행계획/","link":"","permalink":"https://joont92.github.io/2017/11/27/db/실행계획/","excerpt":"","text":"실행계획 절차 SQL 파서 모듈을 통해 작성된 SQL을 잘개 쪼갠다.(SQL 파스 트리 생성) 생성된 SQL 파스트리를 통해 옵티마이저가 불필요한 연산 제거, 어떤 인덱스를 사용할지, 어떤 테이블을 선행할지 등을 결정한다. 결정된 실행계획을 가지고 스토리지 엔진으로부터 데이터를 가져옴 옵티마이저 종류규칙기반(rule based optimizer), 비용기반(cost based optimizer)가 있다.거의 대부분이 CBO를 사용한다. 통계 정보CBO에서 가장 중요한 정보이다. 통계정보가 잘못되면 엉뚱한 방향으로 쿼리가 실행될 수 있다.MySQL은 통계정보가 다양하지 않은 편. 전체 레코드의 대략적 건수, 인덱스 유니크 값 개수 정도가 전부이다.ANALYZE 명령으로 통계정보를 갱신할 수 있다. 1ANALYZE TABLE '테이블명' ANALYZE 명령 시,MyISAM 테이블의 경우 쓰기는 불가능하고 읽기는 가능InnoDB 테이블의 경우 쓰기와 읽기 둘 다 불가능 실행계획 분석1EXPLAIN [쿼리] 와 같이 입력하면 실행계획 표가 출력됨.표의 로우는 사용하는 테이블의 개수만큼 출력됨(서브쿼리, 임시테이블 등 포함)실행순서는 위에서 아래로CRUD의 경우 실행계획 분석이 불가능하다. WHERE 절에 사용되는 부분만 따로 빼내서 실행계획을 분석하던지 해야 한다.","categories":[{"name":"db","slug":"db","permalink":"https://joont92.github.io/categories/db/"}],"tags":[]},{"title":"mysql data sample","slug":"db/mysql-data-sample","date":"2017-11-27T13:22:16.048Z","updated":"2017-11-27T13:22:16.048Z","comments":true,"path":"2017/11/27/db/mysql-data-sample/","link":"","permalink":"https://joont92.github.io/2017/11/27/db/mysql-data-sample/","excerpt":"","text":"https://github.com/datacharmer/test_db mysql &lt; employees.sql이거 외엔 딱히 할 필요 없어보이긴 함","categories":[{"name":"db","slug":"db","permalink":"https://joont92.github.io/categories/db/"}],"tags":[]},{"title":"bash_profile과 bashrc","slug":"linux/bash-profile과-bashrc","date":"2017-11-27T13:19:43.576Z","updated":"2017-11-27T13:19:43.583Z","comments":true,"path":"2017/11/27/linux/bash-profile과-bashrc/","link":"","permalink":"https://joont92.github.io/2017/11/27/linux/bash-profile과-bashrc/","excerpt":"","text":"리눅스에서 alias를 수정하거나 PATH를 변경할 떄 접하게 되는 대표적인 4가지의 파일들.. 1/etc/profile, /etc/bashrc, ~\\.bash_profile, ~\\.bash_rc 각각의 파일에 대해 간단하게 알아보겠다. 일단 이에 대해 알기전에 Login Shell과 Non-Login Shell의 차이에 대해 알아야 한다. Login ShellShell을 실행할 때 로그인이 필요한 경우를 말한다.ssh로 접속하거나, su 명령어로 다른계정을 들어갈 때 등이 해당된다. \\/etc\\/profile, ~\\/.bash_profile 파일이 이 Shell이 뜰 때 실행되는 파일이다. Non-Login ShellShell을 실행할 떄 로그인이 필요하지 않은 경우를 말한다.즉 Shell이 실행되는 모든 상황을 의미하게 됩니다.GUI에서 터미널을 띄울때나, bash 명령어로 다시 bash를 실행하는 경우 등이 해당된다. \\/etc\\/bashrc, ~\\/.bashrc 파일이 이 Shell이 뜰 때 실행되는 파일이다. Login Shell은 Non-Login Shell을 포함합니다.Login Shell이 실행될 때 profile과 bashrc 파일이 모두 실행되게 되고,Non-Login Shell이 실행될 때 bashrc 파일만 실행되게 됩니다. profile\\/etc\\/profile 파일의 경우 전역적인 파일로 모든 사용자가 로그인 시 실행되며,~\\/.bash_profile 파일의 경우 지역적인 파일로 해당하는 사용자가 로그인 시만 실행된다.또한 \\/etc\\/profile의 경우 어떠한 shell이든 상관없지만, ~\\/.bash_profile의 경우 bash shell일 경우에만 해당된다. bashrcprofile과 달리 Login 과정이 없으므로 shell을 실행시키는 사용자로 구분한다.\\/etc\\/bashrc의 경우 모든 사용자가 shell을 실행시킬 때 마다 실행되며,~\\/.bashrc의 경우 해당하는 사용자가 shell 실행시킬 때 실행된다. profile의 경우 대부분 환경 변수같은 것을 명시하고 bashrc의 경우 alias 같은 것을 명시한다..(?)","categories":[{"name":"linux","slug":"linux","permalink":"https://joont92.github.io/categories/linux/"}],"tags":[]},{"title":"apt 명렁어","slug":"linux/apt-명렁어","date":"2017-11-27T13:19:42.160Z","updated":"2017-11-27T13:19:42.168Z","comments":true,"path":"2017/11/27/linux/apt-명렁어/","link":"","permalink":"https://joont92.github.io/2017/11/27/linux/apt-명렁어/","excerpt":"","text":"패키지란커널 및 라이브러리 버전의 배포판 환경에 맞추어 빌드한 실행파일을 압축한 것. apt란우분투에서 쓰이는 데비안 계열의 패키지를 관리하는데 쓰이는 도구이다. 저장소 리스트 : /etc/apt/sources.list 패키지 리스트 업데이트1apt-get update > 실제 패키지를 업그레이드 하는 것이 아니라 사용가능한 패키지 리스트의 정보를 업데이트 패키지 업데이트1apt-get upgrade > 실제 설치되어 있는 패키지들을 최신 버전으로 업그레이드 패키지 설치1apt-get install [패키지명] 패키지 재설치1apt-get --reinstall install [패키지명] 패키지 삭제12apt-get remove [패키지명] # 설정파일은 지우지 않음apt-get purge [패키지명] # 설정파일까지 지움 패키지 검색1apt-cache search [패키지명] 패키지 정보1apt-cache show [패키지명] apt 명령어를 이용해 설치한 패키지는 \\/var\\/cache\\/apt\\/archives 에 설치된다.","categories":[{"name":"linux","slug":"linux","permalink":"https://joont92.github.io/categories/linux/"}],"tags":[]},{"title":"프로세스","slug":"linux/프로세스","date":"2017-11-27T13:19:39.468Z","updated":"2017-11-27T13:19:39.472Z","comments":true,"path":"2017/11/27/linux/프로세스/","link":"","permalink":"https://joont92.github.io/2017/11/27/linux/프로세스/","excerpt":"","text":"작업 : 작성한 프로그램 + 프로그램 실행에 필요한 데이터작업이 커널에 등록되어 커널의 관리하에 있게 되면 이를 프로세스라고 부른다.일반적으로 실행중인 프로그램을 말한다. 종속된 자식 프로세스는 부모 프로세스의 환경을 물려받으나 역은 성립하지 않는다.","categories":[{"name":"linux","slug":"linux","permalink":"https://joont92.github.io/categories/linux/"}],"tags":[]},{"title":"파일/디렉토리 관리","slug":"linux/파일-디렉토리-관리","date":"2017-11-27T13:19:37.940Z","updated":"2017-11-27T13:19:37.946Z","comments":true,"path":"2017/11/27/linux/파일-디렉토리-관리/","link":"","permalink":"https://joont92.github.io/2017/11/27/linux/파일-디렉토리-관리/","excerpt":"","text":"와일드 카드? : 어떤 한 문자 : 어떤 문자도 없거나 그 이상[] : [] 내에 지정된 각각의 문자 [a-d] 는 a,b,c,d를 의미, [acd]는 a,c,d를 의미한다. [abcd] 는 a,b,c,d로 시작하는 파일 모두를 의미한다. [abcd]?, [a-d]? 등등의 예시가 많다. “rm [abc]“ 처럼 사용할 수 있다. 리다이렉션표준 입출력을 키보드나 모니터가 아닌 파일로 받거나, 출력하는 것을 의미. 표준 출력의 변경 : &gt;, &gt;&gt;결과를 파일로 보냄, &gt;&gt;는 기존 파일의 내용을 유지한 채 내용을 추가할 떄 사용한다. access.log 와 같이 사용하면 access.log 파일의 내용을 모두 지우고 크기를 0으로 만들어 버릴 수 있다.아무것도 없는 내용을 access.log에 전달하기 때문 표준 입력의 변경 : &lt;cat &lt; testFile 과 같이 사용. 표준 출력은 터미널로 하고 표준 입력에 키보드가 아닌 testFile 이라는 파일을 사용한다일반적으로 cat 파일명 &lt; 파일명 의 형태가 많이 사용된다. 표준 에러 : 2&gt;, 2&gt;&gt;에러 내용을 파일로 저장하고자 할 때 사용한다. ls /asdfas 2&gt; errorFile2인 경우는 파일 디스크립터의 순서가 입력 0, 출력 1, 에러 2 이기 때문 표준출력과 표준에러를 한꺼번에 저장하려면 &amp;&gt;를 사용한다.find / -name aa* &amp;&gt; errorLog 명령 &gt; 파일명 : 명령의 결과가 파일에 저장. 에러는 모니터로 출력명령 2&gt; 파일명 : 에러 내용이 파일에 저장. 명령 결과는 모니터 출력명령 &amp;&gt; 파일명 : 명령 결과, 에러 내용이 파일에 저장 파이프라인한 명령의 표준 출력을 다른 명령의 표준 입력으로 보내는 방식사용되는 기호는 | 이며, |로 구분 되면 한 개 이상의 명령이 연속되어 나올 수 있다이전 명령의 표준 출력이 다음 명령의 표준 입력이 되는 방식이다.command1 | command2 | command3 | command4 …1의 출력이 2의 입력, 2의 출력이 3의 입력, 3의 출력이 4의 입력…|&amp;을 사용하면 표준출력 + 표준에러를 다음 명령의 표준 입력으로 사용할 수 있다.$? 는 특수한 변수로써, 앞서 실행한 명령의 종료 상태값을 받는다. ※ 파이프라인에 자주 사용되는 grep 명령어는 패턴에 맞는 문자열을 찾아주는 명령어이다.grep 123 라고 입력하면, 사용자로부터 입력을 받아서 패턴에 맞을 경우 화면에 출력해준다.grep만 입력하면 키보드로 표준 입력을 받는다. 보통은 파이프라인을 사용하여 명령의 결과값을grep에게 표준입력으로 전달한다. 기타(||, &amp;&amp;, ;, &amp;)1) ; : 한줄에 여러 명령어 입력. mkfs -t sfs -f /dev/sda5; mkdir /backup; mount /dev/sda5/backup 와 같이 사용 하나의 작업을 기다렸다가 다시 입력하고 하는 방식보다 위와 같이 세미콜론으로 연결해서 사용 가능하다. 2) &amp;&amp;, || : 앞에서 실행한 명령의 결과에 따라 다음 명령어 실행. 각 연산자의 특징을 이용하여 사용된다.; 으로 연결했을 경우 앞의 명령의 실패여부에 관계없이 뒤의 명령이 무조건 실행된다.포멧이 실패했는데 마운트가 되는 경우가 발생할 수도 있는 셈이다.그리하여 &amp;&amp;과 ||를 써서 적절히 성공여부에 따라 명령을 조절할 수 있다.&amp;&amp;의 경우 앞,뒤가 참이여야 하는 논리연산자이다.그러므로 앞의 연산이 거짓일 경우, 뒤의 연산을 실행하지 않는다. -&gt; 이것이 중요하다.cat asddd &amp;&amp; echo ‘test’ 해보면, asddd 파일이 없을 경우 첫번째 연산결과가 거짓이므로 뒤의 echo는 실행되지 않는다.|| 또한 마찬가지다. ||는 둘중 하나만 참이면 되는 논리연산자이다.그리므로 앞의 연산이 참일 경우, 뒤의 연산을 실행하지 않는다.cat asddd || echo ‘test’ 했을 경우, 앞의 연산이 참이면 뒤의 연산이 실행되지 않는다.즉, 위 두 연산자를 사용하려면 &amp;&amp;는 명령이 성공할 경우의 명령을 나열하면 되고, ||는 명령이 실패할 경우의 명령을 나열하면 되겠다. 3) &amp; : 백그라운드 모드로 실행명령어 마지막에 &amp;를 붙여주면 백그라운드 모드로 실행 가능하다. 디렉토리 구조모든 디렉토리는 / 부터 시작한다..는 현재 디렉토리 ..는 부모 디렉토리 ~는 사용자의 홈 디렉토리를 의미한다. 파일1) 일반 파일 : 우리가 평상시 쓰는 파일2) 디렉토리 파일 : 파일을 포함하고 있는 파일. 일반 파일,디렉토리 파일, 특수 파일을 포함할 수 있다. 근데 실제로 들어가보면 파일을 포함하고 있는 것이 아니라, 리눅스가 파일을 엑세스 하는데 필요한 정보를 가지고 있을 뿐이다. 3) 특수 파일 :","categories":[{"name":"linux","slug":"linux","permalink":"https://joont92.github.io/categories/linux/"}],"tags":[]},{"title":"index","slug":"db/index","date":"2017-11-27T12:42:36.272Z","updated":"2017-11-27T12:42:36.275Z","comments":true,"path":"2017/11/27/db/index/","link":"","permalink":"https://joont92.github.io/2017/11/27/db/index/","excerpt":"","text":"","categories":[{"name":"db","slug":"db","permalink":"https://joont92.github.io/categories/db/"}],"tags":[]},{"title":"IOC 컨테이너와 DI","slug":"spring/IOC-컨테이너와-DI","date":"2017-10-29T15:16:21.523Z","updated":"2017-10-29T15:16:21.523Z","comments":true,"path":"2017/10/30/spring/IOC-컨테이너와-DI/","link":"","permalink":"https://joont92.github.io/2017/10/30/spring/IOC-컨테이너와-DI/","excerpt":"","text":"IOC 컨테이너와 DI어플리케이션 컨텍스트 = IOC + DI + 여러 기능(for making enterprise application)(어플리케이션 컨텍스트는 실제 ApplicationContext 인터페이스를 구현한 클래스를 말한다.ApplicationContext는 BeanFactory를 구현한 인터페이스이다.) 이 어플리케이션 컨텍스트가 본격적인 IOC 컨테이너로 동작하려면 아래의 2가지가 필요하다. POJO, 설정 메타정보 어플리케이션 컨텍스트 구현체, POJO, 설정 메타정보가 준비되었으면 이제 IOC 컨테이너로 등록하고 사용해야한다.웹은 싱글 어플리케이션 처럼 main 메서드가 있는 것이 아니므로, 아래와 같은 방식을 통해 등록한다. 컨테이너가 기동될 떄 미리 어플리케이션 컨텍스트를 만든다.(web.xml의 listener, servlet등을 이용) 서블릿에서 요청이 올때마다 어플리케이션 컨텍스트에서 필요한 빈을 가져와 정해진 메서드를 실행한다. 그림으로 보면 아래와 같다.메타정보에 관해서는 아래에서 설명할 것인데, 일단은 우리가 잘 알고 있는 ***-context.xml 파일이라고 생각하시면 됩니다.컨테이너가 기동될 때 POJO 클래스와 메타정보를 조합하여 각종 빈 들이 만들어지고, 그들을 관리하는 IOC 컨테이너가 생성되게 됩니다.(DispatcherServlet)그리고 각 HTTP 요청에 지정된 서블릿의 메서드가 실행될 때, 필요한 빈을 어플리케이션 컨텍스트에서 가져온 뒤 해당 메서드를 실행합니다. 컨테이너 계층구조스프링은 어플리케이션 컨텍스트를 계층구조로 가질 수 있다. 빈 탐색 : 자식 -&gt; 부모부모에서 자식을 찾을 수 없으며, 형제 컨텍스트의 빈도 검색 불가능.자식과 부모에 중복된 이름의 빈이 있을 경우 자식의 빈을 사용(피해야 할 상황) 하나의 컨텍스트에 정의된 AOP의 경우 다른 컨텍스트의 빈에는 영향을 미치지 않음상황에 따라 다른 설정을 사용해야 할 경우, 그런데 중요한 설정을 공유해야 할 경우 사용하면 효율적.그러나 제대로 알지 못하고 사용하면(계층구조, 탐색순서) 예기치 못한 에러를 만날 수 있음 웹 어플리케이션 컨테이너 계층구조웹 어플리케이션 레벨에 등록하는 루트 컨테이너,어플리케이션에 등록된 서블릿들이 각각 자신의 컨테이너를 가지는 구조가 대표적인 경우이다.일반적으로 스프링을 사용하여 웹 개발을 할 경우 프론트 컨트롤러 패턴을 사용하므로 대부분 아래와 같다.1서블릿 어플리케이션 컨텍스트 -&gt; 루트 어플리케이션 컨텍스트 프론트 컨트롤러 패턴임에도 굳이 계층구조로 형성하는 이유는 아래와 같은 상황을 대비하기 위함이다 ㅎㅎ스프링의 유틸리티 메소드를 사용하면 간단하게 어플리케이션 컨텍스트를 얻어올 수 있다.1WebApplicationContextUtils.getWebApplicationContext(ServletContext) ServletContext는 웹 어플리케이션마다 하나씩 만들어지는것이므로HttpServletRequest나 HttpSession 오브젝트만 있으면 간단히 얻을 수 있다. 루트 어플리케이션 컨텍스트 등록서블릿 컨텍스트의 생성/소멸을 알려주는 web.xml의 listener를 사용하여 등록한다.스프링이 제공해주는 리스너로는 ServletContextListener를 구현한 ContextLoaderListener가 있다.12345678&lt;listener&gt;&lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/spring/root-context.xml&lt;/param-value&gt;&lt;/context-param&gt; contextConfigLocation설정파일의 위치를 바꿔줄 때 사용리소스 로더 접두어, ant식 경로표기법 사용가능 contextClass어플리케이션 컨텍스트 클래스를 바꿔줄떄 사능 지정해주지 않을 경우 default로 class는 XmlWebApplicationContext, xml 파일 위치는 /WEB-INF/applicationContext.xml 을 사용한다. 서블릿 어플리케이션 컨텍스트 등록스프링 웹 기능을 지원하는 프론트 컨트롤러 서블릿인 DispatcherServlet은초기화시에 자신만의 컨텍스트를 생성하고 초기화하고,웹 어플리케이션 레벨에 등록된 어플리케이션 컨텍스트를 찾아서 자신의 부모 컨텍스트로 사용한다. 123456789&lt;servlet&gt; &lt;servlet-name&gt;appServlet&lt;/servlet&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/spring/appServlet/servlet-context.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt; 이클립스에서 Sprig MVC 프로젝트를 만들었을 때 생성되는 기본 구조이다.루트 어플리케이션 컨텍스트를 만들 때 처럼 설정파일의 위치나 클래스를 변경해 줄 수 있다.(파라미터는 루트 어플리케이션 컨텍스트와 동일하고, init-param을 사용한다는 것만 다르다.) 지정해주지 않을 경우 default로 class는 XmlWebApplicationContext, xml 파일 위치는 /WEB_INF/{서블릿 네임}-context.xml 을 사용한다. 루트 어플리케이션 컨텍스트에 등록되는 빈 들은 각각 성격이 구분되므로 여러 설정파일로 나누고,서블릿 어플리케이션 컨텍스트의 경우 성격이 비슷하므로 디폴트 설정파일 위치를 사용하는 것이 일반적이라고 한다(근데 위는 왜 저렇지..) IoC/DI를 위한 빈 설정 메타정보 작성앞서 언급한 빈 설정 메타정보에 대해 알아보겠다. IoC 컨테이너는 설정 메타정보를 참고하여 POJO 오브젝트들을 빈으로 등록한다. 설정 메타정보라고 하면 보통 우리에게 익숙한 *-context.xml 파일등이 떠오르게 되는데, 이는 사실 실제 설정 메타정보는 아니다. 아래의 그림을 보면 쉽게 이해할 수 있다. 정확하게 말해 설정 메타정보란 BeanDefinition이라는 순수 오브젝트를 의미한다. 우리가 작성하는 xml파일, 어노테이션 등은 모두 적절한 리더기에 의해 BeanDefinition 오브젝트로 변환되는 것이다! BeanDefinition에는 IoC 컨테이너가 빈을 만들 때 필요한 핵심정보가 담겨 있다.그러나 필수항목 몇개를 제외하면 대부분 디폴트 값을 그대로 사용한다. 빈 등록법 \\ 태그 : 가장 강력하면서도 심플한 방법 네임스페이스 &amp; 전용태그 : 1번의 문제점을 보완한 방식이다.1번의 경우 모두 \\ 태그로 통일하기 때문에 구분이 잘 안된다는 단점이 있다.(스프링은 자신에게 필요한 설정정보에도 DI를 사용하기 때문에 이런 현상이 벌어지는 것이다.)그래서 각각의 성격에 맞게 네임스페이스와 태그를 제공한다.ex) \\가독성, 필수 프로퍼티, 클래스 선택, 다중 클래스 등록 등 많은 이점이 있다. 빈 스캐닝빈 스캐너를 이용하여 인자로 전달한 패키지 아래의 클래스들을 검사한다.@Component나 @Component를 메타 어노테이션으로 가지는 애들을 빈으로 등록한다.이런 형태의 어노테이션을 스프링에선 스테레오 타입이라고 부른다스캐닝으로 등록되는 빈은 이름을 등록하지 않으면 default로 클래스명에서 앞글자만 소문자로 사용한다.어노테이션 디폴트값을 이용해 빈 이름을 지정할 수 있다. ex) @Component(“test”)xml 작성 방법보다 간편하게 빈을 등록할순 있으나, 등록된 빈 들을 한눈에 볼 수 없다는 단점이 있다.또한 xml 처럼 상세 메타정보 항목을 지정할 수 없고(한계가 있음), 클래스당 1개의 빈만 등록할 수 있다. 빈 스캐닝이 편리하긴 하지만 각각의 상황에 따라 xml과 빈 스캐닝을 적절히 선택하는 것이 좋다(세밀한 관리가 필요할 경우 등) 빈스캐너 등록법xml : \\컨텍스트 : 어플리케이션 컨텍스트 등록 시 contextClass로 AnnotationConfigWebApplicationContext 사용 스테레오 타입 종류@Repository : DAO, repository@Service : service@Controller : mvc controller 특정계층으로 분류하기 힘든 경우는 @Component를 사용하는 것이 바람직 빈 스캐닝 시 컨테이너 계층 구조에서 유의할 점이 있다.부모 컨테이너와 자식 컨테이너의 빈 스캐닝 지점이 같은 곳을 바라보고 있을 경우 아래와 같은 문제점이 발생할 수 있다.탐색의 순서가 자식 -&gt; 부모의 순서이므로 위의 경우 AOP, TX가 적용된 UserService 빈을 사용하지 못하게 된다. java config1234567@Configuration // &lt;beans&gt;public class JavaConfig&#123; @Bean // &lt;bean&gt; public Hello hello()&#123; // method name == bean name return new Hello(); &#125;&#125; 등록 방법 : AnnotationConfigWebApplictionContext 생성자 파라미터로 패키지 대신 위의 클래스를 넣어주면 된다. @Configuration이 붙은 클래스도 빈으로 등록된다! (빈 이름 == 클래스명(첫글자 소문자)) 일반적인 자바 코드와 다른점(유의사항)@Bean 아래 메서드에서 new로 인스턴스를 생성했지만 실제로 빈을 가져다 사용해보면 계속해서 같은 오브젝트가 리턴된다(직접 실행해도 마찬가지이다) @Configuration내에 @Bean만 해당함 자바 설정파일을 사용할 때의 장점 컴파일러나 IDE를 통한 검증이 가능하고, IDE의 기능을 최대한 이용할 수 있음.XML은 텍스트이기 떄문에 한계가 있다. @Bean 자체가 자바 메서드이기 때문에 복잡한 빈 등록도 팩토리 빈 없이 쉽게 등록할 수 있다. 자주 사용하는 빈 등록 방법 XML 단독 사용 생성되는 모든 빈을 XML에서 확인할 수 있는 장점이 있는 반면, 빈의 개수가 많아지면 XML 파일을 관리하기 번거로울 수 있다. 설정을 분리하고 순수한 POJO 코드를 유지하고 싶을 떄 사용할 수 있다. 커스텀 태그나 전용태그를 사용할 경우 장점이 부각된다. 스프링이 제공하는 모든 빈 설정을 할 수 있는 유일한 방법이다. XML + 빈 스캐닝 3계층 빈 클래스은 빈 스캔을 사용하고(복잡한 메타정보가 필요없으므로), 복잡한 설정 정보는 XML을 사용한다. XML 없이 단독 스캐닝 사용 자바 설정파일이 반드시 필요하다. 루트/서블릿 어플리케이션 컨텍스트를 전부 AnnotationConfigWebApplicationContext로 변경하고, @Configuration 클래스 파일을 빈 설정 대상에 포함시킨다. 스프링이 제공하는 전용 태그를 사용할 수 없다는 단점이 있다.","categories":[{"name":"spring","slug":"spring","permalink":"https://joont92.github.io/categories/spring/"}],"tags":[]},{"title":"3장-영속성관리","slug":"jpa/3장-영속성관리","date":"2017-10-29T09:58:40.829Z","updated":"2017-10-29T09:58:40.829Z","comments":true,"path":"2017/10/29/jpa/3장-영속성관리/","link":"","permalink":"https://joont92.github.io/2017/10/29/jpa/3장-영속성관리/","excerpt":"","text":"엔티티 매니저 : 엔티티를 저장하는 가상의 데이터베이스로 볼 수 있다.(엔티티 저장,수정,삭제 등) 1234// 엔티티 매니저를 생성하기 위해선 공장이 필요하다.EntityManagerFactory emf = Persistence.createEntityManagerFactory(&quot;영속성 유닛&quot;);// 엔티티 매니저 생성EntityManger em = emf.createEntityManger(); 공장을 만드는 과정은 굉장히 비용이 많이들고, 공장에서 Entity Manager를 생성하는 과정은 비용이 거의 들지 않는다.그러므로 EntityMangerFactory는 하나만 만들어서 어플리케이션 전체에서 공유해야 한다. 엔티티 매니저 팩토리는 여러 스레드가 동시에 접근해도 안전하지만 엔티티 매니저는 그렇지 않다(동시성 문제). 절대 공유해선 안된다. 위는 JPA를 사용하는 일반적인 웹 어플리케이션의 모습이다.대부분의 JPA 구현체는 EntityManagerFactory를 만들 때 커넥션 풀을 생성한다.그리고 Entity Manager는 필요한 시점(대부분 트랜잭션을 시작할 때)까지 db 커넥션을 얻지 않는다. 영속성 컨텍스트엔티티를 영구 저장하는 논리적인 환경을 말한다. 엔티티 매니저를 생성하면 영속성 컨텍스트가 만들어지고, 엔티티 매니저를 통해 영속성 컨텍스트에 접근/관리 할 수 있다. 엔티티 생명주기엔티티에는 4가지 상태가 존재한다. 비영속간단하게 엔티티 객체를 생성한 상태를 얘기한다.영속성 컨텍스트나 데이터베이스와는 전혀 관련이 없는 상태이다. 12User user = new User();// ... 영속엔티티 매니저를 통해 엔티티를 영속성 컨텍스트에 저장한(엔티티가 영속성 컨텍스트에 의해 관리되는) 상태이다. 123// 아래와 같은 상황들이 영속상태를 만든다em.persist(entity);em.find(entity_id); 준영속영속성 컨텍스트가 더이상 엔티티를 관리하지 않으면 준영속 상태가 된다. 1234em.detach(entity);em.clear();em.close(); 삭제엔티티를 영속성 컨텍스트와 데이터베이스에서 삭제한다. 1em.remove(entity); 영속성 컨텍스트 특징 엔티티는 무조건 식별자 값이 있어야한다. 영속성 컨텍스트 -&gt; 데이터베이스는 트랜잭션을 커밋하는 순간에 일어난다. 이를 flush라고 한다. 엔티티 조회영속성 컨텍스트는 내부 캐시를 가지고 있다. 영속 상태로 관리되는 엔티티는 전부 이 캐시에 저장된다.캐시의 형태는 Id와 entity가 key/value로 저장된 map으로 보면 된다.find 등을 통해 엔티티를 조회할 때 이 캐시를 먼저 조회하고, 없으면 데이터베이스에서 조회한다.persist로 저장한 엔티티, find로 찾은 엔티티(데이터베이스에서 조회해온)가 1차 캐시 저장 대상이다.간단히 설명하면 위의 그림과 같다. 영속 엔티티의 동일/동등성 동일성 : 인스턴스가 같다. ==로 비교함 동등성 : 인스턴스가 가지고 있는 값이 같다. equlas로 비교함 1차 캐시에서 가져온 엔티티의 경우는 동일성이 성립하는 특징이 있다.Map에서 인스턴스를 가져온 것이기 때문에 어찌보면 당연하다!!1234User user1 = em.find(User.class, \"uid1\");User user2 = em.find(User.class, \"uid1\");Assert.assertTrue(user1==user2); 엔티티 등록아래는 엔티티 등록 예제이다12345678910111213EntityManager em = emf.createEntityManager();EntityTransaction transaction = em.getTransaction();transaction.begin(); // 트랜잭션 시작 필수Member member1 = ...;Member member2 = ...;em.persist(member1);em.persist(member2);// insert를 db에 날리지 않음transaction.commit(); // flush 위는 엔티티등록 과정을 간단히 그림으로 나타낸 것이다.보다시피 persist 명령어를 수행했을 때, 아래의 행위를 한다. 영속성 컨텍스트에 엔티티 저장 수행될 SQL을 SQL 저장소에 저장 최종 커밋 시 영속성 컨텍스트를 플러시(db에 반영)한다.","categories":[{"name":"jpa","slug":"jpa","permalink":"https://joont92.github.io/categories/jpa/"}],"tags":[]},{"title":"사용자/그룹 관리","slug":"linux/사용자-그룹-관리","date":"2017-10-29T09:23:55.909Z","updated":"2017-10-29T09:23:55.909Z","comments":true,"path":"2017/10/29/linux/사용자-그룹-관리/","link":"","permalink":"https://joont92.github.io/2017/10/29/linux/사용자-그룹-관리/","excerpt":"","text":"리눅스는 여러명의 사용자가 동시에 로그인하여 시스템을 사용할 수 있는 멀티유저 운영체제이다.이러한 사용자들은 각각 계정을 가지고 시스템에 접근하게 된다.그리고 이 사용자들을 묶어서 관리할 수 있는 그룹이라는 것이 있다.모든 사용자는 하나의 그룹을 가진다. 사용자 관리/etc/passwd : 사용자 정보가 담긴 파일123root:x:0:0:root:/root:/bin/bash# 사용자명:패스워드:UID:GID:사용자정보:홈디렉토리:쉘 사용자명 : 로그인 시 사용하는 사용자명. 네이밍 규칙 : 영문자 대소문자, 숫자, “-“, “_”, “.” 사용 가능, 보통 1~32자 사용 패스워드 : /etc/shadow 파일에 암호화되어 저장되어 있다. UID : 사용자 고유 ID 일반 사용자는 1000~60000을 사용한다(/etc/login.defs에 명시)root 는 0으로 예약되어 있다. GID : 사용자가 속한 그룹 고유 ID 사용자정보 : 사용자에 대한 간단한 정보를 기입할 수 있다. 홈디렉토리 : 사용자 폴더. 로그인 시 최초 접속되는 폴더이기도 하다. 쉘 : 사용자가 사용하는 쉘 환경 사용자 추가12345678910111213&gt; useradd [options] 사용자명 # options# -c [텍스트] : 사용자정보# -m : 홈디렉토리 생성# -M : 홈디렉토리 생성 안함# -d [폴더] : 홈디렉토리 지정# -N : 사용자 개인 그룹 생성하지 않음. default : 생성# -u [UID] : UID 직접 지정# -g [GID] : GID 직접 지정# -s [Shell] : shell 지정# 이 외에도 많은 옵션이 존재한다. useradd --help 를 활용한다. 생성 시 사용하는 default 값을 확인하고 바꿀 수 있다.1234567891011121314151617181920&gt; useradd -DGROUP=100HOME=/homeINACTIVE=-1EXPIRE=SHELL=/bin/shSKEL=/etc/skelCREATE_MAIL_SPOOL=no&gt; useradd -D -b /test&gt; useradd -DGROUP=100HOME=/test #변경됨INACTIVE=-1EXPIRE=SHELL=/bin/shSKEL=/etc/skelCREATE_MAIL_SPOOL=no# 위에 대한 설정파일은 /etc/default/useradd 이다 사용자 추가 시 홈 디렉토리에 생성되는 파일123456789101112&gt; useradd user1 -m&gt; cd /home/user1&gt; ls -al합계 32drwxr-xr-x 2 user1 user1 4096 10월 29 16:23 .drwxr-xr-x 4 root root 4096 10월 29 16:23 ..-rw-r--r-- 1 user1 user1 220 9월 1 2015 .bash_logout-rw-r--r-- 1 user1 user1 3771 9월 1 2015 .bashrc-rw-r--r-- 1 user1 user1 655 6월 25 2016 .profile-rw-r--r-- 1 user1 user1 8980 4월 20 2016 examples.desktop# /etc/skel에 있는 파일을 복사해 사용한다. 사용자 수정12345678910111213141516171819&gt; usermod [options] 사용자명 # options# -c [텍스트] : 사용자정보 수정# -d [폴더] : 홈디렉토리 변경# -u [UID] : UID 변경# -s [Shell] : shell 지정# -L : 계정 락킹# -U : 계정 언락킹# -g [group] : 사용자 기본 그룹 변경 &gt; usermod -g user2 user1 # user1의 기본 그룹을 user2로 변경# -G [groups] : 사용자 그룹 추가,변경(제거). 기본 그룹은 영향을 받지 않는다. &gt; usermod -a -G group1,group2 user1 # user1에 group1,group2를 추가. -a 옵션으로 기존 그룹 +group1, group2 된다. &gt; usermod -G group1 user1 # 그룹을 제거하는 방법. user1의 기존 그룹을 날리고 group1만을 지정 패스워드 변경123456&gt; passwd [options] 사용자명# options# -d : 패스워드 삭제# -e : 패스워드 강제 만료# -l, -u : 패스워드 락킹/언락킹. usermod에 있는 -L, -U 옵션을 쓰는것이 더 좋다고 한다.. 사용자 삭제12345userdel [options] 사용자명# options # -r : 사용자의 홈디렉토리, 메일박스, 임시디렉토리 까지 같이 삭제. 그룹은 기본적으로 속한 사용자가 없으면 자동 삭제된다 그룹 관리/etc/group : 그룹 정보가 담긴 파일123sudo:x:27:user1,user2# 그룹명:패스워드:GID:사용자리스트 그룹명 : 그룹의 이름이다 패스워드 : 그룹 패스워드 GID : 그룹 고유 ID 사용자리스트 : 해당 그룹에 속한 사용자들의 리스트. 생략되는 경우도 많기 때문에 비어있다고 그룹에 속한 사용자가 없다고 확신할 수 없다. 그룹 추가1234&gt; groupadd [options] 그룹명# options# -g [GID] : GID 지정 그룹 수정1234&gt; groupmod [options] 그룹명# options# -n [이름] : 그룹명 변경 그룹 삭제1&gt; groupdel 그룹명","categories":[{"name":"linux","slug":"linux","permalink":"https://joont92.github.io/categories/linux/"}],"tags":[]},{"title":"관리자 권한 전환","slug":"linux/관리자-권한-전환","date":"2017-10-29T09:07:27.000Z","updated":"2017-11-27T13:19:51.000Z","comments":true,"path":"2017/10/29/linux/관리자-권한-전환/","link":"","permalink":"https://joont92.github.io/2017/10/29/linux/관리자-권한-전환/","excerpt":"","text":"Windows에서 최고 관리자가 Administrator였다면, 리눅스에서는 root입니다.보안상의 이유로 root로 직접 로그인하는 것은 권장되지 않고,일반 사용자로 로그인 한 뒤, 필요시에 root 권한으로 작업하는 것을 권장합니다. sudo일반 사용자가 root 권한으로 명령어를 실행하고자 할 떄 사용하는 명령어입니다.1sudo cat /etc/shadow 당연히 누구나 사용할 순 없고, 허가된 사용자만이 사용 가능한 명령어입니다.이를 확인하기 위해선 /etc/sudoers 파일을 확인해야 합니다. 현재 우분투를 사용하고 있으므로, 우분투를 기점으로 해당 파일을 열어봤을때12# Allow members of group sudo to execute any command%sudo ALL=(ALL:ALL) ALL 부분을 발견할 수 있습니다. 보다시피 sudo 그룹에 해당하는 멤버들은 모든 명령어를 사용할 수 있다고 명시되어 있습니다.(기본적으로 관리자 계정으로 등록된 사용자는 sudo 그룹에 소속되어 있음) 그럼 유저를 하나 만들고, sudo 명령어를 사용 가능하도록 만들어보겠습니다. 12345678910111213141516171819202122232425# 먼저 사용자 추가를 위해 root 계정으로 변경합니다. (su 명령어는 아래서 설명)&gt; su -# user1 추가 및 패스워드 설정&gt; useradd -m user1&gt; passwd user1&gt; su - user1&gt; sudo cat /etc/shadow[sudo] password for user1: user1 is not in the sudoers file. This incident will be reported.# sudo 명령어를 실행할 수 없다.# user1에 sudo 그룹을 추가&gt; su - &gt; usermod -G sudo user1# 다시 실행&gt; su - user1&gt; sudo cat /etc/shadow[sudo] password for user1: root:x:0:0:root:/root:/bin/bashdaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin.....# 출력이 잘 된다! sudo 명령어를 통해 root 권한으로 명령어를 실행하고 나면 다시 일반 사용자 권한으로 돌아오게 됩니다.sudo 명령어 실행 시 입력한 암호는 5분 동안 유지됩니다! (5분간 암호를 재입력하지 않아도 됨) susudo 처럼 잠시 관리자 권한을 빌려오는 것이 아니라, 아예 관리자 권한으로 전환할 때 사용합니다.123&gt; su - 암호 :root@:~# - 옵션을 주어야 root 사용자의 환경변수까지 다 읽어오게 됩니다.입력하지 않을 경우 환경변수가 없어 명령어를 찾지 못하는 현상이 발생할 수도 있습니다. su 뒤에 사용자명을 입력하여 root가 아닌 다른 사용자로 전환할 수도 있습니다.123&gt; su - user2암호 : user2@:~$","categories":[{"name":"linux","slug":"linux","permalink":"https://joont92.github.io/categories/linux/"}],"tags":[]},{"title":"hexo와 github pages로 블로그 만들기","slug":"etc/hexo와-github-pages로-블로그-만들기","date":"2017-10-29T09:00:38.907Z","updated":"2017-10-29T09:00:38.907Z","comments":true,"path":"2017/10/29/etc/hexo와-github-pages로-블로그-만들기/","link":"","permalink":"https://joont92.github.io/2017/10/29/etc/hexo와-github-pages로-블로그-만들기/","excerpt":"","text":"이번엔 앞서 작성한 github-pages에 블로그 서비스를 하기 위해 정적 사이트 생성 도구인 hexo에 대해 알아보겠습니다. Hexo블로그 형태의 정적사이트를 생성하는데 사용되는 도구입니다. hexo는 사용자가 작성한 포스트(markdown 등)을 읽어서, 정적파일 생성기를 통해 웹서버에 바로 서비스 할 수 있는 형태의 정적 웹사이트를 만들어냅니다. 대표적인 것으로 jekyll이 있지만 hexo가 좀 더 편해보이고 테마도 맘에 들어서 hexo를 사용하기로 했습니다 ㅎㅎ 설치 사전준비 : Node.js,npm,git 바로 설치하고 초기화 해보겠습니다. 12npm install -g hexo-clihexo init '폴더명' ‘폴더명’에 입력한 폴더를 만들고 그 폴더에 hexo 관련 파일을 초기화합니다. (폴더를 지정하지 않으면 현재 폴더에 초기화하는데, 현재 폴더가 비어있는 상태여야 합니다.) 아래는 초기화 후 폴더 모습입니다! 빨간색으로 표시해둔 _config.yml에서 블로그에 대한 대부분의 설정을 할 수 있습니다. 초기화가 완료되면 간단하게 로컬에서 테스트 해보도록 할까요 해당 폴더로 이동하여 1hexo server 라고 입력하면, INFO Start processing INFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 라는 메시지와 함께 http://localhost:4000 으로 접속 가능합니다. 기본 테마로 생성된 정적 블로그 페이지를 볼 수 있을 것입니다 ㅎㅎ 테마 적용하지만 이대로 사용할 순 없으니 테마를 한번 적용해보도록 하죠. 적용방법은 매우 간단합니다. https://hexo.io/themes/index.html 위의 주소에 접속한 뒤, 마음에 드는 테마를 고르시면 됩니다. 각 테마의 github 페이지에 들어가면 테마 적용 방법에 대한 상세한 설명이 있으니 별로 어려움 없으실 겁니다 ㅎㅎ 제가 고른 테마는 Material Flow 라는 테마입니다. gitgub : https://github.com/stkevintan/hexo-theme-material-flow 보시다시피 매우 간단합니다. 소스를 clone받고 _config.yml에서 해당 테마로 지정해주기만 하면 됩니다. 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: material-flow 설정이 다 되었으면 12hexo cleanhexo generate # 정적 리소스 생성 와 같이 입력하여 정적 리소스를 생성해주면 됩니다. 간혹 제대로 되지 않는 경우도 있기 떄문에 clean도 한번 해줬습니다. 이제 다시 hexo server 입력 후 들어가보시면 테마가 잘 적용되어 있음을 보실 수 있습니다! 글을 써보자블로그를 만들었으니 글을 써야겠네요. 123hexo new post [post_name]# ex) hexo new post 'first post'# ex) hexo new post first-post 과 같이 입력하면, 폴더에 아래와 같은 형태로 markdown 파일이 하나 생성됩니다.1234567```md---title: first postdate: 2017-09-23 10:51:08tags:--- 각종 폴더나 카테고리에 대한 설정도 _config.yml에서 할 수 있으니 각자 설정하시면 됩니다 ㅎㅎ 배포이제 github에 배포해보도록 하겠습니다 ㅎㅎ 먼저 _config.yml에 deploy 관련 설정을 해 줍니다. 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/joont92/joont92.github.io.git branch: master 저장한 뒤 123456hexo cleanhexo generate # 정적파일 생성하고hexo deploy # 배포!# hexo deploy --generate 로도 가능 와 같이 해주면 끝입니다. 매우 간단하죠?? 배포시 아래와 같은 메시지와 함께 배포가 되지 않는 경우1ERROR Deployer not found: git hexo-deployer-git 플러그인을 설치해주면 됩니다. 1npm install hexo-deloyer-git --save 여기까지입니다 ㅎㅎ 블로그에 markdown을 사용할 수 있고, git의 형상관리를 블로그에 사용할 수 있다니 매우 좋은것 같네요. 들려주셔서 감사합니다~~","categories":[{"name":"etc","slug":"etc","permalink":"https://joont92.github.io/categories/etc/"}],"tags":[]},{"title":"markdown","slug":"etc/markdown","date":"2017-10-29T08:59:18.559Z","updated":"2017-10-29T08:59:18.562Z","comments":true,"path":"2017/10/29/etc/markdown/","link":"","permalink":"https://joont92.github.io/2017/10/29/etc/markdown/","excerpt":"","text":"문단 쓰기, 줄바꿈기본적으로 마크다운은 엔터 한번은 그냥 무시하고 한 문단으로 간주합니다.띄워쓰기를 표시하려면 2번의 엔터를 쳐야 합니다.그러나 몇몇 마크다운 에디터에서는 ‘엔터 한번’ == ‘개행’을 지원하기도 합니다.1234개행 테스트개행!진짜 개행 개행 테스트개행! 진짜 개행 html 직접 사용 가능12&lt;hr /&gt;&lt;span style=&quot;color:red&quot;&gt;**red**&lt;/span&gt; > 출력 red 특수문자 자동 적용됨12&lt;div&gt; 태그를 사용하자&amp;lt;div&amp;gt; 태그를 사용하자 > 출력 태그를 사용하자&lt;div&gt; 태그를 사용하자 제목. 6개 크기 까지 지원한다1234567# h1## h2### h3#### h4##### h5###### h6####### h7 h1h2h3h4h5h6####### h7 인용1234&gt; 인용되는 글&gt; 길게길게길게길게길게길게길게길게길게길게길게길게길게길게길게길게길게길게길게길게길게길게길게길게길게길게길게길게길게길게&gt;&gt; depth를 늘림&gt; 내부에서 **markdown** 사용 가능 > 출력 인용되는 글길게길게길게길게길게길게길게길게길게길게길게길게길게길게길게길게길게길게길게길게길게길게길게길게길게길게길게길게길게길게 depth를 늘림, 변경할때는 아래와 같이 빈줄 하나 넣어야 함. 내부에서 markdown 사용 가능 리스트12345678910111213141516171819202122232425262728293031숫자의 경우 자동으로 넘버링 된다.처음쓰는 리스트의 숫자부터 카운트 된다.1. 숫자2. 숫자3. 숫자순서를 바꿔도 1,2,3 으로 출력된다1. 숫자4. 숫자7. 숫자일반 리스트는 *, +, - 중 아무거나 쓰면 된다.* 일반 리스트- 일반 리스트+ 일반 리스트리스트 안에 두 문단이상 사용할 경우, tab을 사용한다.계속해서 이어가려면 아래와 왼쪽 탭 정렬선을 맞춰줘야 한다.- 첫번째 리스트이어지는 문단1이어지는 문단2- 두번째 리스트 > 출력 숫자의 경우 자동으로 넘버링 된다. 처음쓰는 리스트의 숫자부터 카운트 된다. 숫자 숫자 숫자 순서를 바꿔도 1,2,3 으로 출력된다 숫자 숫자 숫자 일반 리스트는 *, +, - 중 아무거나 쓰면 된다. 일반 리스트 일반 리스트 일반 리스트 리스트 안에 두 문단이상 사용할 경우, tab을 사용한다.계속해서 이어가려면 아래와 왼쪽 탭 정렬선을 맞춰줘야 한다. 첫번째 리스트 이어지는 문단1 이어지는 문단2 두번째 리스트 이스케이프 문자태그로 변형되는 문자를 그냥 사용하고 싶을 때가 있습니다.(&gt;, - 등) 그냥 사용하면 md에서 해석해버리므로 앞에 \\ 를 붙여줍니다.123\\&gt; : 원래는 인용으로 표시됨1998\\.서울올림픽 : 원래는 1.서울올림픽으로 표시됨(자동 넘버링)\\- : 원래는 리스트로 표시됨 > : 원래는 인용으로 표시됨 1998.서울올림픽 : 원래는 1.서울올림픽으로 표시됨 - : 원래는 리스트로 표시됨 코드 블록마크다운 내에서 코드를 표현 가능하다!키보드 왼쪽 가장자리에 있는 ` 키를 사용하면 된다.\\사용하는 언어를 넣어주면 해당 문법에 맞게 해석한다12345&gt; \\```javascript &gt; var str = &apos;test str&apos;; &gt; console.log(str); &gt; \\ > 출력 12var str = 'test str';console.log(str); 수평선123456편한대로 골라쓰면 된다.**** * *---- - - > 출력 편한대로 골라쓰면 된다. * 강조하기*나, _를 사용하여 표시한다. 12*이탤릭***볼드** > 출력 이탤릭 볼드 취소선1~~취소~~ > 출력 취소 링크 걸기링크 주소 자체에 링크를 거는 방법과, 문구를 사용하는 방법이 있다. 물론 상대경로도 가능하다! \\http://주소\\ [링크걸 문구](http://주소\\) 12345&lt;http://google.com&gt;[구글](http://google.com)상대경로 : [1번 포스트](/1) > 출력 http://google.com 구글 상대경로 : 1번 포스트 이미지 삽입![사진이름](사진경로) 1![테스트사진](http://leader.pubs.asha.org/data/Journals/ASHANL/934378/NIB1_web.png) > 출력 테이블| 와 - 로 구분하여 테이블을 그릴 수 있다.1234Field1 | Field2 | Field3-|-|-Data1 | Data2 | Data3Data4 | Data5 | Data6 > 출력Field1 | Field2 | Field3-|-|-Data1 | Data2 | Data3Data4 | Data5 | Data6 헤드부분, 즉 html의 th부분은 꼭 있어야 한다! (상단 2줄) emojigithub은 emoji를 지원한다.https://www.webpagefx.com/tools/emoji-cheat-sheet/","categories":[{"name":"etc","slug":"etc","permalink":"https://joont92.github.io/categories/etc/"}],"tags":[]},{"title":"1장 - JPA소개","slug":"jpa/1장-JPA소개","date":"2017-10-28T13:54:16.361Z","updated":"2017-10-28T13:54:16.361Z","comments":true,"path":"2017/10/28/jpa/1장-JPA소개/","link":"","permalink":"https://joont92.github.io/2017/10/28/jpa/1장-JPA소개/","excerpt":"","text":"※ ORM은 객체지향과 관계형 데이터베이스의 상위 단계이므로 학습곡선이 높다.SQL Mapper : Mybatis, JdbcTemplate..JPA : Hibernate, EclipseLink.. 기존 JDBC엔티티 &lt;&gt; SQL 매핑을 항상 해줘야함.엔티티는 SQL에 의존적임. 그러므로 엔티티를 신뢰할 수 없다.(항상 결국엔 SQL을 확인해야함)엔티티는 SQL을 자바로 가져오기 위해 존재하는 도메인 객체 역할 정도밖에 안됨. 그에 반해 JPA는 JPA가 사용하는 API에 엔티티를 넣어주면 자동으로 SQL 쿼리를 만들어 실행해주므로 엔티티를 신뢰할 수 있다. 자바 객체와 RDB의 패러다임 불일치1) 상속abstract class Item{ Long Id; String name; int price;}class Album Extends Item{ String artist;}class Movie Extends Item{ String director;}자바는 위와 같이 상속구조가 가능하나, RDB는 상속구조가 없다.데이터 모델링의 DTYPE을 이용하면 상속 비슷하게 구현할 수 있긴하다. ※ DTYPETable ITEM{ ID(PK), NAME, PRICE.. DTYPE}Table ALBUM{ // ITEM과 연결 ID(PK, FK) , ARTIST} 모델링에서 위와 같이 DTYPE을 이용해 구성할 경우자바에선 ITEM, ALBUM의 CRUD를 이중으로 수행하는 상황이 온다.(ITEM, ALBUM)이것이 각자의 패러다임을 맞추기 위한 낭비이다. JPA는 ALBUM 객체만 전달하면 알아서 수행 2) 연관관계객체는 참조를 통해 객체끼리 연관관계를 가지고, 해당 참조에 접근해서 연관 객체를 조회한다.테이블은 외래키를 사용하고, 조인을 이용해 연관 테이블을 조회한다. 둘의 패러다임이 완전히 다르다. 자바는 부모 객체를 통해 자식 객체를 조회 가능하지만 그 반대는 불가능하다. 그러나 테이블은 양쪽 조회가 가능하다.(JOIN) ★ 객체는 참조를 통해 연관관계를 가지지만, 테이블은 JOIN이라는 기능을 통한다. 서로의 패러다임을 맞추기가 힘들다. JAVA의 패러다임에 맞추자니 개발자가 직접 변환해줘야 하기도 하고, 굉장히 복잡해진다. 그렇다고 RDB의 패러다임에 맞추자니 객체지향의 특징을 잃어버린다.JPA는 JAVA의 연관관계를 편하게 사용 가능하다. 참조를 통한 관계를 설정하고, ORM Framework에 전달만 해주면 된다. (JAVA의 패러다임에 맞춰 엔티티 설계하고, 복잡한 과정은 JPA가 대신해준다.) 3) 객체 그래프 탐색Member member = memberDao.find(mid);member.getTeam();member.getTeam().getName();// 이와 같이 참조를 이용해서 파고드는 행위를 객체 탐색이라고 한다. 근데 사실상 아래와 같은 코드들(JPA를 사용하지 않는)member.getTeam();member.getOrder().getDelivery(); 의 탐색 깊이는 결국 SQL문에 의존적이라는 것이다.객체가 아무리 연관관계를 가진들 SQL에서 Order 테이블을 JOIN 하지 않았으면 2행은 Null Exception이 발생할 것 아닌가.. 그렇다고 조회마다 Member에 관련된 모든 객체를 조회해서 메모리에 올려두는것은 비효율적.상황에 따라 조회하는 메서드를 만들어야 한다. JPA에서는 연관 객체를 사용하는 시점에 select 쿼리를 실행할 수 있다(Lazy Loading) 게다가 JPA는 이를 투명하게(transparent) 처리하므로 DAO에 따로 코드가 있지 않고 getOrder() 함수를 호출할 때 지연 로딩을 한다. 이는 엔티티 설정에서 줄 수 있다. 지연로딩을 하지 않을 경우 애초에 Member 객체를 얻어올떄 연관객체를 조인하는 쿼리가 실행된다. 4) 비교Java에서는 비교가 동일성, 동등성으로 나뉘기 때문에 복잡해지는 부분이 많다.class MemberDAO(){ publid Member findOne(String id){ // select * from member where id=? 실행 Member memeber = new Member(); // resultset을 member에 담음 member.setXXX(rs.getString(XXX)); ... return member; } } Member member1 = memberDao.findOne(“id1”);Member member2 = memberDao.findOne(“id1”); member1 == member2 // false; 동일성 비교에서 실패한다. new로 생성된 객체이기 때문이다. 이처럼 db에서 같은 row를 조회했다 하더라도 위의 연산에서 true를 호출하게 하기가 어렵다. 하지만 JPA는 위의 상황에서 동일성을 보장한다. (JPA의 조회 메서드를 사용) JPA란위치Application - JPA - JDBC - DB JPA는 ORM 기술의 표준이다. ORM은 Object Relation Mapping의 약자이다.JPA란 자바 ORM 기술에 대한 API 표준명세. 쉽게 말해 인터페이스들을 모아놓은 것이다.따라서 JPA를 사용하려면 JPA를 구현한 ORM 프레임워크를 선택해야한다. (여러가지가 있으며 하이버네이트가 가장 대중적)성숙한 ORM 프레임워크의 경우 간단한 CRUD외에 다양한 패러다임 문제까지 해결해주므로 개발자가 객체지향 어플리케이션 개발에 집중할 수 있다. Why JPA?1) 생산성 : ORM Framework에 엔티티만 전달하면 되므로, SQL을 개발자가 직접 작성하지 않아도 된다.2) 유지보수 : 테이블의 명세가 변경되어도 변경할 사항이 많지 않다. 엔티티만 변경해주면 된다. (쿼리가 자동생성이므로) ex) 테이블에 컬럼이 추가되거나 삭제될 경우 JPA는 엔티티만 수정하면 되지만, mybatis의 경우 해당 엔티티를 사용하는 쿼리를 전부 수정해줘야 한다.3) 패러다임 불일치 해결4) JPA는 application과 jdbc사이에서 동작하기 때문에 시도할 수 있는 성능 최적화가 있다. 위의 “4) 비교” 의 경우가 그렇다. 똑같은 row를 조회할 때 jdbc에 쿼리를 2번 보내지 않고, 기생성된 인스턴스를 사용한다.5) 추상화 되어 있으므로 DB변경 또한 용이함. 벤더의 독립성","categories":[{"name":"jpa","slug":"jpa","permalink":"https://joont92.github.io/categories/jpa/"}],"tags":[]},{"title":"2장 - JPA 시작","slug":"jpa/2장-JPA-시작","date":"2017-10-28T13:54:10.285Z","updated":"2017-10-28T13:54:10.285Z","comments":true,"path":"2017/10/28/jpa/2장-JPA-시작/","link":"","permalink":"https://joont92.github.io/2017/10/28/jpa/2장-JPA-시작/","excerpt":"","text":"H2 데이터베이스따로 설치할 필요없이 자바만 설치되어 있으면 사용할 수 있는 경량(1.7M) 데이터베이스이다.(h2database.com에서 다운로드 가능)JVM 메모리 안에서 실행되는 임베디드 모드와 별도의 서버를 띄우는 서버모드가 있다. ※ package가 javax.persistence인것은 JPA 표준이므로 특정 구현체에 종속되지 않으나hibernate로 시작되는건 hibernate만 사용 가능 JPA 설정1) 어노테이션@Entity : 이 엔티티는 테이블과 매핑한다고 JPA에게 알려줌@Table : 엔티티에 매핑될 테이블 정보를 알려줌(name 속성을 사용). 생략 시 클래스 이름을 사용@Id : 기본키 매핑@Column : 컬럼 매핑. name 속성에 테이블의 속성명을 써준다. 생략시 필드명을 사용 2) persistence.xmlJPA 설정정보이다. META-INF 안에 있으면 자동으로 인식한다\\ 태그로 시작. namespace와 version 지정\\ 이라는 영속성 유닛 지정. 일반적으로 DB하나당 하나의 영속성 유닛을 등록한다. 필수 속성1) JPA 표준 속성javax.persistence.jdbc.driverjavax.persistence.jdbc.userjavax.persistence.jdbc.passwordjavax.persistence.jdbc.url2) 하이버네이트 속성hibernate.dialect dialect는 데이터베이스 방언을 의미한다. 방언은 특정 데이터베이스만의 고유한 기능을 뜻한다. JPA에서 특정 데이터베이스의 기능은 여기 방언에 지정한 클래스로 처리한다. 즉, DB가 교체되어도 이 방언만 수정해주면 된다. 이 외에 optional한 속성들이 있다(쿼리 로그, 쿼리 포맷, 주석 등등) 실습Hibernate의 기능을 사용하려면 EntityManager 라는 클래스를 사용해야 한다.(mybatis에서 sqlSession 이었던 것처럼)EntityManager를 얻으려면 먼저 EntityManagerFactory를 생성해야 한다. EntityManagerFactory emf = Persistence.createEntityManagerFactory(“영속성유닛”); persistence.xml의 내용을 읽어 EntityManagerFactory를 생성한다.중요한점은 위의 엔티티 매니저 팩토리를 생성하는 비용이 매우 크다는 것이다.그러므로 엔티티 매니저 팩토리는 딱 1번만 생성하고 공유해서 사용해야 한다. EntityManager em = emf.createEntityManager(); 엔티티 매니저 팩토리에서 엔티티 매니저를 생성한다.JPA의 대부분 기능은 이 EntityManager에서 제공한다(CRUD)하나의 엔티티 매니저는 하나의 데이터소스를 유지하면서 통신한다.데이터베이스 커넥션과 밀접한 관련이 있으므로 스레드간에 공유하거나 재사용하면 안된다. 예시)※ JPA를 사용해서 데이터를 변경하려면 항상 트랜잭션 안에서 수행해야한다. 아니면 예외가 발생한다.Member member = new Member();member.setXXX(“XXX”);…. em.persist(member); // 저장 member.setXXX(“XXX”); // 수정. JPA는 어떤 엔티티가 변경되었는지 추적하는 기능을 갖추고 있다. em.remove(member); // 삭제// Member Entity에 @Id 컬럼으로 지정한 부분을 조건으로 삭제를 진행한다. em.find(Member.class, id); // select * from member where id=?// @Id 컬럼으로 지정한 부분을 조건으로 조회하는 아주 단순한 조회 메서드이다. JPQLORM의 한계를 위해 존재하는 부분.select의 기본 문법을 지원함. 그러나 대상이 RDB의 테이블이 아니라 Entity이다. TypedQuery query = em.createQuery(JPQL, return Type); T t = query.getReulstList();ex) em.createQuery(“select m from Member m”, Member.class);// Member는 MEMBER테이블이 아니라 엔티티 Member이다.","categories":[{"name":"jpa","slug":"jpa","permalink":"https://joont92.github.io/categories/jpa/"}],"tags":[]},{"title":"스프링 웹 기술과 스프링 MVC","slug":"spring/스프링-웹-기술과-스프링-MVC","date":"2017-10-28T13:48:40.821Z","updated":"2017-10-28T13:48:40.821Z","comments":true,"path":"2017/10/28/spring/스프링-웹-기술과-스프링-MVC/","link":"","permalink":"https://joont92.github.io/2017/10/28/spring/스프링-웹-기술과-스프링-MVC/","excerpt":"","text":"스프링의 웹 프레젠테이션 계층 기술presentation layer =스프링 웹 기술을 사용하는 프레젠테이션 계층 + 스프링 외의 웹 기술을 사용하는 프레젠테이션 계층 컨텍스트root contetxt : 웹 기술에서 독립적인 비즈니스 계층, 데이터 엑세스 계층servlet application context : 스프링 웹 기술을 기반. 웹 관련 빈> 통째로 다른 기술로 교체하기 용이하기 위해서 스프링 서블릿은 mvc 아키텍쳐를 따르는 웹 프레임워크를 구축할 수 있는 유연한 기반을 제공@MVC와 같이 스프링이 확장시켜 만든 프레임워크도 있다. JSP/Servelt에서 스프링 빈 사용하려면 WebApplicationContextUtils의 스태틱 메서드를 사용하면 된다.JSP에서 사용할 수 있는 HttpServletRequest 타입의 오브젝트를 이용하여 ServletContext를 가져올 수 있다.123ApplicationContext context =WebApplicationContextUtils.getWebApplicationContext(request.getSession().getServletContext());HelloBean helloBean = context.getBean(HelloBean.class); 스프링 : 유연성, 확장성, 다양성에 무게를 둠집착에 가까울 정도로 모든 기능을 확장 가능하도록 설계되어 있다.스프링을 잘 사용하는 법은 스프링 프레임워크를 완성된 고정적인 프레임워크로 보지말고,스프링이 가진 기존 기능을 확장해서 프로젝트에 맞는 프레임워크로 확장하는 것이다. DispatcherServlet, MVC architecture스프링 웹 기술은 MVC 아키텍쳐를 기반으로 하고있고, 핵심 기술은 DispatcherServlet이다.M(Model) : 프레젠테이션 계층의 구성요소 정보를 담음V(View) : 화면 출력 로직C(Controller) : 제어 로직 프론트 컨트롤러 패턴 :중앙 집중형 컨트롤러(e.g. DispatcherServlet)을 계층의 젤 앞에 둬서 요청을 가장 먼저 받아 처리하게 만드는 패턴선행작업, 뷰 선택, 예외처리 등을 행한다. DispatcherServlet의 requset -&gt; response과정 web.xml등에 따라 요청을 dispatcherServlet이 받고, 공통적으로 진행해야 하는 전처리 작업 등을 한다.e.g 보안, 파라미터 조작, 디코딩 등 url, parameter 정보 등을 사용하여 어떤 컨트롤러에게 작업을 위임할 지 결정(핸들러 매핑 전략)개발자는 어떤 오브젝트가 처리할지를 매핑하는 전략을 만들어 DI가능하도록 제공해주기만 하면 된다.이후 요청이 들어오면, DispatcherServlet은 컨트롤러를 선택하고, 해당 메서드를 실행하여 실제 작업을 처리한다.여기서 중요한 것은 컨트롤러가 특정 인터페이스를 구현하는 식의 규약을 따르지 않았다는 것이다.그러한데도 DispatcherServlet이 컨트롤러의 메서드를 호출할 수 있는 이유는 어댑터 라는 것을 이용하기 때문이다. DispatcherServlet -&gt; HandlerAdapter -&gt; Controller 의 형태이다.DispatcherServlet은 모든 웹 요청정보가 담긴 HttpServletRequest 오브젝트를 전달해주고,이를 어댑터가 컨트롤러 메서드가 받을 수 있도록 파라미터로 변환하여 전달한다. (HttpServletResponse도 전달해준다) 컨트롤러는 사용자의 요청을 해석하여 로직을 수행한 뒤 결과에 따라 모델을 생성한다. 모델은 key, value로 이뤄진 쌍이라고 보면 된다.이후 뷰를 선택한다. 뷰도 하나의 오브젝트이다. 컨트롤러가 직접 선택할 수도 있지만 보통은 논리적인 이름을 리턴해주고,DispatcherServlet의 뷰 리졸버가 이를 이용해 뷰 오브젝트를 생성해준다.이후 준비된 모델과 뷰를 DispatcherServlet에 돌려줌으로써 컨트롤러의 역할은 끝난다.(ModelAndView, Model 등의 오브젝트를 사용하여 전달할 수 있다.) DispatcherServlet은 뷰 오브젝트에 모델을 전달하고, 결과물을 생성해달라고 요청한다.(JstlView의 경우 컨트롤러가 리턴한 논리적 이름의 jsp 템플릿을 가져다가 HTML을 생성한다.)HTML이 일반적이고, 엑셀, PDF등과 같이 파일 형태로 만드는 뷰도 있다.모델이 같아도 어떤 뷰를 선택하느냐에 따라 결과가 달라질수 있다는 의미이다.최종 결과는 HttpServletReponse에 담긴다. DispatcherServlet은 마지막으로 후처리기가 있는가 확인 후,있으면 후처리를 진행한 뒤 최종 HttpServletResponse를 서블릿 컨테이너에 돌려준다. 서블릿 컨테이너는 이를 HTTP 응답으로 만들어 클라이언트에 전송하고 작업이 종료된다. DispatcherServlet의 확장 가능한 전략(using DI) HandlerMappingURL과 요청정보를 기준으로 컨트롤러를 결정한다. HandlerMapping 인터페이스를 구현해서 만들 수 있다. HandlerAdapterHandlerMapping으로 선택한 컨트롤러를 호출할 때 사용하는 어댑터다.컨트롤러 호출 방법은 타입에 따라 다르기 때문에 컨트롤러를 결정했다고 해도 호출방법을 DispatcherServlet이 알 수가 없으므로, 어댑터가 필요하다. HandlerExceptionResolver비즈니스로직이 아닌 초기 요청단계에서의 Exception은 프론트 컨트롤러인 DispatcherServlet에 의해 처리되어야 한다.DispatcherServlet은 등록된 HandlerExceptionResolver중에 적합한 것을 찾아 예외처리를 위임한다. ViewResolver컨트롤러가 리턴한 논리적 뷰 이름을 통해 뷰 오브젝트를 찾아주는 오브젝트다.디폴트는 InternalResourceViewResolver이며, JSP같은 리소스를 사용할 수 있게 해주는 뷰 리졸버이다. LocaleResolver지역정보를 결정해주는 전략. default인 AcceptHeaderLocaleResolve는 HTTP header정보를 보고 locale정보를 설정한다.이 전략을 바꾸면 파라미터, 쿠키, xml등을 이용할 수도 있다. RequestToViewNameTranslator컨트롤러에서 뷰 정보를 제공하지 않았을 경우 URL등을 이용해서 자동으로 뷰 이름을 생성해주는 전략 DispatcherServlet은 스프링 컨테이너가 아닌 서블릿 컨텍스트가 관리하는 오브젝트이기때문에 직접 DI가 불가능하다. DispatcherServlet은 각 전략의 default 설정을 DispatcherServlet.properties라는 파일로부터 가져와서 초기화하는데, 이전에 개발자가 추가하거나 수정한 전략이 있나 찾아보고 있으면 대체, 없으면 default 전략을 사용한다.","categories":[{"name":"spring","slug":"spring","permalink":"https://joont92.github.io/categories/spring/"}],"tags":[]}]}