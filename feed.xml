<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>기록은 기억의 연장선</title>
  
  <subtitle>더 많은 것을 기억하기 위해 기록합니다</subtitle>
  <link href="/feed.xml" rel="self"/>
  
  <link href="https://joont92.github.io/"/>
  <updated>2020-11-02T10:09:30.457Z</updated>
  <id>https://joont92.github.io/</id>
  
  <author>
    <name>JunYoung Park</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>nextstep 교육과정 및 멘토링 후기</title>
    <link href="https://joont92.github.io/life/nextstep-%EA%B5%90%EC%9C%A1%EA%B3%BC%EC%A0%95-%ED%9B%84%EA%B8%B0/"/>
    <id>https://joont92.github.io/life/nextstep-교육과정-후기/</id>
    <published>2020-11-02T15:33:32.000Z</published>
    <updated>2020-11-02T10:09:30.457Z</updated>
    
    <content type="html"><![CDATA[<h1 id="nextstep-교욱과정"><a class="markdownIt-Anchor" href="#nextstep-교욱과정"></a> nextstep 교욱과정</h1><p>작년 3월, 그러니까 1년 반전 쯤… 이쪽 업계에서는 유명하신 박재성(자바지기)님이 하시는 교육과정을 들은적이 있었다.<br>교육과정명은 <code>클린코드를 위한 TDD, 리팩토링 with Java</code> 이었는데, 과정은 대충 이러했다.</p><h3 id="매주-금요일-3시간의-수업을-진행한다총-5주"><a class="markdownIt-Anchor" href="#매주-금요일-3시간의-수업을-진행한다총-5주"></a> 매주 금요일 3시간의 수업을 진행한다(총 5주)</h3><p>매주 금요일 오후 7시 반에 강남역에 모여서 수업을 진행한다.<br>수업 내용은 대부분 OOP, TDD, refactoring 에 대한 내용이었고, 가끔씩 재성님의 인생 철학(!)을 얘기해주시기도 하신다.<br>수업 내용은 아주 유익하고, 인생 철학 또한 아주 유익하다 ㅋㅋㅋ</p><h3 id="수업과-별개로-과제를-진행한다"><a class="markdownIt-Anchor" href="#수업과-별개로-과제를-진행한다"></a> 수업과 별개로 과제를 진행한다</h3><p>이 과제가 교육과정의 핵심이다.<br>프로그래밍 언어로 자동차 경주 게임, 로또, 사다리 게임 등을 직접 구현하는 과제이다(출력은 콘솔로 한다).<br>단순히 구현하는 것이 아니라, 교육과정 중에 배운 OOP, TDD, refactoring 을 열심히 사용(?)하여 구현해야 한다.<br>그리고 각 과제마다, 담당 코드 리뷰어들이 있다.<br>(리뷰어는 이미 이 과정을 수료하신 분들로 구성되어 있다.)<br>하나의 과제는 여러 step 들로 구성되어 있으며, step 별 요구사항을 완료하여 PR 을 보내면 리뷰어가 리뷰를 해주고, approve 가 되면 다음 step 으로 넘어가게 되는 구조이다.<br>이렇게 총 5개(1개는 optional)의 과제를 완료하면 교육과정을 수료할 수 있게 된다.</p><h3 id="어렵다-어려워"><a class="markdownIt-Anchor" href="#어렵다-어려워"></a> 어렵다 어려워</h3><p>매번 서비스 메서드에 모든 로직을 다 떄려박던 나같은 트랜잭션 스크립터(?)에게 이 과제는 매우 어려웠었다.<br>지금까지 내가 해오던 코딩과는 너무 달랐기 때문이었다.<br>어떤 기준으로 객체를 설계해야할지, 객체끼리는 어떻게 메시지를 주고 받아야할지, 테스트는 제대로 짜고 있는지…<br>그야말로 혼란스러웠다.<br>몇시간동안 한줄도 못 짜고 머리를 싸매며 고통스러워 했었던적도 한두번이 아니었던 것 같다.</p><p>그래도 매일 고민하고, 리뷰어님들의 아주아주 정성스러운 피드백들을 받다보니 시간이 지날수록 조금씩 나아지는 내 모습을 발견할 수 있었다.<br><img src="/temp/nextstep1.png" alt="코드리뷰"></p><blockquote><p>그저 빛…</p></blockquote><p>결과적으로 5주 동안 필수 과제 4개를 전부 완료하고, 한 단계 더 성장한 모습으로 이 과정을 수료할 수 있었다.</p><h3 id="이제는-실전"><a class="markdownIt-Anchor" href="#이제는-실전"></a> 이제는 실전</h3><p>회사로 돌아왔다(교육과정 듣는다고 회사를 안간것은 아니었지만…).<br>회사 코드를 봤다.<br>트랜잭션 스크립트 패턴이 많고, 테스트도 많이 없다. 개선해야 할 부분이 많아 보인다.<br>하지만 코드 자체가 워낙 양이 많고 복잡하며, 다른 코드나 시스템끼리 복잡하게 의존되는 부분이 많아서 어디서부터 어떻게 시작해야할지 정하기가 힘들었다.<br>그래도 훈련소까지 갔다왔는데… 그냥 포기할수는 없었다.</p><p>기존에 존재하던 코드들에 대해 테스트를 작성하기 시작했고, 테스트 작성이 완료되고나니 조금씩 리팩토링 하는것이 가능했다.<br>그렇게 하나의 프로젝트를 전반적으로 리팩토링했다.<br>굉장히 뿌듯했다.</p><p>새로운 프로젝트를 들어갔을때에도, 클린코드에 대한 끈을 놓지 않으려고 했다.<br>항상 테스트를 작성했으며, 객체 설계에 대해 매번 고민하고 작성했다.</p><p>그렇게 1년 정도 실전에서 훈련한 결과, 확실히 코드 자체가 작년에 비해 많이 달라진것을 느끼고 있다.<br>아직 갈 길은 많이 멀었지만, 작년에 이 과정을 듣지 못했다면 아직까지 나는 얽히고 섥힌 코드들을 유지보수하느라 고통받고 있지 않았을까 싶다.</p><hr><h1 id="nextstep-멘토링"><a class="markdownIt-Anchor" href="#nextstep-멘토링"></a> nextstep 멘토링</h1><p>이 교육에는 수업 이후에 멘토링을 해주는 과정이 추가적으로 포함되어 있다.<br>멘토링은 이 과정을 수료한 수강자에 한해서 모두 제공된다.</p><blockquote><p>단순히 수업을 듣는다고 수료가 되는것이 아니라, 필수과제 4개의 과제를 모두 제출해 통과해야만 수료가 된다.</p></blockquote><p>멘토링에서 해주는 내용은 아래와 같다.</p><ul><li>이력서 검토 및 피드백</li><li>온라인, 오프라인 모의 면접</li><li>추천</li></ul><p>어쩌다보니 나도 이번에 이직 시기가 되어서, 멘토링을 신청하게 되었다.</p><h3 id="이력서-검토-및-피드백"><a class="markdownIt-Anchor" href="#이력서-검토-및-피드백"></a> 이력서 검토 및 피드백</h3><p>일단 자유 포멧으로 이력서를 작성해 전달해주면, 이력서를 전체적으로 점검하고 피드백을 작성하여 전달해주신다.<br><img src="/temp/nextstep2.png" alt="이력서 피드백"></p><blockquote><p>이런식으로 전달해주신다. 매우 좋다!!!</p></blockquote><p>전달받은 피드백을 적용해서 이력서를 다시 전달해드리면 또 추가적으로 피드백을 주시게 되고, 이런식으로 몇번 왔다갔다 하면서 이력서를 전체적으로 다듬어가는 과정이다.<br>이 과정에서 확실히 처음에 비해 이력서가 매우 나아지는 과정을 경험했다.</p><h3 id="온라인-모의-면접"><a class="markdownIt-Anchor" href="#온라인-모의-면접"></a> 온라인 모의 면접</h3><p>처음에는 그냥 화상 회의라고 하셔서 부담없이 들어갔는데… 온라인 모의 면접이었다😅<br>이력서를 기반으로 꼼꼼하게 질문해주시고, 이 질문이 어떤 의도였는지, 내 대답이 어땠으면 좋았을지에 대해 바로 바로 피드백 해주신다.</p><p>그리고 다음 오프라인 면접 날짜를 잡고, 그 날짜까지 추가로 더 준비해오면 좋을 것들에 대해 숙제(!)를 내주신다.</p><p>개인적으로 피드백 해주시는 내용들이 도움이 많이 되었고, 내 스스로 내가 한 일들에 대해 제대로 정리되어 있지 않았다는 사실을 깨달을 수 있었다.</p><h3 id="오프라인-모의-면접"><a class="markdownIt-Anchor" href="#오프라인-모의-면접"></a> 오프라인 모의 면접</h3><p>온라인 면접 후, 딱 1주일 뒤에 오프라인 모의 면접을 진행했다.<br>오프라인 모의 면접은 잠실역에 있는 우형 사무실에서 진행했다.<br>총 1시간 정도 진행되며, 온라인 면접처럼 바로 피드백을 주지 않고 실제 면접과 동일한 분위기로 모의 면접을 진행하였다.<br>그리고 오프라인인 만큼 내가 수행했던 프로젝트에 대해 화이트보드에 그려가며 설명하는 과정들이 많았다.</p><p>확실히 모의면접을 진행하고나니 자신감도 붙고, 앞으로 어떤 부분들을 더 준비해야할지 더 잘 알게 되었다.</p><h3 id="추천"><a class="markdownIt-Anchor" href="#추천"></a> 추천</h3><p>이후에는 추천이다.<br>이력서, 모의면접 과정을 다 진행하고 난 후에 통과가 되면 nextstep 쪽에서 연계된 기업들에 한해 추천을 해준다.<br>단순히 내 이력서만 전달해주시는 것이 아니라, 교육과정과 멘토링 진행할 때의 내 모습을 기반으로 직접 추천서를 작성해서 같이 전달해주신다.</p><h3 id="그래서-결과는"><a class="markdownIt-Anchor" href="#그래서-결과는"></a> 그래서 결과는?</h3><p>모의면접 진행이 끝난 후 실제 이력서를 내고 면접을 진행하였고, 최종적으로 원하던 기업에 합격하여 다음주에 입사하게 된다.<br>면접 과정에서 nextstep 에서 받았던 멘토링 과정이 도움이 많이 되었다.</p><p>평소에 갈증이 많은 개발자라면 nextstep 의 교육 과정을 들어보는 것을 추천한다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;nextstep-교욱과정&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#nextstep-교욱과정&quot;&gt;&lt;/a&gt; nextstep 교욱과정&lt;/h1&gt;
&lt;p&gt;작년 3월, 그러니까 1년 반전 쯤… 이쪽 업계에서는 유명하신 박재성(
      
    
    </summary>
    
      <category term="life" scheme="https://joont92.github.io/categories/life/"/>
    
    
      <category term="nextstep" scheme="https://joont92.github.io/tags/nextstep/"/>
    
  </entry>
  
  <entry>
    <title>sql and or 순서</title>
    <link href="https://joont92.github.io/db/sql-and-or-%EC%88%9C%EC%84%9C/"/>
    <id>https://joont92.github.io/db/sql-and-or-순서/</id>
    <published>2019-10-11T00:31:12.000Z</published>
    <updated>2020-11-02T10:09:30.449Z</updated>
    
    <content type="html"><![CDATA[<p>다들 알다시피 SQL 에서 소괄호 없이 AND OR 을 사용하면 AND -&gt; OR 의 순서로 처리된다<br>그렇다면 아래와 같은 쿼리는 어떻게 처리되는걸까?</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) </span><br><span class="line"><span class="keyword">from</span> employees </span><br><span class="line"><span class="keyword">where</span> <span class="keyword">year</span>(hire_date) = <span class="string">'1998'</span> <span class="keyword">or</span> <span class="keyword">year</span>(hire_date) = <span class="string">'1999'</span> <span class="keyword">and</span> gender = <span class="string">'M'</span>;</span><br></pre></td></tr></table></figure><p>이 쿼리는 and 조건 먼저 실행되고 그다음 or 조건이 실행된다<br>이 쿼리는 아래의 두 쿼리를 합친것과 동일하다</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> employees </span><br><span class="line"><span class="keyword">where</span> <span class="keyword">year</span>(hire_date) = <span class="string">'1999'</span> <span class="keyword">and</span> gender = <span class="string">'M'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> employees </span><br><span class="line"><span class="keyword">where</span> <span class="keyword">year</span>(hire_date) = <span class="string">'1998'</span>;</span><br></pre></td></tr></table></figure><blockquote><p>결론은 그냥 알아보기 너무 힘드니까 입닥치고 괄호로 감싸주자</p></blockquote><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;다들 알다시피 SQL 에서 소괄호 없이 AND OR 을 사용하면 AND -&amp;gt; OR 의 순서로 처리된다&lt;br&gt;
그렇다면 아래와 같은 쿼리는 어떻게 처리되는걸까?&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;count&lt;/span&gt;(*) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; employees &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;year&lt;/span&gt;(hire_date) = &lt;span class=&quot;string&quot;&gt;&#39;1998&#39;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;year&lt;/span&gt;(hire_date) = &lt;span class=&quot;string&quot;&gt;&#39;1999&#39;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; gender = &lt;span class=&quot;string&quot;&gt;&#39;M&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;이 쿼리는 and 조건 먼저 실행되고 그다음 or 조건이 실행된다&lt;br&gt;
이 쿼리는 아래의 두 쿼리를 합친것과 동일하다&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;count&lt;/span&gt;(*) &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; employees &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;year&lt;/span&gt;(hire_date) = &lt;span class=&quot;string&quot;&gt;&#39;1999&#39;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; gender = &lt;span class=&quot;string&quot;&gt;&#39;M&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;count&lt;/span&gt;(*) &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; employees &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;year&lt;/span&gt;(hire_date) = &lt;span class=&quot;string&quot;&gt;&#39;1998&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;결론은 그냥 알아보기 너무 힘드니까 입닥치고 괄호로 감싸주자&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="db" scheme="https://joont92.github.io/categories/db/"/>
    
    
      <category term="and" scheme="https://joont92.github.io/tags/and/"/>
    
      <category term="or" scheme="https://joont92.github.io/tags/or/"/>
    
  </entry>
  
  <entry>
    <title>[java] 쓰레드 기본</title>
    <link href="https://joont92.github.io/java/%EC%93%B0%EB%A0%88%EB%93%9C-%EA%B8%B0%EB%B3%B8/"/>
    <id>https://joont92.github.io/java/쓰레드-기본/</id>
    <published>2019-07-21T21:40:57.000Z</published>
    <updated>2020-11-02T10:09:30.453Z</updated>
    
    <content type="html"><![CDATA[<p>기본적으로 서버 프로그램의 경우 많은 동시에 많은 사용자의 요청을 처리해야 하므로 멀티 쓰레드로 동작한다<br>우리가 매번 사용하는 톰캣 또한 사용자의 요청을 모두 쓰레드가 처리하는, 멀티 쓰레드 구조이다<br>그래므로 쓰레드에 대한 지식은 필수이다<br>라고 말했지만 나는 겉핥기밖에 모르는 것 같아서 다시 기초부터 공부하고 있고, 이를 정리하고자 한다</p><p>쓰레드에 대한 기본 지식은 구글에 검색하면 아주 아주 잘 설명된 글들이 많으니 그것을 참조하면 되고, 여기서는 자바에서 쓰레드를 사용하는 법에 대해 정리하겠다</p><h1 id="쓰레드-구현"><a class="markdownIt-Anchor" href="#쓰레드-구현"></a> 쓰레드 구현</h1><p>자바에서 쓰레드를 구현하는 방법은 <code>Thread</code> 클래스를 상속받는 방법과 <code>Runnable</code> 인터페이스를 구현하는 방법이 있다<br>자바에서는 상속이 비싼 행위이기 때문에 보통은 <code>Runnable</code> 인터페이스를 구현하여 쓰레드를 구현한다</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 쓰레드에서 실행할 내용 */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 쓰레드에서 실행할 내용 */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyThread1 myThread1 = <span class="keyword">new</span> MyThread1(); <span class="comment">// Thread 상속 시 </span></span><br><span class="line">    Thread myThread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread2()); <span class="comment">// Runnable 구현시 </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 쓰레드 실행</span></span><br><span class="line">    myThread1.start();</span><br><span class="line">    myThread2.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Thread 클래스를 상속받은 경우 바로 인스턴스를 생성하면 되고, Runnable 인터페이스를 구현한 경우 Thread 클래스의 인자로 넘겨주면 된다<br>그리고 <code>start()</code> 메서드를 호출해서 쓰레드를 실행시키고 있음을 볼 수 있다</p><blockquote><p>참고로 한번 사용한(<code>start()</code>가 이미 호출된) 쓰레드는 재사용 할 수 없다<br>두 번 이상 호출 시 <code>IllegalThreadStateException</code>이 발생한다</p></blockquote><p>앞서 우리가 구현했던 run 메서드는 단순히 수행할 태스크만을 작성하는 부분이고, 실제로 쓰레드를 실행시키려면 위와 같이 start 메서드를 통해서 실행해야 한다<br>start 메서드 호출 시 쓰레드가 작업을 실행하는데 필요한 호출 스택을 생성하고 run 메서드를 실행하게 된다</p><p>!(thread call stack)[<a href="https://joont92.github.io/temp/thread-call-stack.jpg">https://joont92.github.io/temp/thread-call-stack.jpg</a>]</p><p>위는 메인 메서드에서 2개의 쓰레드를 실행시켰을 때의 모습이다<br>보다시피 각 쓰레드들은 모두 별개의 작업이고, 스케줄링의 대상이 된다<br>스케줄러가 정한 실행순서에 따라 각 쓰레드들을 돌면서 연산을 수행하게 될 것이고, 수행이 끝난 쓰레드들은 호출스택이 비워지면서 먼저 종료가 될 것이다</p><blockquote><p>CPU는 기본적으로 쓰레드를 기반으로 스케줄링을 한다</p><blockquote><p>확인 필요(+ JVM 쓰레드 스케줄러)<br>즉, 메인 메서드가 수행을 마쳤다 하더라도 쓰레드가 남아있다면 프로그램은 종료되지 않음을 뜻한다<br>실행중인 사용자 쓰레드가 하나도 없을 경우 프로그램은 종료된다</p></blockquote></blockquote><p>그리고 언급했다시피 <strong>각각의 쓰레드들은 각각 별개의 작업흐름이기 때문에 한 쓰레드에서 예외가 발생해도 다른 쓰레드의 실행에는 영향을 미치지 않게 된다</strong></p><h1 id="싱글-쓰레드와-멀티-쓰레드"><a class="markdownIt-Anchor" href="#싱글-쓰레드와-멀티-쓰레드"></a> 싱글 쓰레드와 멀티 쓰레드</h1><p>방금 아주 간단하게 멀티 쓰레드를 구성해봤는데,<br>사실 단순히 CPU만 사용해서 계산하는 작업을 수행할 경우 위와 같이 멀티쓰레드로 작업을 수행하는것이 더 비효율적이다<br>쓰레드간 context switching 비용이 발생하기 때문이다</p><p>하지만 쓰레드 내에서 연산 이외의 작업을 수행할 경우(CPU 이외의 자원을 사용할 경우), 멀티 쓰레드 프로세스가 훨씬 효율적이다<br>예를 들면 파일이나 네트워크 I/O 작업등이 있게 되는데, 특정 쓰레드가 이러한 작업을 수행하고 있을 경우 CPU는 이를 기다리지 않고 다른 쓰레드의 작업을 수행하면 되기 때문이다<br>만약 싱글 쓰레드였다면 I/O 작업이 끝날 때 까지 CPU가 대기해야 했을 것이다</p><h1 id="쓰레드-우선순위"><a class="markdownIt-Anchor" href="#쓰레드-우선순위"></a> 쓰레드 우선순위</h1><p>쓰레드는 우선순위(priority)라는 속성(멤버변수)을 가지고 있고, 이 우선순위에 따라 스케줄러가 할당하는 시간이 달라진다<br>쓰레드의 우선순위가 같다면 CPU는 각 쓰레드에게 거의 같은 양의 시간을 할당하지만, 우선순위가 다르다면 CPU는 우선순위가 높은 쓰레드에게 더 많은 작업시간을 할당한다<br>즉 쓰레드가 수행하는 작업의 중요도에 따라 쓰레드의 우선순위를 다르게 지정하여 특정 쓰레드가 더 많은 작업시간을 갖도록 처리할 수 있다<br>(예를 들면 채팅을 처리하는 쓰레드는 쓰레드는 파일을 전송하는 쓰레드보다 우선순위가 높아야한다)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        System.out.print(<span class="string">"1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        System.out.print(<span class="string">"2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">thread1.setPriority(<span class="number">10</span>);</span><br><span class="line">thread2.setPriority(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">thread1.start();</span><br><span class="line">thread2.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 출력 : 222222222222222222222222222222222222222222222222...........1111111111111111111111111111111111111...............</span></span><br></pre></td></tr></table></figure><p>쓰레드가 가질 수 있는 우선순위의 범위는 1~10까지 이며, 숫자가 높을수록(작을수록) 우선순위가 높다<br>참고로 이 우선순위 값은 절대적인 것이 아니라 <code>상대적인 값</code>이다<br>값이 1정도 차이나는 경우에는 별 차이가 없지만, 2 이상 차이가 나면 실행시간에 많은 차이가 발생하게 된다</p><p>쓰레드의 우선순위는 따로 지정해주지 않으면 쓰레드를 생성한 쓰레드로부터 상속을 받게 된다(main 쓰레드는 우선순위가 5이다)</p><h1 id="데몬-쓰레드"><a class="markdownIt-Anchor" href="#데몬-쓰레드"></a> 데몬 쓰레드</h1><p>쓰레드는 사용자 쓰레드와 데몬 쓰레드 2종류가 있다<br>지금까지 언급했던 것은 전부 사용자 쓰레드이고, 데몬 쓰레드의 경우 일반 쓰레드의 작업을 돕는 보조적인 역할을 수행하는 쓰레드를 말한다<br>보조 역할을 하는 쓰레드이므로 일반 쓰레드가 모두 종료되면 데몬 쓰레드 또한 강제적으로 종료된다(더이상 필요없기 때문에)<br>데몬 쓰레드의 예로는 가비지 컬렉터, 자동저장, 화면 자동갱신 등이 있다</p><p>쓰레드를 데몬 쓰레드로 생성시키고 싶다면 아래와 같이 <code>setDaemon()</code> 메서드만 실행시켜주면 된다</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread());</span><br><span class="line">thread.setDaemon(<span class="keyword">true</span>); <span class="comment">// start 전에 해줘야함</span></span><br><span class="line"></span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure><blockquote><p>이 외에도 데몬 쓰레드가 생성한 쓰레드도 자동으로 데몬 쓰레드가 된다</p></blockquote><p>데몬 쓰레드는 기본적으로 무한루프와 조건문을 이용해서 작성된다<br>(예시에서 봤듯이 가비지 컬렉터, 자동저장 등은 계속해서 상태를 체크해야하는 작업이다)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoSaveDaemonThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">3</span> * <span class="number">1000</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">        <span class="comment">// do nothing</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(autoSave) &#123;</span><br><span class="line">        autoSave();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JVM은 기본적으로 가비지 컬렉션, 이벤트처리, 그래픽처리와 같이 프로그램이 실행되는데 필요한 보조작업을 수행하는 데몬 쓰레드들을 자동적으로 실행시킨다</p><h1 id="쓰레드-실행제어welcome-to-hell"><a class="markdownIt-Anchor" href="#쓰레드-실행제어welcome-to-hell"></a> 쓰레드 실행제어(Welcome To Hell!)</h1><p>앞서 쓰레드의 우선순위로 쓰레드간 실행을 제어하긴 했지만, 사실 이것만으로는 부족하다<br>효율적인 멀티쓰레드 프로그램을 만들기 위해서는 보다 정교한 스케줄링을 통해 주어진 자원을 여러 쓰레드가 낭비없이 잘 사용하도록 프로그래밍 해야한다<br>이를 위해 자바에서는 쓰레드를 컨트롤 할 수 있는 기능을 제공하는데, 이를 알기전에 먼저 쓰레드의 상태에 대해 알고 있어야한다</p><p><img src="https://joont92.github.io/temp/thread-states.png" alt="thread states"></p><ul><li>NEW<blockquote><p>쓰레드가 생성되고 아직 <code>start()</code>가 호출되지 않은 상태</p></blockquote></li><li>RUNNABLE<blockquote><p><code>start()</code>를 호출했다고 바로 실행되는 것이 아니라, 큐의 구조로 된 실행 대기열에 저장되어 대기하다가 자기 차례가 되면 실행한다</p></blockquote></li><li>RUNNING<blockquote><p>실행대기열에 있던 쓰레드가 자기 차례가 되어 실행중인 상태</p></blockquote></li><li>WAITING<blockquote><p>실행중인 쓰레드가 특정 메서드(sleep(), wait(), join() 등)에 의해 일시정지 상태가 된 것을 말한다<br>지정된 일시정지 시간이 다 되거나 특정 메서드(notify(), interrupt()) 호출이 발생하면 다시 RUNNABLE 상태로 돌아가 실행대기열에 저장된다</p></blockquote></li><li>BLOCKED<blockquote><p>?</p></blockquote></li><li>TERMINATED<blockquote><p>쓰레드의 작업이 종료된 상태를 말한다<br>작업이 종료된 쓰레드는 소멸되므로 사실상 쓰레드가 이 상태로 있는것은 아니다</p></blockquote></li></ul><p>아래는 쓰레드의 상태를 제어하는 주요 메서드들에 대한 설명이다</p><h2 id="start"><a class="markdownIt-Anchor" href="#start"></a> start</h2><p>위에서 언급한 것처럼, 쓰레드를 실행시키는 메서드이다<br>바로 RUNNING 상태가 되지는 않고 RUNNABLE 상태로 되었다가 자기 차례가 되면 RUNNING 상태가 된다</p><h2 id="join"><a class="markdownIt-Anchor" href="#join"></a> join</h2><p>지정한 쓰레드의 작업이 끝날 때 까지 기다리는 메서드이다</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread());</span><br><span class="line">Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread());</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  thread1.start();</span><br><span class="line">  thread1.join(); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">  thread2.start();</span><br><span class="line">  thread2.join(); <span class="comment">// 2</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">  <span class="comment">// do nothing</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"job ended"</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p><code>join()</code> 메서드 실행 시, 기다리는 대상은 해당 쓰레드를 실행한 쓰레드이다<br>thread1, thread2를 실행한 쓰레드를 메인 쓰레드라고 가정한다면,</p><ol><li>main thread는 thread1 을 실행하고, thread1 의 작업이 끝날 때 까지 기다린다</li></ol><blockquote><p>메서드의 인자로 밀리초나 나노초를 줘서 특정 시간 동안만 기다리게도 설정할 수 있다</p></blockquote><ol start="2"><li>thread1의 작업이 끝난 뒤 mani thread는 thread2 를 실행하고, thread2 의 작업이 끝날 때 까지 기다린다</li><li>thread2의 작업이 끝나고 나면 main thread의 마지막 부분을 실행하고, main thread는 종료된다</li></ol><p>보다시피 join 메서드는 한 쓰레드의 작업 중간에 다른 쓰레드의 작업이 필요할 경우 유용하게 사용할 수 있다</p><h2 id="sleep"><a class="markdownIt-Anchor" href="#sleep"></a> sleep</h2><p>지정한 시간동안 작업을 일시정지 상태로 들어가는 메서드이다<br>static 메서드로 제공되며(인스턴스 메서드는 deprecated 되었다), 이 메서드를 호출한 쓰레드가 지정한 시간만큼 일시정시 상태가 된다</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread());</span><br><span class="line">thread.start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5000 millisecond 이기 때문에 5초간 WAITTING 상태가 된다<br>5초가 지난 후 다시 RUNNABLE 상태가 되어 실행대기열에 저장된다</p><h2 id="yield"><a class="markdownIt-Anchor" href="#yield"></a> yield</h2><p>RUNNABLE 상태로 들어가면서 다른 쓰레드에게 작업을 양보하는 메서드이다<br>이 또한 static 메서드로 제공되며, 이 메서드를 호출한 쓰레드가 RUNNABLE 상태로 들어가게 된다</p><blockquote><p>다른 메서드들과의 차이점은 WAITING 상태로 들어가지 않고 바로 RUNNABLE 로 들어간다는 점이다</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1000번 loop</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"sub thread has been terminated"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">static</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread());</span><br><span class="line">    thread.start();</span><br><span class="line"></span><br><span class="line">    Thread.yield();</span><br><span class="line">    System.out.println(<span class="string">"main thread has been terminated"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>원래라면 main thread 종료 문구 -&gt; sub thread 종료 문구 의 순서로 출력되어야 하지만,<br>main thread 에서 yield 로 다른 쓰레드에게 실행을 양보함으로써 sub thread가 먼저 종료됨을 볼 수 있다</p><blockquote><p>쓰레드의 실행을 양보하고 RUNNABLE 상태로 들어간 것이기 때문에,<br>sub thread의 작업 시간이 CPU 스케줄링에서 쓰레드에 할당하는 작업 시간보다 길 경우, main thread 종료 문구가 먼저 출력될 것이다<br>WAITING 상태로 들어가는 join 과는 다르다</p></blockquote><h2 id="suspend-resume-stop"><a class="markdownIt-Anchor" href="#suspend-resume-stop"></a> suspend, resume, stop</h2><p>이 3개의 메서드는 쓰레드를 교착상태(dead-lock)에 빠트릴 수 있어 deprecated 되었다<br>그렇다고 사용 못하는 것은 아니고, 아래와 같이 작성하여 구현할 수 있다</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> suspended = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> stopped = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Thread thread;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    thread = <span class="keyword">new</span> Thread(<span class="keyword">this</span>, name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!stopped) &#123;</span><br><span class="line">      <span class="keyword">if</span>(!suspended) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// </span></span><br><span class="line">        &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">          System.out.println(name + <span class="string">" interrupted"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Thread.yield();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">suspend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    suspended = <span class="keyword">true</span>;</span><br><span class="line">    thread.interrupt();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    suspended = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stopped = <span class="keyword">true</span>;</span><br><span class="line">    thread.interrupt();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    thread.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>stopped, suspended flag 값으로 기존의 <code>suspend()</code>, <code>stop()</code> 메서드를 구현하였다<br>게다가 suspend 상태일때는 <code>Thread.yield()</code> 를 발생시켜 불필요한 while 문을 돌지 않도록 하였으며,<br><code>stop()</code>과 <code>suspend()</code> 시에 <code>interrupt()</code>를 발생시켜 thread가 WAITING 상태라면 깨워서 RUNNABLE 상태로 가도록 설정하였다<br>(<code>interrupt()</code> 시에 WAITING 상태가 아니라면 아무일도 일어나지 않는다)</p><h1 id="쓰레드의-동기화"><a class="markdownIt-Anchor" href="#쓰레드의-동기화"></a> 쓰레드의 동기화</h1><p>멀티 쓰레드 환경의 경우 여러 쓰레드가 같은 프로세스 내의 자원을 공유하기 때문에, 서로의 작업에 영향을 줄 수 있다<br>자바의 경우, 힙 영역의 경우 JVM 프로세스가 공유하는 영역이고, 스택 영역의 경우 각 쓰레드마다 별개로 가지는 영역이다<br>그러므로 우리는 항상 힙 영역의 데이터를 사용할 경우 주의를 기울여야 한다<br>아래는 힙 영역의 데이터를 공유함으로써 문제가 발생하는 것에 대한 예시이다</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> amount;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(<span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.amount = amount;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(amount &gt;= money) &#123;</span><br><span class="line">      amount-=money;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Account account;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.account = account;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    account.withdraw(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">static</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Account account = <span class="keyword">new</span> Account(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread(account));</span><br><span class="line">    Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread(account));</span><br><span class="line"></span><br><span class="line">    thread1.start();</span><br><span class="line">    thread2.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>잔고 1000원의 계좌를 생성하고, 1000원을 출금하는 쓰레드를 2개 생성하여 동시에 실행시켰다</p></blockquote><p>결과로 항상 0원이 나올것이라 생각했지만, 돌려보면 -1000원이 나올수도 있다<br>(위 정도의 작업에서는 거의 무조건 0원이 나오므로, if 문 안에 Thread.sleep 을 조금 걸고 테스트해보면 확인할 수 있다)</p><p>이는 thread1과 thread2가 account 객체를 공유하기 때문에 발생하는 문제이다<br>예를 들면 thread1이 if문을 통과하고 아직 amount를 차감하지 않은 상태에서, thread2가 if문을 통과하는 경우가 될 것이다<br>이런 상황이 발생하면 결국 두 쓰레드 모두 amount 값을 차감하게 되고, 우리는 음수 결과값을 받아보게 되는 것이다</p><p>쓰레드 프로그램 작성시에 스택내의 변수만을 사용하여 위와 같은 상황을 안 만들면 되지 않느냐고 생각할 수 있지만,<br>로직을 처리하다 보면 결국에는 위와 같이 공용 변수에 접근하는 순간이 발생하므로, 위와 같은 현상은 피할 수 없다</p><p>그러므로 위 withdraw 같은 메서드들은 하나의 쓰레드에서 접근하고 있을 경우 다른 쓰레드에서 접근하지 못하도록 락을 걸어 데이터가 틀어지는 것을 방지해야 하는데, 이를 <code>동기화</code>라고 한다<br>자바에서는 <code>snychronized</code> 키워드를 사용해 이를 구현할 수 있고, 방법은 아래와 같이 메서드에 synchronized 를 선언하는 방법과, synchronized block을 선언하는 방법이 있다</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * synchronized method</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(amount &gt;= money) &#123;</span><br><span class="line">    amount-=money;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * synchronized block</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(amount &gt;= money) &#123;</span><br><span class="line">      amount-=money;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그리고 이런식의 동기화 블록을 사용해서 프로그램을 작성시에는 교착상태(dead-lock)을 항상 주의해줘야 한다<br>만약 thread가 락을 건 상태에서 정지되거나 종료된다면 이를 기다리는 다른 쓰레드들이 전부 데드락에 빠지기 떄문이다<br>이같은 이유로 suspend(), stop() 메서드등이 deprecated 되었다</p><h2 id="wait-notify"><a class="markdownIt-Anchor" href="#wait-notify"></a> wait, notify</h2><p>한 쓰레드가 객체에 lock을 걸 경우, 이 객체를 사용하려는 다른 쓰레드들은 lock 이 풀릴떄까지 무작정 같이 기다려야하는 비효율이 발생하게 된다<br>이 같은 상황을 방지하기 위해 나온 메서드가 <code>wait()</code>과 <code>notify()</code>이다</p><p><code>wait()</code>과 <code>notify()</code>, <code>notifyAll()</code>은 Object 클래스에 정의된 메서드이므로 모든 객체에서 호출이 가능하며, synchronized 블록 내에서만 사용할 수 있다<br><code>wait()</code>이 호출되면 쓰레드는 이때까지 자기가 걸고있던 모든 락을 다 풀고, WAITING 상태로 전환되면서 <code>wait()</code>이 호출된 객체의 대기실에서 대기하게 된다<br>그러다가 다른 쓰레드에 의해 해당 객체의 <code>notify()</code>나 <code>notifyAll()</code>이 호출되면, 객체의 대기실에서 나와 다시 RUNNABLE 상태로 들어가게 된다</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> amount;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(<span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.amount = amount;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(amount &lt; money) &#123; <span class="comment">// 1</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        wait(); <span class="comment">// 2</span></span><br><span class="line">      &#125; <span class="keyword">catch</span>(InterruptedException e) &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    amount -= money;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">deposit</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">    balance += money;</span><br><span class="line">    notifyAll(); <span class="comment">// 3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>전달받은 금액을 출금하기 위해 메서드에 락을 걸고 들어왔으나, 가지고 있는 잔고보다 출금하려는 금액이 더 많은 상황이다</li><li>그러므로 출금하지 못하고, Account 객체의 <code>wait()</code>를 호출한다</li></ol><ul><li>withdraw 에 걸고 있는 락이 풀리게 된다</li><li>쓰레드는 WAITING 상태로 들어가게 된다</li><li>쓰레드는 Account 객체 인스턴스의 대기실(waiting room)에서 기다리게 된다</li></ul><ol start="3"><li>deposit 메서드가 호출되며 금액이 채워지고, <code>notifyAll()</code>을 호출한다</li></ol><ul><li>Account 객체 인스턴스의 대기실에 있는 모든 쓰레드들을 깨운다</li><li>깨어난 쓰레드는 2번의 위치에서 다시 흐름을 이어가게 되는데, while 문이므로 다시 출금 가능한지 검사하게 된다<blockquote><p>if문 대신 while문을 사용한 이유이다</p></blockquote></li></ul><blockquote><p><code>nofiy()</code> 대신 <code>notifyAll()</code> 을 사용하나 사실 별 차이는 없지만,<br><code>notify()</code>를 사용해서 한개의 쓰레드만 꺠울 경우 어떤 쓰레드가 꺠워질지 알수 없고,<br>이로인해 우선순위가 높은 쓰레드가 계속 pool에 머물게 될 수 도 있으므로, <code>notifyAll()</code>을 통해 모든 쓰레드를 꺠워서 스케줄러에 의해 처리되도록 해주는 것이 좋다</p></blockquote><p>참고 :</p><ul><li><a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&amp;mallGb=KOR&amp;barcode=9788995379493&amp;orderClick=LAH&amp;Kc=" rel="external nofollow noopener noreferrer" target="_blank">남궁성, 『Java의 정석 2nd Edition』, 도우출판(2010)</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;기본적으로 서버 프로그램의 경우 많은 동시에 많은 사용자의 요청을 처리해야 하므로 멀티 쓰레드로 동작한다&lt;br&gt;
우리가 매번 사용하는 톰캣 또한 사용자의 요청을 모두 쓰레드가 처리하는, 멀티 쓰레드 구조이다&lt;br&gt;
그래므로 쓰레드에 대한 지식은 
      
    
    </summary>
    
      <category term="java" scheme="https://joont92.github.io/categories/java/"/>
    
    
      <category term="java thread" scheme="https://joont92.github.io/tags/java-thread/"/>
    
      <category term="synchronized" scheme="https://joont92.github.io/tags/synchronized/"/>
    
      <category term="join()" scheme="https://joont92.github.io/tags/join/"/>
    
      <category term="Thread.sleep()" scheme="https://joont92.github.io/tags/Thread-sleep/"/>
    
      <category term="Thread.yield()" scheme="https://joont92.github.io/tags/Thread-yield/"/>
    
      <category term="wait()" scheme="https://joont92.github.io/tags/wait/"/>
    
      <category term="notify()" scheme="https://joont92.github.io/tags/notify/"/>
    
      <category term="notifyAll()" scheme="https://joont92.github.io/tags/notifyAll/"/>
    
  </entry>
  
  <entry>
    <title>[kubernetes] 배포 전략</title>
    <link href="https://joont92.github.io/kubernetes/%EB%B0%B0%ED%8F%AC-%EC%A0%84%EB%9E%B5/"/>
    <id>https://joont92.github.io/kubernetes/배포-전략/</id>
    <published>2019-07-13T18:49:46.000Z</published>
    <updated>2020-11-02T10:09:30.457Z</updated>
    
    <content type="html"><![CDATA[<p>쿠버네티스는 2가지 방법으로 무중단 배포를 수행할 수 있다</p><h1 id="롤링-업데이트"><a class="markdownIt-Anchor" href="#롤링-업데이트"></a> 롤링 업데이트</h1><p>Deployment 속성중에 <code>.specs.strategy.type</code> 값을 통해 Pod 교체전략을 지정할 수 있는데, 여기서 <code>RollingUpdate</code> 를 사용하는 방법이다<br>RollingUpdate는 우리가 잘 알다시피, Pod를 하나씩 죽이고 새로 띄우면서 순차적으로 교체하는 방법이다</p><blockquote><p>RollingUpdate, Recreate 2개의 값이 존재하며 Recreate의 경우 기존 파드를 모두 삭제한 다음 새로운 파드를 생성하는 방법이다(이 방식은 무중단이 아니다)<br>기본값은 RollingUpdate 이다</p></blockquote><p>RollingUpdate를 테스트하기 위해 먼저 deployment 와 service를 정의한다</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="string">name</span> <span class="string">:</span> <span class="string">test-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">4</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">test-pod</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">test-pod</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">test-pod</span></span><br><span class="line"><span class="attr">          image:</span> <span class="string">joont92/echo-version:1.0</span> <span class="comment"># 단순히 요청을 받으면 version을 리턴해주는 서버이다</span></span><br><span class="line"><span class="attr">          ports:</span></span><br><span class="line"><span class="attr">            - containerPort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">test-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">    - port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">      targetPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">test-pod</span></span><br></pre></td></tr></table></figure><blockquote><p>deployment의 기본 속성이 RollingUpdate 이므로 따로 RollingUpdate 부분을 명시하지 않았다</p></blockquote><p>이제 다른 Pod에서 위 서비스명으로 호출하면 <code>1.0</code> 이라는 버전을 리턴해주게 된다<br>이를 <code>2.0</code>을 리턴해주는 이미지로 바꿀건데, RollingUpdate 를 이용하여 바꿔보도록 할 것이다</p><p>먼저 위의 서비스 명으로 호출하는 Pod를 하나 만들어야한다</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span> </span><br><span class="line"><span class="attr">  name:</span> <span class="string">update-checker</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">update-checker</span></span><br><span class="line"><span class="attr">      image:</span> <span class="string">joont92/update-chekcer:latest</span> <span class="comment"># curl 이 깔려있는 alpine 리눅스</span></span><br><span class="line"><span class="attr">      command:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">sh</span></span><br><span class="line"><span class="bullet">        -</span> <span class="bullet">-c</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">|</span></span><br><span class="line"><span class="string">          while true</span></span><br><span class="line"><span class="string">          do</span></span><br><span class="line"><span class="string">            echo "[`date`] curl -s http://test-service/"</span></span><br><span class="line"><span class="string">            sleep 1</span></span><br><span class="line"><span class="string">          done</span></span><br></pre></td></tr></table></figure><p>이 Pod가 뜨게되면 1초마다 test-service를 호출하게 되고, test-service 에서 사용하는 Pod 가 받아서 0.1.0 이라는 값을 리턴해주게 될 것이다</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Sat Jul 13 14:08:27 UTC 2019] APP_VERSION=0.1.0</span><br><span class="line">[Sat Jul 13 14:08:28 UTC 2019] APP_VERSION=0.1.0</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>이제 Deployment 내 Pod의 이미지를 바꿔서 적용시켜보겠다<br>먼저 변경할 내용을 작성하고,</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">echo-version</span></span><br><span class="line"><span class="attr">          image:</span> <span class="string">joont92/echo-version:0.2.0</span> <span class="comment"># 버전 변경</span></span><br></pre></td></tr></table></figure><p>기존의 Deployment 에 적용한다</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl patch deplyment <span class="built_in">test</span>-deployment -p <span class="string">"<span class="variable">$(cat patch-deployment.yaml)</span>"</span></span><br></pre></td></tr></table></figure><p>참고로 아래처럼 할수도 있다</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl <span class="built_in">set</span> image deployment <span class="built_in">test</span>-deployment <span class="built_in">test</span>-pod=joont92/<span class="built_in">echo</span>-version:0.2.0</span><br></pre></td></tr></table></figure><p>변경사항을 적용하자, 컨테이너가 하나씩 삭제되고 생성되는 것을 볼 수 있다</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pod -l app:<span class="built_in">test</span>-pod -w</span><br><span class="line">NAME                               READY   STATUS              RESTARTS   AGE</span><br><span class="line"><span class="built_in">test</span>-deployment-6b8d4f7967-9gwxl   0/1     Terminating         0          46s</span><br><span class="line"><span class="built_in">test</span>-deployment-6b8d4f7967-f9nlf   1/1     Running             0          48s</span><br><span class="line"><span class="built_in">test</span>-deployment-6b8d4f7967-knrws   1/1     Running             0          48s</span><br><span class="line"><span class="built_in">test</span>-deployment-6b8d4f7967-wkd4l   0/1     Terminating         0          46s</span><br><span class="line"><span class="built_in">test</span>-deployment-86658bfcfd-4kf2z   1/1     Running             0          3s</span><br><span class="line"><span class="built_in">test</span>-deployment-86658bfcfd-ckxvx   0/1     ContainerCreating   0          1s</span><br><span class="line"><span class="built_in">test</span>-deployment-86658bfcfd-d4znq   0/1     ContainerCreating   0          3s</span><br><span class="line"><span class="built_in">test</span>-deployment-86658bfcfd-d4znq   1/1     Running             0          4s</span><br><span class="line"><span class="built_in">test</span>-deployment-6b8d4f7967-knrws   1/1     Terminating         0          49s</span><br><span class="line"><span class="built_in">test</span>-deployment-86658bfcfd-s96t6   0/1     Pending             0          0s</span><br><span class="line"><span class="built_in">test</span>-deployment-86658bfcfd-s96t6   0/1     Pending             0          0s</span><br><span class="line"><span class="built_in">test</span>-deployment-86658bfcfd-s96t6   0/1     ContainerCreating   0          1s</span><br><span class="line"><span class="built_in">test</span>-deployment-6b8d4f7967-wkd4l   0/1     Terminating         0          49s</span><br><span class="line"><span class="built_in">test</span>-deployment-6b8d4f7967-wkd4l   0/1     Terminating         0          49s</span><br><span class="line"><span class="built_in">test</span>-deployment-86658bfcfd-ckxvx   1/1     Running             0          4s</span><br><span class="line"><span class="built_in">test</span>-deployment-6b8d4f7967-f9nlf   1/1     Terminating         0          51s</span><br><span class="line"><span class="built_in">test</span>-deployment-6b8d4f7967-knrws   0/1     Terminating         0          52s</span><br><span class="line"><span class="built_in">test</span>-deployment-6b8d4f7967-knrws   0/1     Terminating         0          52s</span><br><span class="line"><span class="built_in">test</span>-deployment-6b8d4f7967-knrws   0/1     Terminating         0          52s</span><br><span class="line"><span class="built_in">test</span>-deployment-86658bfcfd-s96t6   1/1     Running             0          4s</span><br><span class="line"><span class="built_in">test</span>-deployment-6b8d4f7967-f9nlf   0/1     Terminating         0          54s</span><br><span class="line"><span class="built_in">test</span>-deployment-6b8d4f7967-f9nlf   0/1     Terminating         0          54s</span><br><span class="line"><span class="built_in">test</span>-deployment-6b8d4f7967-f9nlf   0/1     Terminating         0          54s</span><br><span class="line"><span class="built_in">test</span>-deployment-6b8d4f7967-9gwxl   0/1     Terminating         0          53s</span><br><span class="line"><span class="built_in">test</span>-deployment-6b8d4f7967-9gwxl   0/1     Terminating         0          53s</span><br></pre></td></tr></table></figure><h2 id="롤링-업데이트-동작-제어"><a class="markdownIt-Anchor" href="#롤링-업데이트-동작-제어"></a> 롤링 업데이트 동작 제어</h2><p>Deployment의 <code>.specs.strategy</code> 속성을 설정하여 롤링 업데이트의 동작을 제어할 수 있다</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="string">name</span> <span class="string">:</span> <span class="string">test-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">4</span></span><br><span class="line"><span class="attr">  strategy:</span> <span class="comment"># 요기</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">RollingUpdate</span></span><br><span class="line"><span class="attr">    rollingUpdate:</span></span><br><span class="line"><span class="attr">      maxUnvailable:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">      maxSurge:</span> <span class="number">4</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">test-pod</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">test-pod</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">test-pod</span></span><br><span class="line"><span class="attr">          image:</span> <span class="string">joont92/echo-version:0.1.0</span></span><br><span class="line"><span class="attr">          ports:</span></span><br><span class="line"><span class="attr">            - containerPort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure><p><code>maxUnvaliable</code>은 롤링 업데이트시 동시에 삭제할 수 있는 파드의 최대 개수를 의미하고, <code>maxSurge</code>는 동시에 생성될 수 있는 파드의 최대 개수를 의미한다<br>(둘 다 기본값은 replicas 값의 25%이다)<br>이 값을 적절히 수정하면 RollingUpdate 시간을 단축할 수 있으나, 갑자기 한 Pod에 부하가 몰리거나 서버의 리소스가 잠깐 급증하는 사이드이팩트도 있으니 잘 설정해줘야 한다</p><h1 id="블루-그린"><a class="markdownIt-Anchor" href="#블루-그린"></a> 블루-그린</h1><p>롤링 업데이트는 강력하지만, 구버전과 새버전이 공존하는 시간이 발생한다는 단점이 있다<br>이 문제를 해결하기 위해 사용되는게 이 블루-그린 배포 인데, 이는 서버를 새버전과 구버전으로 2세트를 마련하고, 이를 한꺼번에 교체하는 방법이다</p><p>기존에 아래와 같이 Service, Deployment가 생성되어 있었다고 치자</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="string">name</span> <span class="string">:</span> <span class="string">test-deployment-blue</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">4</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">test-pod</span></span><br><span class="line"><span class="attr">      color:</span> <span class="string">blue</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">test-pod</span></span><br><span class="line"><span class="attr">        color:</span> <span class="string">blue</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">test-pod</span></span><br><span class="line"><span class="attr">          image:</span> <span class="string">joont92/echo-version:0.1.0</span> <span class="comment"># 구버전</span></span><br><span class="line"><span class="attr">          ports:</span></span><br><span class="line"><span class="attr">            - containerPort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">test-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">    - port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">      targetPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">test-pod</span></span><br><span class="line"><span class="attr">    color:</span> <span class="string">blue</span></span><br></pre></td></tr></table></figure><p>blue-green 배포를 하기 위해, 새로운 버전이 적용된 Deployment 세트를 하나 더 준비한다</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="string">name</span> <span class="string">:</span> <span class="string">test-deployment-green</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">4</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">test-pod</span></span><br><span class="line"><span class="attr">      color:</span> <span class="string">green</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">test-pod</span></span><br><span class="line"><span class="attr">        color:</span> <span class="string">green</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">test-pod</span></span><br><span class="line"><span class="attr">          image:</span> <span class="string">joont92/echo-version:0.2.0</span> <span class="comment"># 신버전</span></span><br><span class="line"><span class="attr">          ports:</span></span><br><span class="line"><span class="attr">            - containerPort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure><p>아래가 블루-그린 배포를 하기 위한 핵심 부분이다</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    color:</span> <span class="string">green</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl patch service <span class="built_in">test</span>-service -p <span class="string">"<span class="variable">$(cat patch-service.yaml)</span>"</span></span><br></pre></td></tr></table></figure><p>test-service의 label selector가 업데이트 됨으로써, test-service는 새로 배포된 Pod 들만을 바라보게 변경되었다<br>이처럼 구버전과 신버전이 공존하는 텀이 없이 바로 신버전으로 전환할 수 있다(!!)<br>게다가 만약 새로 배포된 버전에 문제가 발생한다면, 다시 test-service의 label을 blue로 돌려줌으로써 쉽게 롤백도 가능하다</p><p>기존에 물려있던 트래픽에 대해서는… 롤링배포와 블루그린 배포에서 차이점이 뭘까?</p><p>참고 :</p><ul><li><a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&amp;mallGb=KOR&amp;barcode=9791158391447&amp;orderClick=LEA&amp;Kc=" rel="external nofollow noopener noreferrer" target="_blank">야마다 아키노리, 『도커/쿠버네티스를 활용한 컨테이너 개발 실전 입문』, 심효섭 옮김, 위키북스(2019)</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;쿠버네티스는 2가지 방법으로 무중단 배포를 수행할 수 있다&lt;/p&gt;
&lt;h1 id=&quot;롤링-업데이트&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#롤링-업데이트&quot;&gt;&lt;/a&gt; 롤링 업데이트&lt;/h1&gt;
&lt;p&gt;Deployment 속성중에 &lt;
      
    
    </summary>
    
      <category term="kubernetes" scheme="https://joont92.github.io/categories/kubernetes/"/>
    
    
      <category term="도커/쿠버네티스를 활용한 컨테이너 개발 실전 입문" scheme="https://joont92.github.io/tags/%EB%8F%84%EC%BB%A4-%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EA%B0%9C%EB%B0%9C-%EC%8B%A4%EC%A0%84-%EC%9E%85%EB%AC%B8/"/>
    
      <category term="RollingUpdate" scheme="https://joont92.github.io/tags/RollingUpdate/"/>
    
      <category term="Blue-Green" scheme="https://joont92.github.io/tags/Blue-Green/"/>
    
  </entry>
  
  <entry>
    <title>[kubernetes] kubectl context</title>
    <link href="https://joont92.github.io/kubernetes/kubectl-context/"/>
    <id>https://joont92.github.io/kubernetes/kubectl-context/</id>
    <published>2019-07-03T22:10:49.000Z</published>
    <updated>2020-11-02T10:09:30.457Z</updated>
    
    <content type="html"><![CDATA[<p>쿠버네티스 클러스터를 관리하는 cli 도구인 kubectl에는 환경을 바꿔가며 클러스터를 관리할 수 있는 context 라는 기능?이 존재한다<br>예를 들어 내 로컬 pc에 설치된 쿠버네티스 클러스터용 context 를 사용하면 kubectl 명령으로 내 로컬 쿠버네티스 클러스터를 컨트롤 할 수 있게되며,<br>GCP에 있는 쿠버네티스 클러스터용 context를 사용하면 kubectl로 GCP 쿠버네티스 클러스터를 컨트롤 할 수 있게 되는 것이다</p><h1 id="설정"><a class="markdownIt-Anchor" href="#설정"></a> 설정</h1><p>context 는 kubectl 을 깔면 생성되는 파일인 <code>~/.kube/config</code> 파일에서 설정할 수 있다<br>아래는 내 PC의 config 파일이다(보기쉽게 조금 수정했다)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">clusters:</span><br><span class="line">- cluster:</span><br><span class="line">    insecure-skip-tls-verify: true</span><br><span class="line">    server: https://localhost:6443</span><br><span class="line">  name: local-cluster</span><br><span class="line">- cluster:</span><br><span class="line">    certificate-authority-data: ~~~~</span><br><span class="line">    server: https://xxx.xxx.xxx.xxx</span><br><span class="line">  name: gcp-cluster</span><br><span class="line"></span><br><span class="line">users:</span><br><span class="line">- name: local-user</span><br><span class="line">  user:</span><br><span class="line">    blah blah</span><br><span class="line">- name: gcp-user</span><br><span class="line">  user:</span><br><span class="line">    blah blah</span><br><span class="line"></span><br><span class="line">contexts:</span><br><span class="line">- context:</span><br><span class="line">    cluster: gcp-cluster</span><br><span class="line">    user: gcp-user</span><br><span class="line">  name: gcp-context</span><br><span class="line">- context:</span><br><span class="line">    cluster: local-cluster</span><br><span class="line">    user: local-user</span><br><span class="line">  name: local-context</span><br><span class="line"></span><br><span class="line">current-context: local-context</span><br><span class="line"></span><br><span class="line">kind: Config</span><br><span class="line">preferences: &#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>크게 clusters, users, contexts 가 있다</p></blockquote><ul><li>clusters<blockquote><p>말 그대로 쿠버네티스 클러스터의 정보이다<br>내 PC에 설치된 쿠버네티스 클러스터와, GCP에 설치된 쿠버네티스 클러스터가 있음을 볼 수 있다<br>각 클러스터의 이름을 local-cluster, gcp-cluster로 수정해서 알아보기 쉽게 해놓았다<br>처음 클러스터 생성하면 조금 복잡?한 이름으로 생성되는데, 위처럼 자신이 알아보기 쉽게 바꿔주는 것이 좋다</p></blockquote></li><li>users<blockquote><p>클러스터에 접근할 유저의 정보이다<br>각 환경마다 필요한 값들이 다르다<br>이 또한 알아보기 쉽게 local-user, gcp-user 로 수정해놓았다</p></blockquote></li><li>context<blockquote><p>cluster와 user를 조합해서 생성된 값이다<br>cluster의 속성값으로는 위에서 작성한 cluster의 name을 지정했고, user의 속성값 또한 위에서 작성한 user의 name을 지정했다<br>local-context는 local-user 정보로 local-cluster에 접근하는 하나의 set가 되는 것이다</p></blockquote></li><li>current-context<blockquote><p>현재 사용하는 context 를 지정하는 부분이다<br>현재 local-context 를 사용하라고 설정해놓았으므로, 터미널에서 kubectl 명령을 입력하면 로컬 쿠버네티스 클러스터를 관리하게 된다</p></blockquote></li></ul><h1 id="context-조회-및-변경feat-kubectx"><a class="markdownIt-Anchor" href="#context-조회-및-변경feat-kubectx"></a> context 조회 및 변경(feat. kubectx)</h1><p>가장 단순한 방법으로는 <code>~/.kube/config</code> 파일을 컨트롤하여 context를 조회하거나 수정하는 방법이 있고,<br>그 다음 방법으로는 <code>kubectl config</code> 명령을 이용하는 방법이 있다</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gcp-context 로 변경</span></span><br><span class="line">$ kubectl config use-context gcp-context</span><br><span class="line"></span><br><span class="line"><span class="comment"># context 조회</span></span><br><span class="line">$ kubectl config get-contexts</span><br><span class="line"></span><br><span class="line">CURRENT   NAME            CLUSTER         AUTHINFO     NAMESPACE</span><br><span class="line">*         gcp-context     gcp-cluster     gcp-user</span><br><span class="line">          <span class="built_in">local</span>-context   <span class="built_in">local</span>-cluster   <span class="built_in">local</span>-user</span><br></pre></td></tr></table></figure><p>하지만 이것보다 <code>kubectx</code> 라는 더 최적화된 도구가 있다</p><blockquote><p>github : <a href="https://github.com/ahmetb/kubectx" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/ahmetb/kubectx</a></p></blockquote><p>간단하게 brew 로 설치할 수 있다<br>아래는 간단한 사용법이다</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># context 조회</span></span><br><span class="line">$ kubectl</span><br><span class="line">gcp-context <span class="comment"># 노란색으로 표시</span></span><br><span class="line"><span class="built_in">local</span>-context</span><br><span class="line"></span><br><span class="line"><span class="comment"># local-context 로 변경</span></span><br><span class="line">$ kubectx <span class="built_in">local</span>-context</span><br><span class="line"></span><br><span class="line"><span class="comment"># 이전 context로 돌아가기</span></span><br><span class="line">$ kubectx -</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;쿠버네티스 클러스터를 관리하는 cli 도구인 kubectl에는 환경을 바꿔가며 클러스터를 관리할 수 있는 context 라는 기능?이 존재한다&lt;br&gt;
예를 들어 내 로컬 pc에 설치된 쿠버네티스 클러스터용 context 를 사용하면 kubectl
      
    
    </summary>
    
      <category term="kubernetes" scheme="https://joont92.github.io/categories/kubernetes/"/>
    
    
      <category term="kubectl context change" scheme="https://joont92.github.io/tags/kubectl-context-change/"/>
    
      <category term="kubectx" scheme="https://joont92.github.io/tags/kubectx/"/>
    
  </entry>
  
  <entry>
    <title>[docker] network 구조</title>
    <link href="https://joont92.github.io/docker/network-%EA%B5%AC%EC%A1%B0/"/>
    <id>https://joont92.github.io/docker/network-구조/</id>
    <published>2019-06-29T17:30:30.000Z</published>
    <updated>2020-11-02T10:09:30.453Z</updated>
    
    <content type="html"><![CDATA[<p>도커를 공부하면서 네트워크 부분에서 알게된 부분은 아래와 같았다</p><ul><li>도커 컨테이너를 띄울때마다 매번 동일한 네트워크 대역의 IP가 할당된다</li><li>각 컨테이너들은 서로 통신이 가능하다</li><li>docker-compose로 컨테이너를 띄우면 다른 네트워크 대역의 IP가 할당된다</li></ul><p>이런것을 알게되다 보니 도커의 네트워크 구성이 궁금해졌고, 찾아가며 공부한 내용을 정리하고자 한다<br>(<code>참고</code>에 있는 글들에 훨씬 잘 설명되어있으니 그걸 읽는게 더 낫다… 난 그냥 개인 정리용…ㅎ)</p><hr><h1 id="veth-interface-net-namespace"><a class="markdownIt-Anchor" href="#veth-interface-net-namespace"></a> veth interface, NET namespace</h1><p>도커의 네트워크 구조를 이해하기 위해선 먼저 리눅스의 <code>NET namespace</code>와 <code>veth interface</code>에 대해 알아야한다</p><ul><li><p>veth interface</p><blockquote><p>간단히 말해 랜카드에 연결된 실제 네트워크 인터페이스가 아니라, 가상으로 생성한 네트워크 인터페이스이다<br>일반적인 네트워크 인터페이스와는 달리 패킷을 전달받으면, 자신에게 연결된 다른 네트워크 인터페이스로 패킷을 보내주는 식으로 동작하기 때문에 항상 쌍(pair)로 생성해줘야 한다</p></blockquote></li><li><p>NET namespace</p><blockquote><p>리눅스 격리 기술인 namespace 중 네트워크와 관련된 부분을 말한다<br>네트워크 인터페이스를 각각 다른 namespace에 할당함으로써 서로가 서로를 모르게끔 설정할 수 있다</p></blockquote></li></ul><p>(자세한 내용은 <a href="https://bluese05.tistory.com/28" rel="external nofollow noopener noreferrer" target="_blank">https://bluese05.tistory.com/28</a> 를 참조한다… 100배 설명이 더 잘되어 있다)</p><h1 id="도커-네트워크-구조"><a class="markdownIt-Anchor" href="#도커-네트워크-구조"></a> 도커 네트워크 구조</h1><p>도커는 위에서 언급한 veth interface와 NET namespace 를 사용해 네트워크를 구성한다<br>그림으로 보면 아래와 같다</p><p><img src="https://joont92.github.io/temp/docker-network.png" alt="docker-network"></p><ol><li>생성되는 도커 컨테이너는 namespace 로 격리되고, 그 상태에서 통신을 위한 네트워크 인터페이스(eth0)를 할당받는다</li><li>host PC의 veth interface 가 생성되고 도커 컨테이너 내의 eth0 과 연결한다<blockquote><p>컨테이너의 네트워크 격리를 달성하기 위해 선택한 방법인 것 같다</p></blockquote></li><li>host PC의 veth interface 는 <code>docker0</code> 이라는 다른 veth interface 와 연결된다</li><li>이 과정이 컨테이너가 추가될 때 마다 반복된다</li></ol><p>여기서 나오는 <code>docker0</code>은 docker 실행 시 자동으로 생성되는 <code>가상 브릿지</code> 이다<br>컨테이너가 생성될 때 마다 가상 인터페이스가 생성되고, 이 브릿지에 바인딩 되는 형태라고 보면 된다<br>즉, 모든 컨테이너는 외부로 통신할 때 이 <code>docker0 브릿지</code>를 무조건 거쳐가야 되는 것이다<br>이러한 특징 때문에 도커 컨테이너끼리 서로 통신이 가능한 것이다</p><blockquote><p><code>docker0</code> 브릿지에 할당된 ip 대역에 맞춰 컨테이너들도 ip가 할당된다<br>e.g. docker0 = 172.17.0.1/16, container1 = 172.17.0.2, container2 = 172.17.0.3 …<br>IP는 veth가 가지는걸까, eth0 이 가지는걸까?(가상 네트워크 인터페이스에 대한 이해가 조금 더 필요하다)</p></blockquote><p>아래는 컨테이너 2개를 띄웠을 떄의 모습이다</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ ip link ls</span><br><span class="line"></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">2: enp0s3: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether 08:00:27:d8:72:d9 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">3: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP mode DEFAULT group default</span><br><span class="line">    link/ether 02:42:c0:e5:8c:93 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">4: vethf3bf38b@if34: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP mode DEFAULT group default</span><br><span class="line">    link/ether 02:13:50:cf:5c:48 brd ff:ff:ff:ff:ff:ff link-netnsid 1</span><br><span class="line">5: veth1680438@if36: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP mode DEFAULT group default</span><br><span class="line">    link/ether f2:b2:f7:eb:a5:55 brd ff:ff:ff:ff:ff:ff link-netnsid 2</span><br></pre></td></tr></table></figure><p>그리고 아래는 브릿지에 연결되어 있는 veth interface 를 조회한 모습이다</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ brctl show docker0</span><br><span class="line">bridge namebridge idSTP enabledinterfaces</span><br><span class="line">docker08000.0242c0e58c93noveth1680438</span><br><span class="line">            vethf3bf38b</span><br></pre></td></tr></table></figure><blockquote><p>참고로 mac이나 window에서는 이 <code>docker0</code> 브릿지나 <code>veth interface</code> 들을 볼 수 없다<br>VM 안으로 감쳐줘 있기 때문이다</p></blockquote><h2 id="사실-docker-container의-네트워크-모드는-총-4개이다"><a class="markdownIt-Anchor" href="#사실-docker-container의-네트워크-모드는-총-4개이다"></a> 사실 docker container의 네트워크 모드는 총 4개이다</h2><p>bridge, host, container, none 으로 총 4개가 존재한다<br>위에서 살펴본 구조가 bridge 네트워크로 생성한 container의 동작방식이며, default 값이다<br>kubernetes의 pod을 생성할때는 container 모드를 사용한다<br>자세한 내용은 <a href="https://bluese05.tistory.com/38" rel="external nofollow noopener noreferrer" target="_blank">https://bluese05.tistory.com/38</a>를 참조한다</p><h2 id="docker-compose-로-띄우면-다른-네트워크-대역을-가진다"><a class="markdownIt-Anchor" href="#docker-compose-로-띄우면-다른-네트워크-대역을-가진다"></a> docker-compose 로 띄우면 다른 네트워크 대역을 가진다</h2><p>docker-compose 를 공부할 때 docker-compose 로 띄운 컨테이너들은 모두 같은 네트워크에 속한다는 말이 있었고, 실제로도 그랬다<br>단독으로 띄운 도커 컨테이너와 docker-compose 를 통해 띄운 도커 컨테이너들을 들어가서 ip를 확인해보면 각자 네트워크 대역대가 다름을 알 수 있다</p><p>이는 docker-compose 로 컨테이너를 띄우면 compose 로 묶은 범위에 맞춰 브릿지를 하나 더 생성하기 때문이다</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 이렇게 docker-compose로 컨테이너를 띄우고</span></span><br><span class="line">$ docker-compose -f docker-compose.yml up</span><br><span class="line"><span class="comment"># 네트워크 인터페이스를 확인해보면</span></span><br><span class="line">$ ip link ls</span><br><span class="line"></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">2: enp0s3: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether 08:00:27:d8:72:d9 brd ff:ff:ff:ff:ff:ff</span><br><span class="line"><span class="comment"># docker0 브릿지와 아까 띄워놓은 컨테이너들</span></span><br><span class="line">3: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP mode DEFAULT group default</span><br><span class="line">    link/ether 02:42:c0:e5:8c:93 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">4: vethf3bf38b@if34: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP mode DEFAULT group default</span><br><span class="line">    link/ether 02:13:50:cf:5c:48 brd ff:ff:ff:ff:ff:ff link-netnsid 1</span><br><span class="line">5: veth1680438@if36: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP mode DEFAULT group default</span><br><span class="line">    link/ether f2:b2:f7:eb:a5:55 brd ff:ff:ff:ff:ff:ff link-netnsid 2</span><br><span class="line"><span class="comment"># 여기서부터 docker-compose로 띄운 부분</span></span><br><span class="line"><span class="comment"># bridge가 하나 더 생겼다!</span></span><br><span class="line">6: br-776e18676383: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP mode DEFAULT group default</span><br><span class="line">    link/ether 02:42:e0:f3:47:6b brd ff:ff:ff:ff:ff:ff</span><br><span class="line">7: vethc059d77@if39: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master br-776e18676383 state UP mode DEFAULT group default</span><br><span class="line">    link/ether 0a:f7:37:0c:<span class="built_in">cd</span>:64 brd ff:ff:ff:ff:ff:ff link-netnsid 3</span><br><span class="line">8: veth0fea37d@if41: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master br-776e18676383 state UP mode DEFAULT group default</span><br><span class="line">    link/ether b2:95:86:71:c6:43 brd ff:ff:ff:ff:ff:ff link-netnsid 4</span><br></pre></td></tr></table></figure><p>이런 상태이므로 물론 docker-compose로 띄운 컨테이너와 일반 컨테이너간의 통신은 불가능하다(서로 경유하는 브릿지가 다르므로)</p><h1 id="외부와-통신은-어떻게-할까"><a class="markdownIt-Anchor" href="#외부와-통신은-어떻게-할까"></a> 외부와 통신은 어떻게 할까?</h1><p>우리는 컨테이너를 띄울 때 아래와 같이 포트포워딩을 설정하여 외부에 컨테이너를 공개할 수 있다(+expose)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 포트포워딩 설정하여 컨테이너 생성</span></span><br><span class="line">$ docker container run -p 8080:80 nginx</span><br><span class="line"><span class="comment"># 포트 listen 확인</span></span><br><span class="line">$ netstat -nlp | grep 8080</span><br><span class="line"></span><br><span class="line">tcp6       0      0 :::8080                 :::*                    LISTEN      26113/docker-proxy-</span><br></pre></td></tr></table></figure><p>근데 보다시피 <code>docker-proxy</code> 라는 프로세스가 해당 포트를 listen 하고 있음을 볼 수 있다<br>이는 간단히 docker host 로 들어온 요청을 해당하는 컨테이너로 넘기는 역할만을 수행하는 프로세스이다<br>컨테이너에 포트포워딩이나 expose를 설정했을 경우 같이 생성되는 프로세스이다</p><p>그렇지만 중요한것은, 실제로 포트포워딩을 이 docker-proxy가 담당하는 것이 아니라, host PC iptables 에서 관리한다는 점이다</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ iptables -t nat -L -n</span><br><span class="line"></span><br><span class="line">Chain PREROUTING (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination</span><br><span class="line">DOCKER     all  --  0.0.0.0/0            0.0.0.0/0            ADDRTYPE match dst-type LOCAL</span><br><span class="line"></span><br><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination</span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination</span><br><span class="line">DOCKER     all  --  0.0.0.0/0           !127.0.0.0/8          ADDRTYPE match dst-type LOCAL</span><br><span class="line"></span><br><span class="line">Chain POSTROUTING (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination</span><br><span class="line">MASQUERADE  all  --  172.17.0.0/16        0.0.0.0/0</span><br><span class="line">MASQUERADE  tcp  --  172.17.0.4           172.17.0.4           tcp dpt:80</span><br><span class="line"></span><br><span class="line">Chain DOCKER (2 references)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination</span><br><span class="line">RETURN     all  --  0.0.0.0/0            0.0.0.0/0</span><br><span class="line">DNAT       tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:8080 to:172.17.0.4:80</span><br></pre></td></tr></table></figure><p>보다시피 모든 요청을 DOCKER Chain 으로 넘기고, DOCKER Chain 에서는 DNAT를 통해 포트포워딩을 해주고 있음을 볼 수 있다<br>(이 iptables 룰은 docker daemon이 자동으로 한다)</p><p>docker-proxy 는 iptables가 어떠한 이유로 NAT를 사용하지 못하게 될 경우 사용된다고 한다</p><p>참고 :</p><ul><li>NET namespace, veth interface : <a href="https://bluese05.tistory.com/28" rel="external nofollow noopener noreferrer" target="_blank">https://bluese05.tistory.com/28</a></li><li>도커 네트워크 구조 : <a href="https://bluese05.tistory.com/15" rel="external nofollow noopener noreferrer" target="_blank">https://bluese05.tistory.com/15</a></li><li>도커 네트워크 외부 통신 : <a href="https://bluese05.tistory.com/53" rel="external nofollow noopener noreferrer" target="_blank">https://bluese05.tistory.com/53</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;도커를 공부하면서 네트워크 부분에서 알게된 부분은 아래와 같았다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;도커 컨테이너를 띄울때마다 매번 동일한 네트워크 대역의 IP가 할당된다&lt;/li&gt;
&lt;li&gt;각 컨테이너들은 서로 통신이 가능하다&lt;/li&gt;
&lt;li&gt;docker-co
      
    
    </summary>
    
      <category term="docker" scheme="https://joont92.github.io/categories/docker/"/>
    
    
      <category term="docker" scheme="https://joont92.github.io/tags/docker/"/>
    
      <category term="docker network" scheme="https://joont92.github.io/tags/docker-network/"/>
    
      <category term="docker0" scheme="https://joont92.github.io/tags/docker0/"/>
    
  </entry>
  
  <entry>
    <title>[kubernetes] 주요 개념</title>
    <link href="https://joont92.github.io/kubernetes/%EC%A3%BC%EC%9A%94-%EA%B0%9C%EB%85%90/"/>
    <id>https://joont92.github.io/kubernetes/주요-개념/</id>
    <published>2019-06-21T22:10:49.000Z</published>
    <updated>2020-11-02T10:09:30.457Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kubernetes란"><a class="markdownIt-Anchor" href="#kubernetes란"></a> kubernetes란?</h1><p>구글이 2014년에 발표한 <strong>컨테이너 오케스트레이션 도구</strong>이다</p><blockquote><p>컨테이너 오케스트레이션 도구란 <code>많은 수의 컨테이너를 협조적으로 연동시키기 위한 통합 시스템</code>을 말한다</p></blockquote><p>도커 등장 이래로 많은 오케스트레이션 도구가 나왔지만(mesos, ECS, Swarm 등),<br>쿠버네티스가 가장 강력한 끝판왕으로 등장함에 따라 현재는 사실상 표준이 된 상태이다<br>많은 클라우드 플랫폼에서도 쿠버네티스를 연동하여 사용할 수 있는 기술을 제공한다</p><blockquote><p>GCP는 GKE, AWS는 EKS, 애저는 AKS</p></blockquote><h2 id="로컬에서-kubernetes-띄우기"><a class="markdownIt-Anchor" href="#로컬에서-kubernetes-띄우기"></a> 로컬에서 kubernetes 띄우기</h2><p>예전에는 로컬에서 kubernetes를 띄우려면 minikube 를 이용해야 했는데<br>minikube는 기존에 도커를 위해 띄워진 VM에 쿠버네티스를 띄우는 것이 아니라 새로운 VM(dockerd)를 띄우는 방식이므로 조금 까다로운 면이 있었다</p><p>하지만 요즘에는 윈도우/macOS용 도커에서 쿠버네티스 통합 기능을 제공해주므로 이를 사용하여 간단하게 쿠버네티스를 구축할 수 있다<br>대신 minikube 에 자동으로 설치되어 있는 대시보드 같은것은 추가로 설치해줘야 하는 불편함은 있다</p><p>mac에서 kubernetes 설치는 <code>kubernetes</code> 탭의 <code>Enable Kubernetes</code>만 클릭해주면 된다<br><img src="https://joont92.github.io/temp/mac-kubernetes.png" alt="mac kubernetes 설치"></p><p>그리고 쿠버네티스 API를 실행하기 위한 명령행 도구인 kubectl도 설치해준다<br><a href="https://kubernetes.io/docs/tasks/tools/install-kubectl/" rel="external nofollow noopener noreferrer" target="_blank">https://kubernetes.io/docs/tasks/tools/install-kubectl/</a></p><h1 id="kubernetes-주요-개념"><a class="markdownIt-Anchor" href="#kubernetes-주요-개념"></a> kubernetes 주요 개념</h1><p>쿠버네티스 내에는 매우 다양한 리소스들이 존재하고, 이 리소스들이 클러스터내에서 서로 연동하고 협조하면서 컨테이너 시스템을 구성하는 형태이다</p><blockquote><p>하나의 쿠버네티스 환경 자체를 클러스터라고 부른다</p></blockquote><h2 id="노드"><a class="markdownIt-Anchor" href="#노드"></a> 노드</h2><p>쿠버네티스 내에 떠있는 호스트들(가상머신이나 물리적 서버머신)이다<br>이중에서도 마스터 노드와 일반 노드들로 나뉘는데, 마스터 노드에는 쿠버네티스 클러스 전체를 관리하기 위한 관리 컴포넌트들이 자리하는 곳이고, 이 관리 컴포넌트들에 의해 일반 노드들로 컨테이너들이 오케스트레이션 되는 구조이다</p><p>마스터 노드에 들어가는 관리 컴포넌트들의 종류는 아래와 같다</p><ul><li>kube-apiserver</li><li>kube-scheduler</li><li>kube-controller-manager</li><li>etcd</li></ul><blockquote><p>마스터 노드에는 이 관리 컴포넌트 외에 다른 컴포넌트(Pod)들은 들어갈 수 없다</p></blockquote><hr><p>여기까지가 기본적인 개념이고, 이제부터 쿠버네티스의 주요 리소스에 대해 설명하겠다<br>아래는 간단한 설명이며, 상세한 설명은 <a href="https://bcho.tistory.com" rel="external nofollow noopener noreferrer" target="_blank">조대협님의 블로그</a>를 보는 것이 좋을 것 같다</p><h2 id="오브젝트"><a class="markdownIt-Anchor" href="#오브젝트"></a> 오브젝트</h2><p>쿠버네티스에서 가장 중요한 부분은 <code>오브젝트</code>라는 개념인데, 이 오브젝트는 크게 <code>기본 오브젝트</code>와 <code>컨트롤러</code>로 나뉜다<br>기본 오브젝트는 리소스들의 가장 기본적인 구성 단위이며, 컨트롤러는 이 기본 오브젝트들을 생성하고 관리하는 기능을 가진 애들을 말한다</p><p>기본 오브젝트의 종류는 아래와 같고</p><ul><li>파드</li><li>서비스</li><li>볼륨</li><li>네임스페이스</li></ul><p>컨트롤러의 종류는 아래와 같다</p><ul><li>레플리카 셋</li><li>디플로이먼트</li><li>스테이트풀 셋</li><li>데몬 셋</li><li>잡</li></ul><blockquote><p>참고로 아래에서 설명하겠지만, 이 오브젝트들은 모두 논리적인 단위이다<br><strong>각 노드들에 생성된 수많은 도커 컨테이너, 네트워크 인터페이스들을 쿠버네티스가 논리적인 단위로 묶어서 Pod, Service, namespace 등의 개념으로 제공하게 되는 것이다</strong></p></blockquote><p>이 오브젝트에 중요한 속성이 있는데, 바로 <code>스펙</code>과 <code>상태</code>이다<br>스펙은 우리가 직접 설정파일 같은 것으로 작성해서 전달해줘야 하는것으로써, 오브젝트가 어떤 상태가 되어야 한다고 작성한 것을 말한다<br>아래는 스펙의 간단한 예제이다</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">myapp-pod</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">myapp-container</span></span><br><span class="line"><span class="attr">      image:</span> <span class="string">busybox</span> <span class="comment"># 이미지는 로컬을 참조하지 않고 항상 registry에서 땡겨오는 것 같다</span></span><br><span class="line"><span class="attr">      command:</span> <span class="string">['sh',</span> <span class="string">'-c'</span><span class="string">,</span> <span class="string">'echo Hello Kubernetes! &amp;&amp; sleep 3600'</span><span class="string">]</span></span><br></pre></td></tr></table></figure><p>busybox 이미지를 가진 container가 하나 들어가있는 pod를 띄워야한다고 스펙에 명시했다<br>이 스펙을 보고 쿠버네티스는 오브젝트를 생성하게 될 것이며, 이 오브젝트에 대한 상태는 쿠버네티스에 의해 제공되게 된다<br>그리고 쿠버네티스는 이 오브젝트의 상태가 우리가 원한 상태와 일치하도록 계속 관리해주는 역할을 수행하게된다</p><blockquote><p>원하는 상태를 직접 명시하지는 않았지만, 아마도 RUNNING 을 말하는거겠지…</p></blockquote><h3 id="기본-오브젝트-pod"><a class="markdownIt-Anchor" href="#기본-오브젝트-pod"></a> 기본 오브젝트 - Pod</h3><p>쿠버네티스의 가장 기본적인 배포 단위(컨테이너)이다<br>우리가 알고있는 도커 컨테이너와는 조금 다른게, 하나의 Pod는 하나 이상의 컨테이너를 포함할 수 있는 구조이다<br>즉 웹서버를 구성한다고 할 때 nginx pod, spring-boot pod, mysql pod 를 각각 띄워야 하는 것이 아니라 이 컨테이너들을 모두 하나의 pod에 넣을 수 있다는 의미이다</p><p>위의 오브젝트의 스펙을 설명하는 부분에서 Pod의 설정파일 예시를 작성했는데, 보다시피 spec에 containers 로 여러 컨테이너를 받을 수 있게 되어있다</p><blockquote><p>하나의 Pod는 하나의 노드에만 배치될 수 있다<br>Pod 내의 컨테이너가 각각 다른 노드에 배치될 수 없다</p></blockquote><p>이러한 특징 때문에,<br>쿠버네티스 내에서 Pod를 띄울경우 내부의 컨테이너가 다 떠야 Pod 의 상태가 RUNNING 으로 표시되고(e.g. 2/2),<br>Pod 에 접근하고자 할 경우 <code>-c</code> 옵션으로 접근할 컨테이너를 지정해줘야 한다</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl <span class="built_in">exec</span> -it myapp-pod /bin/bash -c myapp-container</span><br></pre></td></tr></table></figure><p>그리고 추가로,<br>Pod에는 관심사를 합칠 수 있다는 장점(컨테이너들을 여러개 묶어서 배포할 수 있으므로) 외에도 추가적인 장점이 존재한다</p><p><strong>첫째로, Pod 내의 컨테이너들은 서로 IP와 Port를 공유한다</strong><br>기존에 docker-compose로 띄웠던 컨테이너들이 서로 이름으로 참조했던 방식이 아닌, 서로 localhost로 통신할 수 있는 방식이다<br>즉, 1개의 Pod 내에 만약 spring-boot, mysql이 있다고 한다면 각자 서로를 localhost:8080, localhost:3306 으로 참조할수 있게 되는 것이다</p><blockquote><p>각자의 IP를 가지는 컨테이너들이 어떻게 localhost로 통신할 수 있을까?</p></blockquote><p><strong>둘째로, Pod 내부의 모든 컨테이너가 공유하는 볼륨을 설정할 수 있다</strong><br>즉 Pod 내부의 모든 컨테이너는 그 볼륨에 접근할 수 있고, 그 컨테이너끼리 데이터를 공유하는 것을 허용하게 되는 것이다</p><h3 id="기본-오브젝트-서비스"><a class="markdownIt-Anchor" href="#기본-오브젝트-서비스"></a> 기본 오브젝트 - 서비스</h3><p>아래에서 다시 설명하겠지만, Pod의 경우 kubernetes 에서 가장 작은 단위의 리소스라 삭제되거나 추가되는 행위가 잦은 리소스이다(scalable)<br>문제는 매번 삭제되고 추가될 때 마다 IP가 랜덤하게 새로 부여된다는 것이다<br>이러한 상황에서는 고정된 엔드포인트로 호출하는 것이 어려워진다<br>또한 Pod의 경우 보통 1개로 운영하지 않고, 여러개의 Pod을 띄워서 로드밸런싱을 제공해줘야 한다<br>즉, 이러한 역할을 해주는 리소스가 Pod들 앞단에 하나 더 존재해야하는데, <code>서비스</code>가 이러한 역할을 한다<br>서비스는 지정된 IP로 생성이 가능하고, 여러 Pod를 묶어서 로드 밸런싱이 가능하며, 고유한 DNS 이름을 가질 수 있다</p><p>서비스가 Pod 들을 묶을 때는 <code>레이블</code>과 <code>셀렉터</code> 라는 개념을 사용하는데, 아래의 스펙을 보면 직관적으로 이해할 수 있을 것이다</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">my-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">    - protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">      port:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>보다시피 selector 로 <code>app: myapp</code> 이라고 선언해놓았는데, 이는 <code>app: myapp</code> 이라는 레이블을 가진 Pod 들을 선택해서 <code>my-service</code> 라는 서비스로 묶겠다는 의미이다</p><p>그렇다면 label은 어떻게 설정하는가?<br>위의 Pod 를 설정할 때 metadata에 <code>label: myapp</code> 이라는 부분을 봤을 것이다</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">myapp-pod</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">myapp</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure><p>이 부분이 리소스에 label을 설정하는 부분이다<br>label은 여러개 설정할 수 있다</p><p>이제 이렇게 서비스를 정의했으니 이 서비스를 통해 Pod 에 접근할 수 있어야 할 것이다<br>이는 서비스를 생성할 때 지정하는 타입에 따라 방식이 나뉜다<br>쿠버네티스에서 지원하는 서비스의 타입들은 아래와 같다</p><ul><li><p><strong>ClusterIp</strong><br>디폴트 설정으로, 서비스에 내부 IP(Cluster IP)를 할당한다<br>그러므로 클러스터 내에서는 접근이 가능하지만, 클러스터 외부에서는 접근이 불가능하다<br>클러스터 내의 컨테이너로 들어간 뒤 <code>curl http://my-service[:80]</code> 를 호출하면 myapp 레이블을 가진 pod의 80포트로 연결될 것이다(targetPort 지정가능, 지정하지 않을 시 port와 동일하게 설정)</p></li><li><p><strong>NodePort</strong><br>Cluster IP 로 접근가능하면서 모든 노드의 IP와 포트를 통해서도 접근이 가능하게 된다</p>  <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">....</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">    selector:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">NodePort</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">      - protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">        port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">        nodePort:</span> <span class="number">31111</span></span><br></pre></td></tr></table></figure><p>클러스터 내에서 <code>&lt;내부IP&gt;:&lt;포트&gt;</code>으로도 접속 가능하고, 외부에서 <code>&lt;NodeIP&gt;:&lt;NodePort&gt;</code>로도 접근 가능하다</p><p>모든 Node의 포트가 열리고, 해당 서비스로 연결된다<br>30000 ~ 32767 까지 사용 가능<br>노드의 IP가 바뀔 수 있는 부분을 처리해줘야함<br>보통 ingress랑 같이 씀<br>ingress랑 같이 쓰면 해결됨<br>api gateway 붙이기 싫을 때 ingress를 쓴다?</p></li><li><p><strong>LoadBalancer</strong><br>보통 클라우드 서비스에서만 설정 가능한 방식으로, 외부 IP를 가지고 있는 로드밸런서를 할당한다<br>외부 IP를 가지고 있기 때문에 외부에서 접근이 가능하다<br>클라우드 서비스 내에서 외부 IP가 할당된 로드밸런서를 생성하고 서비스에 연결시키는 구조<br>서비스 자체에 로드밸런싱 기능이 있는데, 왜 굳이 로드밸런서를 할당시키는지?</p></li><li><p><strong>ExternalName</strong><br>외부 서비스를 쿠버네티스 내부에서 호출하고자 할 떄 사용할 수 있다<br>클러스터 내의 Pod들이 클러스터 밖에 있는 서비스(예를 들면 RDS)를 호출하려면 NAT 설정 등 복잡한 설정이 필요한데, 서비스를 externalName 타입으로 설정하면 이를 간단하게 해결 가능하다</p>  <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">my-service-for-rds</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">    selector:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">myproxy</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">ExternalName</span></span><br><span class="line"><span class="attr">    externalName:</span> <span class="string">xxxx-rds.amazonaws.com</span></span><br></pre></td></tr></table></figure><p>이렇게 설정하면 클러스터 내의 Pod 들이 이 서비스를 호출할 경우 <code>xxxx-rds.amazoneaws.com</code> 으로 포워딩해주게 된다(일종의 프록시 역할)</p></li></ul><h3 id="기본-오브젝트-볼륨"><a class="markdownIt-Anchor" href="#기본-오브젝트-볼륨"></a> 기본 오브젝트 - 볼륨</h3><p>도커로 볼륨을 연결할때를 생각해보면, 볼륨은 도커 컨테이너가 생성된 호스트에 위치해야 했다<br>하지만 쿠버네티스의 특성상 Pod가 여러 호스트(노드)를 교차하면서 배포되므로, 이러면 너무 번거롭다<br>쿠버네티스는 이를 해결하기 위해 <code>PersistentVolume</code>, <code>PersistentVolumeClaim</code> 이라는 것을 제공한다</p><p>간단히 말해 PersistentVolume은 쿠버네티스에 지정한 물리 디스크이고, PersistentVolumeClaim은 그 PersistentVolume과 Pod를 연결할 수 있게 해주는 개념이다<br>자세한 내용은 <a href="https://bcho.tistory.com/1259" rel="external nofollow noopener noreferrer" target="_blank">https://bcho.tistory.com/1259</a> 를 참고한다</p><p>PersistentVolume 외에도 쿠버네티스는 다양한 볼륨을 지원한다<br><a href="https://kubernetes.io/docs/concepts/storage/volumes/" rel="external nofollow noopener noreferrer" target="_blank">https://kubernetes.io/docs/concepts/storage/volumes/</a></p><h3 id="기본-오브젝트-네임스페이스"><a class="markdownIt-Anchor" href="#기본-오브젝트-네임스페이스"></a> 기본 오브젝트 - 네임스페이스</h3><p>쿠버네티스 클러스터내의 논리적인 분리단위이다<br>네임스페이스별로 리소스들을 나눠서 관리할 수 있고, 접근권한, 리소스 할당량 등을 설정할 수 있다</p><hr><h3 id="컨트롤러-replicaset"><a class="markdownIt-Anchor" href="#컨트롤러-replicaset"></a> 컨트롤러 - ReplicaSet</h3><p>알다시피 어느정도 규모가 되는 어플리케이션을 구축하려면 하나의 Pod로는 안되고, Pod를 여러개 실행해 가용성을 확보해야 한다<br>이럴때 사용하는 것이 <code>RelicaSet</code>이다<br>ReplicaSet는 똑같은 정의를 갖는 Pod를 여러개 생성하고 관리하기 위한 리소스이다</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicaSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">    replicas:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">    selector:</span></span><br><span class="line"><span class="attr">        matchLabels:</span> </span><br><span class="line"><span class="attr">            tier:</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">    template:</span></span><br><span class="line"><span class="attr">        metadata:</span></span><br><span class="line"><span class="attr">            labels:</span></span><br><span class="line"><span class="attr">                tier:</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">        spec:</span></span><br><span class="line"><span class="attr">            containers:</span></span><br><span class="line"><span class="attr">              - name:</span> <span class="string">php-redis</span></span><br><span class="line"><span class="attr">                image:</span> <span class="string">gcr.io/google_samples/gb-frontend:v3</span></span><br></pre></td></tr></table></figure><p>보다시피 크게 <code>replicas, selector, template</code> 3가지의 파트로 구성된다</p><ul><li>replicas<br>ReplicaSet에 의해 관리될 Pod의 개수이다<br>설정된 값보다 Pod의 수가 적으면 추가로 띄우고, Pod의 수가 더 많으면 남는 Pod를 삭제한다</li><li>selector<br>ReplicaSet으로 관리할 Pod를 선택한다<br>현재는 label을 기반으로 select 하고 있다<blockquote><p>service 의 selector 와 문법이 달라서 혼동될 수 있는데, 그냥 지원되지 않는 것이라고 한다(deployment 는 됨)<br><a href="https://medium.com/@zwhitchcox/matchlabels-labels-and-selectors-explained-in-detail-for-beginners-d421bdd05362" rel="external nofollow noopener noreferrer" target="_blank">https://medium.com/@zwhitchcox/matchlabels-labels-and-selectors-explained-in-detail-for-beginners-d421bdd05362</a></p></blockquote></li><li>template<br>Pod를 <code>추가로 띄울 때</code> 어떻게 만들지에 대한 Pod 정보를 정의해놓은 부분이다<br>새로 생성된 Pod도 selector에 의해 선택되어야 하므로 selector의 label과 동일하게 맞춰줘야 한다</li></ul><p>아래는 ReplicaSet에 대해 조금 주의(?)할 부분들이다</p><ul><li>ReplicaSet 생성 시 label이 일치하면 기존에 떠있는 Pod 들도 같이 ReplicaSet로 묶이는데, 이 Pod들이 template에 있는 Pod의 형태와 않더라도 삭제되지 않음에 주의해야 한다<blockquote><p>e.g. 기존에 <code>app: reverse-proxy</code> 레이블의 apache Pod가 떠있는 상태에서,<br><code>selector = app: reverse-proxy, template = nginx</code>의 ReplicaSet을 생성하면 기존의 apache Pod는 삭제되지않고 같은 ReplicaSet이 된다</p></blockquote></li><li>selector 가 Pod 들을 묶는 기준이니까, 기존에 ReplicaSet가 띄워진 상태에서 selector 를 바꾸게 되면 기존의 Pod 들은 삭제되지 않고 남아있게 되나?<blockquote><p>ReplicaSet으로 떠있는 상태에서 selector를 바꾸게 되면 문법적으로 오류가 발생한다<br>ReplicaSet에 대한 메타정보(떠있는 Pod들과 매핑 등)이 마스터 노드 어딘가에… 저장되어서 그것으로 판단하는 것 같다</p></blockquote></li></ul><h3 id="컨트롤러-deployment"><a class="markdownIt-Anchor" href="#컨트롤러-deployment"></a> 컨트롤러 - Deployment</h3><p>ReplicaSet 보다 상위에 있는 개념으로 ReplicaSet 배포의 기본 단위가 되는 리소스이다<br>아래와 같은 관계이다</p><p><img src="https://joont92.github.io/temp/Deployment-ReplicaSet.png" alt="Deploymemnt, ReplicaSet"></p><p>쿠버네티스는 이 Deployment를 단위로 애플리케이션을 배포한다<br>실제 운영에서는 ReplicaSet을 직접 다루기보다는 Deployment를 통해 배포하는 경우가 대부분이다</p><p>설정은 ReplicaSet와 거의 동일하게 작성한다</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">    label:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">    replicas:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">    selector:</span></span><br><span class="line"><span class="attr">        matchLabels:</span></span><br><span class="line"><span class="attr">            tier:</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">    template:</span></span><br><span class="line"><span class="attr">        metadata:</span></span><br><span class="line"><span class="attr">            labels:</span></span><br><span class="line"><span class="attr">                tier:</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">        spec:</span></span><br><span class="line"><span class="attr">            containers:</span></span><br><span class="line"><span class="attr">              - name:</span> <span class="string">php-redis</span></span><br><span class="line"><span class="attr">                image:</span> <span class="string">gcr.io/google_samples/gb-frontend:v3</span></span><br></pre></td></tr></table></figure><p>Deployment의 특징은 리비전을 사용해 배포를 관리할 수 있다는 점이다</p><p>Deployment를 생성한 뒤 리비전을 확인해본다</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f deployment.yml --record <span class="comment"># 어떤 kubectl을 실행했는지 남기기 위함</span></span><br><span class="line">$ kubectl rollout <span class="built_in">history</span> deployment frontend</span><br><span class="line"></span><br><span class="line">deployment.extensions/fronend</span><br><span class="line">REVISION  CHANGE-CAUSE</span><br><span class="line">1         kubectl apply --filename=deployment.yaml --record=<span class="literal">true</span></span><br></pre></td></tr></table></figure><blockquote><p>결과로는 <code>REVISION=1</code> 값이 출력됨을 볼 수 있다</p></blockquote><p>이 리비전값은 아래와 같은 특성이 있다</p><ul><li>replicas 의 값을 바꿔도 리비전값이 올라가진 않는다</li><li>replicaSet 컨테이너의 이미지를 바꾸고 적용하면 리비전값이 올라간다</li></ul><p>리비전을 올리기 위해 아래와 같이 컨테이너 이미지를 바꾸고</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">containers:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">php-redis</span></span><br><span class="line"><span class="attr">      image:</span> <span class="string">gcr.io/google_samples/gb-frontend:v4</span></span><br></pre></td></tr></table></figure><p>deployment를 다시 적용하면 리비전값이 올라감을 볼 수 있다</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl rollout <span class="built_in">history</span> deployment <span class="built_in">echo</span></span><br><span class="line"></span><br><span class="line">deployment.extensions/frontend</span><br><span class="line">REVISION  CHANGE-CAUSE</span><br><span class="line">1         kubectl apply --filename=deployment.yaml --record=<span class="literal">true</span></span><br><span class="line">2         kubectl apply --filename=deployment.yaml --record=<span class="literal">true</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pods --selector app=frontend</span><br><span class="line"></span><br><span class="line">NAME                        READY   STATUS        RESTARTS   AGE</span><br><span class="line">frontend-6bfffbcf9f-n42dh   1/1     Running       0          1m</span><br><span class="line">frontend-6bfffbcf9f-tssb9   1/1     Running       0          1m</span><br><span class="line">frontend-6bfffbcf9f-vfmcj   1/1     Running       0          1m</span><br><span class="line">frontend-8556ddbfb9-zpfrg   0/1     Terminating   0          3m</span><br><span class="line">frontend-8556ddbfb9-9p7ld   0/1     Terminating   0          3m</span><br><span class="line">frontend-8556ddbfb9-x5kvb   0/1     Terminating   0          3m</span><br></pre></td></tr></table></figure><p>이렇게 리비전으로 관리하게 됨으로써 Deployment를 <strong>롤백이 가능하게 된다</strong></p><pre class="highlight"><code class="sh">$ kubectl rollout undo deployment frontend</code></pre><blockquote><p>Pod를 확인해보면 바로 직전 리비전으로 롤백되고 있음을 볼 수 있다(바로 직전만 가능한 듯 하다)<br>롤백되면 리비전이 다시 1로 돌아가는 것이 아니라, 3으로 올라간다<br>리비전은 최대 10까지 가능한 것 같다</p></blockquote><p>참고 :</p><ul><li><a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&amp;mallGb=KOR&amp;barcode=9791158391447&amp;orderClick=LEA&amp;Kc=" rel="external nofollow noopener noreferrer" target="_blank">야마다 아키노리, 『도커/쿠버네티스를 활용한 컨테이너 개발 실전 입문』, 심효섭 옮김, 위키북스(2019)</a></li><li>쿠버네티스 개념 이해 <a href="https://bcho.tistory.com/1256?category=731548" rel="external nofollow noopener noreferrer" target="_blank">https://bcho.tistory.com/1256?category=731548</a></li><li>쿠버네티스 서비스 <a href="https://bcho.tistory.com/1262" rel="external nofollow noopener noreferrer" target="_blank">https://bcho.tistory.com/1262</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;kubernetes란&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#kubernetes란&quot;&gt;&lt;/a&gt; kubernetes란?&lt;/h1&gt;
&lt;p&gt;구글이 2014년에 발표한 &lt;strong&gt;컨테이너 오케스트레이션 도구&lt;/stro
      
    
    </summary>
    
      <category term="kubernetes" scheme="https://joont92.github.io/categories/kubernetes/"/>
    
    
      <category term="도커/쿠버네티스를 활용한 컨테이너 개발 실전 입문" scheme="https://joont92.github.io/tags/%EB%8F%84%EC%BB%A4-%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EA%B0%9C%EB%B0%9C-%EC%8B%A4%EC%A0%84-%EC%9E%85%EB%AC%B8/"/>
    
      <category term="kubernetes object" scheme="https://joont92.github.io/tags/kubernetes-object/"/>
    
      <category term="kubernetes pod" scheme="https://joont92.github.io/tags/kubernetes-pod/"/>
    
      <category term="kubernetes service" scheme="https://joont92.github.io/tags/kubernetes-service/"/>
    
      <category term="kubernetes replicaset" scheme="https://joont92.github.io/tags/kubernetes-replicaset/"/>
    
      <category term="kubernetes deployment" scheme="https://joont92.github.io/tags/kubernetes-deployment/"/>
    
  </entry>
  
  <entry>
    <title>[docker] volume container 추가하기</title>
    <link href="https://joont92.github.io/docker/volume-container-%EC%B6%94%EA%B0%80%ED%95%98%EA%B8%B0/"/>
    <id>https://joont92.github.io/docker/volume-container-추가하기/</id>
    <published>2019-06-16T22:41:01.000Z</published>
    <updated>2020-11-02T10:09:30.453Z</updated>
    
    <content type="html"><![CDATA[<h1 id="volume-container란"><a class="markdownIt-Anchor" href="#volume-container란"></a> volume container란?</h1><p>일반적으로 docker container는 컨테이너 내부에 데이터를 관리하므로, 컨테이너가 파기되면 데이터가 모두 날라가게 된다<br>이는 mysql 같은 데이터 스토리지를 사용할 경우 위험하게 되는데, 이를 방지하기 위해 따로 볼륨을 설정해서 데이터를 저장해줘야 한다<br>호스트OS 디렉토리를 마운트시켜서 데이터를 관리할 수도 있지만, 호스트쪽 디렉토리에 의존이 생기고 만약 이 디렉토리의 데이터를 잘못 손대면 애플리케이션에 부정적 영향을 미칠 수 있기 때문에 이 방식은 사용하지 않는것이 좋다</p><p>그래서 이에 대한 대안으로 추천되는것이 <code>볼륨 컨테이너</code>이다<br>볼륨 컨테이너는 말 그대로 데이터를 저장하는 것이 목적인 컨테이너이다<br>기본적으로 우리는 <code>Dockerfile</code> 작성 시 아래와 같이 볼륨을 설정할 수 있다</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> mysql</span><br><span class="line"></span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> /var/lib/mysql</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># ...</span></span></span><br></pre></td></tr></table></figure><p>위처럼 작성하게 되면 컨테이너 내의 <code>/var/lib/mysql</code> 디렉터리가 호스트 PC의 <code>/var/lib/docker/volumes/${volume_name}/_data</code>에 마운트 된다<br>(볼륨 이름은 임의의 해쉬값으로 생성된다)</p><blockquote><p>참고로 mac이나 windows의 경우 <code>/var/lib/docker/volumes</code> 디렉토리가 없는데,<br>이는 mac이나 windows의 경우 docker를 바로 실행할 수 없으므로 VM을 하나 띄운 뒤, docker를 실행하기 때문이다<br>즉, <code>/var/lib/docker/volumes</code> 디렉토리는 mac과 docker 사이에 띄워진 VM 내에 감춰져있다<br>참고 : <a href="https://forums.docker.com/t/var-lib-docker-does-not-exist-on-host/18314" rel="external nofollow noopener noreferrer" target="_blank">https://forums.docker.com/t/var-lib-docker-does-not-exist-on-host/18314</a></p></blockquote><p>volume container는 볼륨의 이러한 특징을 사용한 것이다<br>컨테이너 자체를 볼륨을 관리하는 애로 만들어서 캡슐화하고, 이를 다른 컨테이너의 볼륨에 매핑해서 결합을 느슨하게 하는 것이다</p><p>만약 아래와 같은 볼륨 컨테이너를 작성하고,</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> busybox <span class="comment"># 최소한의 운영체제 기능만 제공</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> /var/lib/mysql</span></span><br><span class="line"><span class="bash">VOLUME /var/<span class="built_in">log</span></span></span><br></pre></td></tr></table></figure><blockquote><p><code>/var/lib/mysql</code>, <code>/var/log</code> 디렉토리에 대한 볼륨 2개가 생성되어 각각 <code>/var/lib/docker/volumes/${volume_name}/_data</code> 에 마운트 된다</p></blockquote><p>빌드하고 컨테이너로 띄운 뒤,</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker image build -t volume_container:latest .</span><br><span class="line">$ docker container run -d volume_container:latest</span><br></pre></td></tr></table></figure><blockquote><p>참고로 볼륨 컨테이너를 띄우면 바로 종료되는데, 이렇게 종료된 컨테이너를 사용해도 상관없다</p></blockquote><p><code>--volumes-from</code> 옵션으로 다른 컨테이너에 연결한다면</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run --volumes-from volume_container mysql:5.7</span><br></pre></td></tr></table></figure><p>아래와 같은 형태가 되는 것이다</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql container -&gt; volume_container -&gt; /var/lib/docker/volumes/$&#123;/var/lib/mysql&apos;s volume_name&#125;/_data</span><br><span class="line">                                    -&gt; /var/lib/docker/volumes/$&#123;/var/log&apos;s volume_name&#125;/_data</span><br></pre></td></tr></table></figure><h1 id="docker-composeyml-에-volume-container-추가"><a class="markdownIt-Anchor" href="#docker-composeyml-에-volume-container-추가"></a> docker-compose.yml 에 volume container 추가</h1><p>위의 방식처럼 컨테이너를 직접 만들고 다른 컨테이너 실행 시 <code>--volumes-from</code> 속성으로 연결해주는 방법도 있지만, docker-compose를 사용 시 좀 더 간단한 방법을 제공해준다<br>아래처럼 작성하면 된다</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">    test_database:</span></span><br><span class="line"><span class="attr">        image:</span> <span class="attr">mysql:5.7</span></span><br><span class="line"><span class="attr">        environment:</span></span><br><span class="line"><span class="attr">          MYSQL_DATABASE:</span> <span class="string">test_db</span></span><br><span class="line"><span class="attr">          MYSQL_ROOT_PASSWORD:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">          MYSQL_ROOT_HOST:</span> <span class="string">'%'</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="bullet">          -</span> <span class="number">3306</span><span class="string">:3306</span></span><br><span class="line"><span class="attr">        volumes:</span></span><br><span class="line"><span class="attr">          - test_volume:</span><span class="string">/var/lib/mysql</span></span><br><span class="line"></span><br><span class="line"><span class="attr">    test_application:</span></span><br><span class="line"><span class="attr">        build:</span> <span class="string">.</span></span><br><span class="line"><span class="attr">        expose:</span></span><br><span class="line"><span class="bullet">          -</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">        depends_on:</span></span><br><span class="line"><span class="bullet">          -</span> <span class="string">test_database</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="attr">    test_volume:</span></span><br></pre></td></tr></table></figure><p>보다시피 <code>test_volume</code> 이라는 볼륨을 생성하고, 사용하는 쪽에서 <code>${volume_name}:${mount를 원하는 디렉토리}</code> 의 형태로 지정해주면 된다<br>docker-compose 설정파일 v2 의 형태로 보면 좀 더 직관적으로 이해가 갈 것이다</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"2"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">    test_database:</span></span><br><span class="line"><span class="attr">        image:</span> <span class="attr">mysql:5.7</span></span><br><span class="line"><span class="attr">        environment:</span></span><br><span class="line"><span class="attr">          MYSQL_DATABASE:</span> <span class="string">test_db</span></span><br><span class="line"><span class="attr">          MYSQL_ROOT_PASSWORD:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">          MYSQL_ROOT_HOST:</span> <span class="string">'%'</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="bullet">          -</span> <span class="number">3306</span><span class="string">:3306</span></span><br><span class="line"><span class="attr">        volumes:</span></span><br><span class="line"><span class="bullet">          -</span> <span class="string">test_volume</span></span><br><span class="line"></span><br><span class="line"><span class="attr">    test_application:</span></span><br><span class="line"><span class="attr">        build:</span> <span class="string">.</span></span><br><span class="line"><span class="attr">        expose:</span></span><br><span class="line"><span class="bullet">          -</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">        depends_on:</span></span><br><span class="line"><span class="bullet">          -</span> <span class="string">test_database</span></span><br><span class="line"></span><br><span class="line"><span class="attr">    test_volume:</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">busybox</span></span><br><span class="line"><span class="attr">        volumes:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">/var/lib/mysql</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">/var/log</span></span><br></pre></td></tr></table></figure><p>v3의 경우 컨테이너를 따로 생성하지 않아도 된다는 장점이 있다</p><p>볼륨 컨테이너는 충분히 좋은 기능이지만, 그래도 범위가 같은 도커 호스트 안이라는 사실은 변하지 않는다<br>이렇듯 데이터 이식 면에서는 아직 개선할 부분이 많이 남아있다</p><p>참고 :</p><ul><li><a href="https://darkrasid.github.io/docker/container/volume/2017/05/10/docker-volumes.html" rel="external nofollow noopener noreferrer" target="_blank">https://darkrasid.github.io/docker/container/volume/2017/05/10/docker-volumes.html</a></li><li><a href="https://stackoverflow.com/questions/45494746/docker-compose-volumes-from-usage-example" rel="external nofollow noopener noreferrer" target="_blank">https://stackoverflow.com/questions/45494746/docker-compose-volumes-from-usage-example</a></li></ul><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;volume-container란&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#volume-container란&quot;&gt;&lt;/a&gt; volume container란?&lt;/h1&gt;
&lt;p&gt;일반적으로 docker container는 컨테이너 내부에 데이터를 관리하므로, 컨테이너가 파기되면 데이터가 모두 날라가게 된다&lt;br&gt;
이는 mysql 같은 데이터 스토리지를 사용할 경우 위험하게 되는데, 이를 방지하기 위해 따로 볼륨을 설정해서 데이터를 저장해줘야 한다&lt;br&gt;
호스트OS 디렉토리를 마운트시켜서 데이터를 관리할 수도 있지만, 호스트쪽 디렉토리에 의존이 생기고 만약 이 디렉토리의 데이터를 잘못 손대면 애플리케이션에 부정적 영향을 미칠 수 있기 때문에 이 방식은 사용하지 않는것이 좋다&lt;/p&gt;
&lt;p&gt;그래서 이에 대한 대안으로 추천되는것이 &lt;code&gt;볼륨 컨테이너&lt;/code&gt;이다&lt;br&gt;
볼륨 컨테이너는 말 그대로 데이터를 저장하는 것이 목적인 컨테이너이다&lt;br&gt;
기본적으로 우리는 &lt;code&gt;Dockerfile&lt;/code&gt; 작성 시 아래와 같이 볼륨을 설정할 수 있다&lt;/p&gt;
&lt;figure class=&quot;highlight dockerfile&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;FROM&lt;/span&gt; mysql&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;VOLUME&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; /var/lib/mysql&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bash&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bash&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# ...&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;위처럼 작성하게 되면 컨테이너 내의 &lt;code&gt;/var/lib/mysql&lt;/code&gt; 디렉터리가 호스트 PC의 &lt;code&gt;/var/lib/docker/volumes/${volume_name}/_data&lt;/code&gt;에 마운트 된다&lt;br&gt;
(볼륨 이름은 임의의 해쉬값으로 생성된다)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;참고로 mac이나 windows의 경우 &lt;code&gt;/var/lib/docker/volumes&lt;/code&gt; 디렉토리가 없는데,&lt;br&gt;
이는 mac이나 windows의 경우 docker를 바로 실행할 수 없으므로 VM을 하나 띄운 뒤, docker를 실행하기 때문이다&lt;br&gt;
즉, &lt;code&gt;/var/lib/docker/volumes&lt;/code&gt; 디렉토리는 mac과 docker 사이에 띄워진 VM 내에 감춰져있다&lt;br&gt;
참고 : &lt;a href=&quot;https://forums.docker.com/t/var-lib-docker-does-not-exist-on-host/18314&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;https://forums.docker.com/t/var-lib-docker-does-not-exist-on-host/18314&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;volume container는 볼륨의 이러한 특징을 사용한 것이다&lt;br&gt;
컨테이너 자체를 볼륨을 관리하는 애로 만들어서 캡슐화하고, 이를 다른 컨테이너의 볼륨에 매핑해서 결합을 느슨하게 하는 것이다&lt;/p&gt;
&lt;p&gt;만약 아래와 같은 볼륨 컨테이너를 작성하고,&lt;/p&gt;
&lt;figure class=&quot;highlight dockerfile&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;FROM&lt;/span&gt; busybox &lt;span class=&quot;comment&quot;&gt;# 최소한의 운영체제 기능만 제공&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;VOLUME&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; /var/lib/mysql&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bash&quot;&gt;VOLUME /var/&lt;span class=&quot;built_in&quot;&gt;log&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;/var/lib/mysql&lt;/code&gt;, &lt;code&gt;/var/log&lt;/code&gt; 디렉토리에 대한 볼륨 2개가 생성되어 각각 &lt;code&gt;/var/lib/docker/volumes/${volume_name}/_data&lt;/code&gt; 에 마운트 된다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;빌드하고 컨테이너로 띄운 뒤,&lt;/p&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ docker image build -t volume_container:latest .&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ docker container run -d volume_container:latest&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;참고로 볼륨 컨테이너를 띄우면 바로 종료되는데, 이렇게 종료된 컨테이너를 사용해도 상관없다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;--volumes-from&lt;/code&gt; 옵션으로 다른 컨테이너에 연결한다면&lt;/p&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ docker container run --volumes-from volume_container mysql:5.7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;아래와 같은 형태가 되는 것이다&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;mysql container -&amp;gt; volume_container -&amp;gt; /var/lib/docker/volumes/$&amp;#123;/var/lib/mysql&amp;apos;s volume_name&amp;#125;/_data&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                    -&amp;gt; /var/lib/docker/volumes/$&amp;#123;/var/log&amp;apos;s volume_name&amp;#125;/_data&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;docker-composeyml-에-volume-container-추가&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#docker-composeyml-에-volume-container-추가&quot;&gt;&lt;/a&gt; docker-compose.yml 에 volume container 추가&lt;/h1&gt;
&lt;p&gt;위의 방식처럼 컨테이너를 직접 만들고 다른 컨테이너 실행 시 &lt;code&gt;--volumes-from&lt;/code&gt; 속성으로 연결해주는 방법도 있지만, docker-compose를 사용 시 좀 더 간단한 방법을 제공해준다&lt;br&gt;
아래처럼 작성하면 된다&lt;/p&gt;
&lt;figure class=&quot;highlight yml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;version:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;3&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;services:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;    test_database:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;        image:&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;mysql:5.7&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;        environment:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;          MYSQL_DATABASE:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;test_db&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;          MYSQL_ROOT_PASSWORD:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;root&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;          MYSQL_ROOT_HOST:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;%&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;        ports:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;          -&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;3306&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;:3306&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;        volumes:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;          - test_volume:&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;/var/lib/mysql&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;    test_application:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;        build:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;        expose:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;          -&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;8080&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;        depends_on:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;          -&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;test_database&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;volumes:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;    test_volume:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;보다시피 &lt;code&gt;test_volume&lt;/code&gt; 이라는 볼륨을 생성하고, 사용하는 쪽에서 &lt;code&gt;${volume_name}:${mount를 원하는 디렉토리}&lt;/code&gt; 의 형태로 지정해주면 된다&lt;br&gt;
docker-compose 설정파일 v2 의 형태로 보면 좀 더 직관적으로 이해가 갈 것이다&lt;/p&gt;
&lt;figure class=&quot;highlight yml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;version:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;2&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;services:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;    test_database:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;        image:&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;mysql:5.7&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;        environment:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;          MYSQL_DATABASE:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;test_db&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;          MYSQL_ROOT_PASSWORD:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;root&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;          MYSQL_ROOT_HOST:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;%&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;        ports:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;          -&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;3306&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;:3306&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;        volumes:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;          -&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;test_volume&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;    test_application:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;        build:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;        expose:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;          -&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;8080&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;        depends_on:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;          -&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;test_database&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;    test_volume:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;        image:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;busybox&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;        volumes:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;            -&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;/var/lib/mysql&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;            -&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;/var/log&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;v3의 경우 컨테이너를 따로 생성하지 않아도 된다는 장점이 있다&lt;/p&gt;
&lt;p&gt;볼륨 컨테이너는 충분히 좋은 기능이지만, 그래도 범위가 같은 도커 호스트 안이라는 사실은 변하지 않는다&lt;br&gt;
이렇듯 데이터 이식 면에서는 아직 개선할 부분이 많이 남아있다&lt;/p&gt;
&lt;p&gt;참고 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://darkrasid.github.io/docker/container/volume/2017/05/10/docker-volumes.html&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;https://darkrasid.github.io/docker/container/volume/2017/05/10/docker-volumes.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/45494746/docker-compose-volumes-from-usage-example&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;https://stackoverflow.com/questions/45494746/docker-compose-volumes-from-usage-example&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="docker" scheme="https://joont92.github.io/categories/docker/"/>
    
    
      <category term="docker" scheme="https://joont92.github.io/tags/docker/"/>
    
      <category term="도커/쿠버네티스를 활용한 컨테이너 개발 실전 입문" scheme="https://joont92.github.io/tags/%EB%8F%84%EC%BB%A4-%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EA%B0%9C%EB%B0%9C-%EC%8B%A4%EC%A0%84-%EC%9E%85%EB%AC%B8/"/>
    
      <category term="volume container" scheme="https://joont92.github.io/tags/volume-container/"/>
    
  </entry>
  
  <entry>
    <title>[docker] docker-compose로 nginx + spring-boot + mysql 구성하기</title>
    <link href="https://joont92.github.io/docker/docker-compose%EB%A1%9C-nginx-spring-boot-mysql-%EA%B5%AC%EC%84%B1%ED%95%98%EA%B8%B0/"/>
    <id>https://joont92.github.io/docker/docker-compose로-nginx-spring-boot-mysql-구성하기/</id>
    <published>2019-06-16T11:10:49.000Z</published>
    <updated>2020-11-02T10:09:30.453Z</updated>
    
    <content type="html"><![CDATA[<p>알다시피 일반적으로 시스템은 단일 어플리케이션 만으로 구성되지 않는다<br>다른 어플리케이션 서버나 미들웨어 등과 서로 통신하며 하나의 시스템이 구성된다<br>이번에는 가장 일반적인 구조인 <code>리버스 프록시(nginx) + 어플리케이션 서버(spring-boot) + 데이터 스토어(mysql)</code> 를 구성해보겠다</p><p>각각의 구성요소는 서로 의존관계가 있다<br>서로 통신할 수 있어야하고 각 구성요소가 올라오는 순서도 맞춰줘야 한다<br>물론 도커로 다 설정할 수 있긴하지만, 사람이 매번 수작업으로 맞춰줘야 하기 때문에 번거롭고 실수하기도 쉽다<br>그래서 이런 컨테이너의 실행을 한번에 관리할 수 있게 해주는 <code>docker-compose</code>를 사용할 것이다</p><h1 id="사전-구성"><a class="markdownIt-Anchor" href="#사전-구성"></a> 사전 구성</h1><p>spring boot로 간단히 사용자를 저장하고, 조회하는 로직을 작성한다</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TestController.java</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/users"</span>)</span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;Void&gt; <span class="title">createUser</span><span class="params">(@RequestBody UserRequest request)</span> </span>&#123;</span><br><span class="line">        User user = userRepository.save(request.toEntity());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.created(URI.create(<span class="string">"/users/"</span> + user.getId())).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;List&lt;User&gt;&gt; getUsers() &#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(</span><br><span class="line">            userRepository.findAll()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;User&gt; <span class="title">getUser</span><span class="params">(@PathVariable Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(</span><br><span class="line">            userRepository.findById(id)</span><br><span class="line">                .orElseThrow(IllegalStateException::<span class="keyword">new</span>)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserRequest.java</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRequest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">toEntity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(name, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// User.java</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span>(access = AccessLevel.PROTECTED)</span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"id"</span>)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"name"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"age"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserRepository.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>보다시피 user 를 조회하고 저장하는 기능을 가진 간단한 API 서버이다</p><p>이를 도커 컨테이너로 띄우기 위해 <code>Dockerfile</code>을 작성한다</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">8</span>-jdk</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./<span class="built_in">test</span>-application /<span class="built_in">test</span>-application</span></span><br><span class="line"><span class="bash">WORKDIR /<span class="built_in">test</span>-application</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">CMD [<span class="string">"./gradlew"</span>, <span class="string">"bootRun"</span>]</span></span><br></pre></td></tr></table></figure><p><code>test-application</code>은 spring-boot 어플리케이션이 있는 디렉토리이다<br>간단하게 spring-boot 어플리케이션이 있는 디렉토리 전체를 컨테이너로 복사한 뒤, <code>./gradlew bootRun</code>으로 어플리케이션을 실행시킨다</p><h1 id="spring-boot-mysql-띄우기feat-docker-composeyml"><a class="markdownIt-Anchor" href="#spring-boot-mysql-띄우기feat-docker-composeyml"></a> spring-boot, mysql 띄우기(feat. docker-compose.yml)</h1><p>이제 위 파일을 docker image로 만들어주면 되는데, 알다시피 저 <code>Dockerfile</code>을 사용해 docker image를 만들어봐야 사용하지 못한다<br>db가 없기 때문이다<br>mysql을 docker container 로 띄운 뒤 spring-boot 를 docker container로 띄우면 되긴 하지만, 번거로우므로 이를 같이 해줄 수 있는 <code>docker-compose</code> 설정 파일을 작성한다</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">    test_database:</span></span><br><span class="line">        <span class="comment"># 컨테이너 이름을 주고 싶다면 작성한다</span></span><br><span class="line">        <span class="comment"># container_name: test_database</span></span><br><span class="line"><span class="attr">        image:</span> <span class="attr">mysql:5.7</span></span><br><span class="line"><span class="attr">        environment:</span></span><br><span class="line"><span class="attr">          MYSQL_DATABASE:</span> <span class="string">test_db</span></span><br><span class="line"><span class="attr">          MYSQL_ROOT_PASSWORD:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">          MYSQL_ROOT_HOST:</span> <span class="string">'%'</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="bullet">          -</span> <span class="number">3306</span><span class="string">:3306</span>        </span><br><span class="line"></span><br><span class="line"><span class="attr">    test_application:</span></span><br><span class="line"><span class="attr">        build:</span> <span class="string">.</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="bullet">          -</span> <span class="number">8080</span><span class="string">:8080</span></span><br><span class="line"><span class="attr">        depends_on:</span></span><br><span class="line"><span class="bullet">          -</span> <span class="string">test_database</span></span><br></pre></td></tr></table></figure><p>mysql과 spring-boot 컨테이너 2개를 띄워주는 <code>docker-compose.yml</code> 파일이다<br>mysql의 경우 이미지명을 지정해 레지스트리에서 땡겨오도록 했고, spring-boot의 경우 현 위치에 있는 <code>Dockerfile</code>을 참조하여 만든 image를 컨테이너로 띄우게끔 했다<br>(<code>docker-compose.yml</code>과 spring-boot <code>Dockerfile</code>은 같은 위치에 있다)<br>여기서 중요한 것은 <code>depends_on</code> 속성인데, 이렇게 해놓으면 mysql 컨테이너가 다 뜬 다음 spring-boot 컨테이너가 뜨게끔 설정된다</p><p>이제 spring-boot에서 mysql을 바라볼 수 있도록 <code>application.properties</code>에 접속 정보를 작성한다</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.url=jdbc:mysql://test_database:3306/test_db?useSSL=false</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=root</span><br><span class="line">spring.datasource.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line"></span><br><span class="line">spring.jpa.hibernate.ddl-auto=update</span><br><span class="line">spring.jpa.database-platform=org.hibernate.dialect.MySQL5Dialect</span><br><span class="line">spring.jpa.generate-ddl=true</span><br><span class="line">spring.jpa.show-sql=true</span><br></pre></td></tr></table></figure><p>여기서 특별한 부분은 datasource url로 ip 대신 <code>test_database</code> 라고 준 부분이다<br>이는 <code>docker-compose.yml</code>에 써놓은 mysql의 서비스명과 동일한데,<br>이는 <code>docker-compose.yml</code> 내에 작성한 컨테이너들은 모두 같은 네트워크 대역으로 묶어서 생성하기 때문이다</p><blockquote><p>compose 단위로 새로운 네트워크 대역으로 생성한다<br>그냥 단일 도커들만 실행하면 기본 네트워크 대역에 할당된다</p><blockquote><p>compose 없이 컨테이너 각각 띄워보고 들어가서 ip 확인해보면 대역대가 같다<br>하지만 compose 로 생성한 컨테이너는 대역대가 다르다</p></blockquote></blockquote><p>이제 작성이 끝났으니, docker-compose 로 컨테이너들을 실행시켜보자</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose up</span><br></pre></td></tr></table></figure><blockquote><p>docker-compose는 기본적으로 명령을 실행한 위치에 있는 <code>docker-compose.yml</code> 파일을 참조하여 실행한다<br>만약 다른 경로에 있거나 다른 파일명을 사용하고 싶을 경우 <code>-f</code> 옵션으로 docker-compose 파일을 지정해주면 된다</p></blockquote><p>mysql과 spring-boot가 차례대로 실행되는것을 볼 수 있다</p><blockquote><p><code>-d</code> 옵션을 주면 백그라운드로 실행시킬 수 있다</p></blockquote><p>postman으로 <code>localhost:8080</code>으로 API를 호출해보면, 잘 동작함을 볼 수 있다</p><h1 id="nginx-추가"><a class="markdownIt-Anchor" href="#nginx-추가"></a> nginx 추가</h1><p>이제 리버스 프록시인 nginx를 추가해보자<br><code>docker-compose.yml</code> 파일을 수정한다</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">    test_web:</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="bullet">          -</span> <span class="number">80</span><span class="string">:80</span></span><br><span class="line"><span class="attr">        volumes:</span></span><br><span class="line"><span class="bullet">          -</span> <span class="string">./nginx/conf.d:/etc/nginx/conf.d</span></span><br><span class="line"><span class="attr">        depends_on:</span></span><br><span class="line"><span class="bullet">          -</span> <span class="string">test_application</span></span><br><span class="line"></span><br><span class="line"><span class="attr">    test_database:</span></span><br><span class="line"><span class="attr">        image:</span> <span class="attr">mysql:5.7</span></span><br><span class="line"><span class="attr">        environment:</span></span><br><span class="line"><span class="attr">          MYSQL_DATABASE:</span> <span class="string">test_db</span></span><br><span class="line"><span class="attr">          MYSQL_ROOT_PASSWORD:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">          MYSQL_ROOT_HOST:</span> <span class="string">'%'</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="bullet">          -</span> <span class="number">3306</span><span class="string">:3306</span></span><br><span class="line"></span><br><span class="line"><span class="attr">    test_application:</span></span><br><span class="line"><span class="attr">        build:</span> <span class="string">.</span></span><br><span class="line"><span class="attr">        expose:</span></span><br><span class="line"><span class="bullet">          -</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">        depends_on:</span></span><br><span class="line"><span class="bullet">          -</span> <span class="string">test_database</span></span><br></pre></td></tr></table></figure><p>spring-boot 컨테이너가 뜬 다음에 레지스트리에서 nginx를 땡겨와서 컨테이너로 띄우게끔 했다<br>nginx 를 작성한 부분에 <code>volumes</code> 라는 부분이 보이는데, 이는 호스트의 <code>nginx/conf.d</code> 폴더를 컨테이너의 <code>/etc/nginx/conf.d</code> 폴더로 마운트 해주겠다는 의미이다<br>이렇게 작성한 이유는 호스트쪽에 작성해놓은 nginx 설정 파일을 nginx 컨테이너가 뜨면서 읽게하기 위함이다</p><blockquote><p>nginx는 <code>/etc/nginx/conf.d</code> 내에 들어있는 모든 <code>.conf</code> 파일을 include 한다</p></blockquote><p>아래는 conf.d 안에 작성한 <code>app.conf</code> 파일이다</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    access_log off;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://test_application:8080;</span><br><span class="line">    proxy_set_header Host $host:$server_port;</span><br><span class="line">        proxy_set_header X-Forwarded-Host $server_name;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>이제 작성이 끝났으니, <code>docker-compose</code>를 down 했다가 다시 up 한다<br>앞에 리버스 프록시를 두었으니 url <code>localhost</code>로 변경했을때 잘 작동함을 볼 수 있다</p><blockquote><p>참고로 <code>test_application</code>에 대한 포트포워딩 설정이었던 <code>ports</code>가 <code>expose</code>로 바뀌었는데, 이는 컨테이너 내부에서만 해당 포트를 인식하게끔 하는 속성이다<br>즉, 다른 컨테이너에서는 8080으로 통신이 가능하지만, 외부에서는 8080으로 더이상 접근할 수 없다</p></blockquote><p>github url : <a href="https://github.com/joont92/docker-study/tree/master/step02" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/joont92/docker-study/tree/master/step02</a></p><p>참고 :</p><ul><li><a href="https://github.com/hellokoding/hellokoding-courses/blob/master/docker-examples/dockercompose-springboot-mysql-nginx/docker-compose.yaml" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/hellokoding/hellokoding-courses/blob/master/docker-examples/dockercompose-springboot-mysql-nginx/docker-compose.yaml</a></li></ul><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;알다시피 일반적으로 시스템은 단일 어플리케이션 만으로 구성되지 않는다&lt;br&gt;
다른 어플리케이션 서버나 미들웨어 등과 서로 통신하며 하나의 시스템이 구성된다&lt;br&gt;
이번에는 가장 일반적인 구조인 &lt;code&gt;리버스 프록시(nginx) + 어플리케이션 서버(spring-boot) + 데이터 스토어(mysql)&lt;/code&gt; 를 구성해보겠다&lt;/p&gt;
&lt;p&gt;각각의 구성요소는 서로 의존관계가 있다&lt;br&gt;
서로 통신할 수 있어야하고 각 구성요소가 올라오는 순서도 맞춰줘야 한다&lt;br&gt;
물론 도커로 다 설정할 수 있긴하지만, 사람이 매번 수작업으로 맞춰줘야 하기 때문에 번거롭고 실수하기도 쉽다&lt;br&gt;
그래서 이런 컨테이너의 실행을 한번에 관리할 수 있게 해주는 &lt;code&gt;docker-compose&lt;/code&gt;를 사용할 것이다&lt;/p&gt;
&lt;h1 id=&quot;사전-구성&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#사전-구성&quot;&gt;&lt;/a&gt; 사전 구성&lt;/h1&gt;
&lt;p&gt;spring boot로 간단히 사용자를 저장하고, 조회하는 로직을 작성한다&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// TestController.java&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@RequiredArgsConstructor&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@RequestMapping&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;/users&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Controller&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TestController&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; UserRepository userRepository;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@PostMapping&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; ResponseEntity&amp;lt;Void&amp;gt; &lt;span class=&quot;title&quot;&gt;createUser&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(@RequestBody UserRequest request)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        User user = userRepository.save(request.toEntity());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ResponseEntity.created(URI.create(&lt;span class=&quot;string&quot;&gt;&quot;/users/&quot;&lt;/span&gt; + user.getId())).build();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@GetMapping&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; ResponseEntity&amp;lt;List&amp;lt;User&amp;gt;&amp;gt; getUsers() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ResponseEntity.ok(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            userRepository.findAll()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@GetMapping&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;/&amp;#123;id&amp;#125;&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; ResponseEntity&amp;lt;User&amp;gt; &lt;span class=&quot;title&quot;&gt;getUser&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(@PathVariable Long id)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ResponseEntity.ok(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            userRepository.findById(id)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                .orElseThrow(IllegalStateException::&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// UserRequest.java&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Getter&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Setter&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;UserRequest&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; String name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; Integer age;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; User &lt;span class=&quot;title&quot;&gt;toEntity&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; User(name, age);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// User.java&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@NoArgsConstructor&lt;/span&gt;(access = AccessLevel.PROTECTED)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Entity&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Table&lt;/span&gt;(name = &lt;span class=&quot;string&quot;&gt;&quot;user&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;User&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Getter&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Id&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@GeneratedValue&lt;/span&gt;(strategy = GenerationType.IDENTITY)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Column&lt;/span&gt;(name = &lt;span class=&quot;string&quot;&gt;&quot;id&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; Long id;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Getter&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Column&lt;/span&gt;(name = &lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; String name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Getter&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Column&lt;/span&gt;(name = &lt;span class=&quot;string&quot;&gt;&quot;age&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; Integer age;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String name, Integer age)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name = name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.age = age;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// UserRepository.java&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;UserRepository&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;JpaRepository&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;User&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;Long&lt;/span&gt;&amp;gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;보다시피 user 를 조회하고 저장하는 기능을 가진 간단한 API 서버이다&lt;/p&gt;
&lt;p&gt;이를 도커 컨테이너로 띄우기 위해 &lt;code&gt;Dockerfile&lt;/code&gt;을 작성한다&lt;/p&gt;
&lt;figure class=&quot;highlight dockerfile&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;FROM&lt;/span&gt; openjdk:&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;-jdk&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;COPY&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; ./&lt;span class=&quot;built_in&quot;&gt;test&lt;/span&gt;-application /&lt;span class=&quot;built_in&quot;&gt;test&lt;/span&gt;-application&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bash&quot;&gt;WORKDIR /&lt;span class=&quot;built_in&quot;&gt;test&lt;/span&gt;-application&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bash&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bash&quot;&gt;CMD [&lt;span class=&quot;string&quot;&gt;&quot;./gradlew&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;bootRun&quot;&lt;/span&gt;]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;test-application&lt;/code&gt;은 spring-boot 어플리케이션이 있는 디렉토리이다&lt;br&gt;
간단하게 spring-boot 어플리케이션이 있는 디렉토리 전체를 컨테이너로 복사한 뒤, &lt;code&gt;./gradlew bootRun&lt;/code&gt;으로 어플리케이션을 실행시킨다&lt;/p&gt;
&lt;h1 id=&quot;spring-boot-mysql-띄우기feat-docker-composeyml&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#spring-boot-mysql-띄우기feat-docker-composeyml&quot;&gt;&lt;/a&gt; spring-boot, mysql 띄우기(feat. docker-compose.yml)&lt;/h1&gt;
&lt;p&gt;이제 위 파일을 docker image로 만들어주면 되는데, 알다시피 저 &lt;code&gt;Dockerfile&lt;/code&gt;을 사용해 docker image를 만들어봐야 사용하지 못한다&lt;br&gt;
db가 없기 때문이다&lt;br&gt;
mysql을 docker container 로 띄운 뒤 spring-boot 를 docker container로 띄우면 되긴 하지만, 번거로우므로 이를 같이 해줄 수 있는 &lt;code&gt;docker-compose&lt;/code&gt; 설정 파일을 작성한다&lt;/p&gt;
&lt;figure class=&quot;highlight yml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;version:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;3&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;services:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;    test_database:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;# 컨테이너 이름을 주고 싶다면 작성한다&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;# container_name: test_database&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;        image:&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;mysql:5.7&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;        environment:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;          MYSQL_DATABASE:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;test_db&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;          MYSQL_ROOT_PASSWORD:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;root&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;          MYSQL_ROOT_HOST:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;%&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;        ports:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;          -&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;3306&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;:3306&lt;/span&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;    test_application:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;        build:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;        ports:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;          -&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;8080&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;:8080&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;        depends_on:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;          -&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;test_database&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;mysql과 spring-boot 컨테이너 2개를 띄워주는 &lt;code&gt;docker-compose.yml&lt;/code&gt; 파일이다&lt;br&gt;
mysql의 경우 이미지명을 지정해 레지스트리에서 땡겨오도록 했고, spring-boot의 경우 현 위치에 있는 &lt;code&gt;Dockerfile&lt;/code&gt;을 참조하여 만든 image를 컨테이너로 띄우게끔 했다&lt;br&gt;
(&lt;code&gt;docker-compose.yml&lt;/code&gt;과 spring-boot &lt;code&gt;Dockerfile&lt;/code&gt;은 같은 위치에 있다)&lt;br&gt;
여기서 중요한 것은 &lt;code&gt;depends_on&lt;/code&gt; 속성인데, 이렇게 해놓으면 mysql 컨테이너가 다 뜬 다음 spring-boot 컨테이너가 뜨게끔 설정된다&lt;/p&gt;
&lt;p&gt;이제 spring-boot에서 mysql을 바라볼 수 있도록 &lt;code&gt;application.properties&lt;/code&gt;에 접속 정보를 작성한다&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;spring.datasource.url=jdbc:mysql://test_database:3306/test_db?useSSL=false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;spring.datasource.username=root&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;spring.datasource.password=root&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;spring.datasource.driver-class-name=com.mysql.jdbc.Driver&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;spring.jpa.hibernate.ddl-auto=update&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;spring.jpa.database-platform=org.hibernate.dialect.MySQL5Dialect&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;spring.jpa.generate-ddl=true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;spring.jpa.show-sql=true&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;여기서 특별한 부분은 datasource url로 ip 대신 &lt;code&gt;test_database&lt;/code&gt; 라고 준 부분이다&lt;br&gt;
이는 &lt;code&gt;docker-compose.yml&lt;/code&gt;에 써놓은 mysql의 서비스명과 동일한데,&lt;br&gt;
이는 &lt;code&gt;docker-compose.yml&lt;/code&gt; 내에 작성한 컨테이너들은 모두 같은 네트워크 대역으로 묶어서 생성하기 때문이다&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;compose 단위로 새로운 네트워크 대역으로 생성한다&lt;br&gt;
그냥 단일 도커들만 실행하면 기본 네트워크 대역에 할당된다&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;compose 없이 컨테이너 각각 띄워보고 들어가서 ip 확인해보면 대역대가 같다&lt;br&gt;
하지만 compose 로 생성한 컨테이너는 대역대가 다르다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;이제 작성이 끝났으니, docker-compose 로 컨테이너들을 실행시켜보자&lt;/p&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ docker-compose up&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;docker-compose는 기본적으로 명령을 실행한 위치에 있는 &lt;code&gt;docker-compose.yml&lt;/code&gt; 파일을 참조하여 실행한다&lt;br&gt;
만약 다른 경로에 있거나 다른 파일명을 사용하고 싶을 경우 &lt;code&gt;-f&lt;/code&gt; 옵션으로 docker-compose 파일을 지정해주면 된다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;mysql과 spring-boot가 차례대로 실행되는것을 볼 수 있다&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;-d&lt;/code&gt; 옵션을 주면 백그라운드로 실행시킬 수 있다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;postman으로 &lt;code&gt;localhost:8080&lt;/code&gt;으로 API를 호출해보면, 잘 동작함을 볼 수 있다&lt;/p&gt;
&lt;h1 id=&quot;nginx-추가&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#nginx-추가&quot;&gt;&lt;/a&gt; nginx 추가&lt;/h1&gt;
&lt;p&gt;이제 리버스 프록시인 nginx를 추가해보자&lt;br&gt;
&lt;code&gt;docker-compose.yml&lt;/code&gt; 파일을 수정한다&lt;/p&gt;
&lt;figure class=&quot;highlight yml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;version:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;3&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;services:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;    test_web:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;        image:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;nginx&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;        ports:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;          -&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;80&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;:80&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;        volumes:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;          -&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;./nginx/conf.d:/etc/nginx/conf.d&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;        depends_on:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;          -&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;test_application&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;    test_database:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;        image:&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;mysql:5.7&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;        environment:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;          MYSQL_DATABASE:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;test_db&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;          MYSQL_ROOT_PASSWORD:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;root&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;          MYSQL_ROOT_HOST:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;%&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;        ports:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;          -&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;3306&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;:3306&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;    test_application:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;        build:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;        expose:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;          -&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;8080&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;        depends_on:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;          -&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;test_database&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;spring-boot 컨테이너가 뜬 다음에 레지스트리에서 nginx를 땡겨와서 컨테이너로 띄우게끔 했다&lt;br&gt;
nginx 를 작성한 부분에 &lt;code&gt;volumes&lt;/code&gt; 라는 부분이 보이는데, 이는 호스트의 &lt;code&gt;nginx/conf.d&lt;/code&gt; 폴더를 컨테이너의 &lt;code&gt;/etc/nginx/conf.d&lt;/code&gt; 폴더로 마운트 해주겠다는 의미이다&lt;br&gt;
이렇게 작성한 이유는 호스트쪽에 작성해놓은 nginx 설정 파일을 nginx 컨테이너가 뜨면서 읽게하기 위함이다&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;nginx는 &lt;code&gt;/etc/nginx/conf.d&lt;/code&gt; 내에 들어있는 모든 &lt;code&gt;.conf&lt;/code&gt; 파일을 include 한다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;아래는 conf.d 안에 작성한 &lt;code&gt;app.conf&lt;/code&gt; 파일이다&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;server &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    listen 80;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    access_log off;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    location / &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        proxy_pass http://test_application:8080;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	    proxy_set_header Host $host:$server_port;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        proxy_set_header X-Forwarded-Host $server_name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        proxy_set_header X-Real-IP $remote_addr;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;이제 작성이 끝났으니, &lt;code&gt;docker-compose&lt;/code&gt;를 down 했다가 다시 up 한다&lt;br&gt;
앞에 리버스 프록시를 두었으니 url &lt;code&gt;localhost&lt;/code&gt;로 변경했을때 잘 작동함을 볼 수 있다&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;참고로 &lt;code&gt;test_application&lt;/code&gt;에 대한 포트포워딩 설정이었던 &lt;code&gt;ports&lt;/code&gt;가 &lt;code&gt;expose&lt;/code&gt;로 바뀌었는데, 이는 컨테이너 내부에서만 해당 포트를 인식하게끔 하는 속성이다&lt;br&gt;
즉, 다른 컨테이너에서는 8080으로 통신이 가능하지만, 외부에서는 8080으로 더이상 접근할 수 없다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;github url : &lt;a href=&quot;https://github.com/joont92/docker-study/tree/master/step02&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;https://github.com/joont92/docker-study/tree/master/step02&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;참고 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/hellokoding/hellokoding-courses/blob/master/docker-examples/dockercompose-springboot-mysql-nginx/docker-compose.yaml&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;https://github.com/hellokoding/hellokoding-courses/blob/master/docker-examples/dockercompose-springboot-mysql-nginx/docker-compose.yaml&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="docker" scheme="https://joont92.github.io/categories/docker/"/>
    
    
      <category term="mysql" scheme="https://joont92.github.io/tags/mysql/"/>
    
      <category term="docker-compose" scheme="https://joont92.github.io/tags/docker-compose/"/>
    
      <category term="docker" scheme="https://joont92.github.io/tags/docker/"/>
    
      <category term="nginx" scheme="https://joont92.github.io/tags/nginx/"/>
    
      <category term="spring boot" scheme="https://joont92.github.io/tags/spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>[docker] container 다루기</title>
    <link href="https://joont92.github.io/docker/container-%EB%8B%A4%EB%A3%A8%EA%B8%B0/"/>
    <id>https://joont92.github.io/docker/container-다루기/</id>
    <published>2019-06-09T15:58:27.000Z</published>
    <updated>2020-11-02T10:09:30.453Z</updated>
    
    <content type="html"><![CDATA[<p>빌드한 도커 이미지를 실행시키면 도커 컨테이너가 된다<br>언급했듯이 도커 이미지는 하나의 템플릿이므로, 하나의 도커 이미지로 여러개의 도커 컨테이너를 만들 수 있다</p><h1 id="도커-컨테이너-생명주기"><a class="markdownIt-Anchor" href="#도커-컨테이너-생명주기"></a> 도커 컨테이너 생명주기</h1><p>도커 컨테이너는 도커 이미지를 <code>실행</code>시킨 것이기 때문에 상태를 가지고 있다</p><ul><li>실행 중<blockquote><p>ENTRYPOINT, CMD에 있는 어플리케이션이 실행된 상태를 말한다<br>명령행 도구 등의 컨테이너는 이 상태가 길게 유지되지 않는다</p></blockquote></li><li>정지<blockquote><p>실행 중 상태에 있는 컨테이너를 명시적으로 종료하거나, 컨테이너에서 실행된 어플리케이션이 정상/오류를 막론하고 종료된 경우의 상태를 말한다<br>정지되어도 그 상태 그대로 디스크에 남아있기 때문에(docker container ls 로 확인 가능) 다시 실행할 수 있다</p></blockquote></li><li>파기<blockquote><p>정지된 컨테이너를 명시적으로 삭제하면 파기 상태가 된다(docker container ls 로 확인 불가능)<br>파기된 컨테이너는 다시 정지된 컨테이너와 같은 상태로 돌아갈 수 없으므로 주의해서 실행해야 한다</p></blockquote></li></ul><hr><p>아래는 도커 컨테이너를 관리하면서 자주 사용하는 명령어들과 그에 대한 간단한 설명이다<br>추가적인 명령어나 옵션이 궁금하다면 <a href="https://docs.docker.com/engine/reference/commandline/container/" rel="external nofollow noopener noreferrer" target="_blank">https://docs.docker.com/engine/reference/commandline/container/</a> 를 참조한다</p><h1 id="docker-container-run"><a class="markdownIt-Anchor" href="#docker-container-run"></a> docker container run</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run [options] 이미지명[:태그명] [명령] [명령인자..]</span><br><span class="line">$ docker container run [options] 이미지ID [명령] [명령인자..]</span><br></pre></td></tr></table></figure><p>도커 이미지로부터 컨테이너를 생성+실행 하는 명령이다</p><p>유용한 옵션이 많으니 활용하면 좋다</p><ul><li><p>-d : 백그라운드로 실행</p></li><li><p>-p : 포트포워딩</p><blockquote><p><code>-p 9000:8080</code> == 호스트 포트 9000번을 컨테이너 포트 8080으로 포워딩</p></blockquote></li><li><p>–name : 컨테이너에 이름 부여</p><blockquote><p>매번 컨테이너ID를 조회하는 것이 번거로우므로 이름을 지정할 수 있다<br>컨테이너 이름은 중복될 수 없기 때문에 개발환경 외에는 잘 사용되지 않는다(운영은 많은수의 컨테이너를 추가/삭제 하므로)</p></blockquote></li><li><p>-i, -t : -i는 표준 입력을 받을지 여부이고(파이프라이닝, 키보드 입력), -t는 가상터미널을 제공할지 여부이다</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run -it ubuntu:16.04</span><br></pre></td></tr></table></figure><blockquote><p>보통 위처럼 -it를 같이 사용하고, 이러면 컨테이너에 쉘에 직접 접근할 수 있게 된다(가상 터미널로 표준 입력을 하는것이 되므로)</p><p>-t 없이 -i 만 사용해도 의미가 있다(파이프라이닝으로 입력하는 방법이 있으므로)<br>-i 없이 -t 만 사용하는건 의미가 없다(입력을 받지 못하는 상태라 가상터미널을 열어봐야)<br>-d와 -it를 같이 사용할 수 없다(백그라운드라 입력을 대기하거나 가상터미널을 제공하는것이 불가능하다)</p></blockquote></li><li><p>–rm : 컨테이너를 종료할 때 컨테이너를 파기하는 옵션</p><blockquote><p>같은 이름으로 컨테이너를 실행시킬 수 없기 때문에 이 옵션을 사용해주는것이 좋다<br>보통 <code>--name</code> 과 같이 사용한다</p></blockquote></li></ul><blockquote><p>컨테이너에 할당할 자원도 어느정도 제어할 수 있다 <a href="https://jungwoon.github.io/docker/2019/01/13/Docker-6/" rel="external nofollow noopener noreferrer" target="_blank">https://jungwoon.github.io/docker/2019/01/13/Docker-6/</a></p></blockquote><h1 id="docker-container-ls"><a class="markdownIt-Anchor" href="#docker-container-ls"></a> docker container ls</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls [options]</span><br></pre></td></tr></table></figure><p>컨테이너의 목록을 보여줌</p><ul><li><p>-a : 종료된 컨테이너의 목록도 같이 보여줌(원래는 실행 중인 컨테이너의 목록만 보여줌)</p></li><li><p>-q : 컨테이너 ID만 추출함</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container stop $(docker container ls -q)</span><br></pre></td></tr></table></figure><p>처럼 사용할 수 있음</p></li><li><p>–filter : 컨테이너 목록 필터링</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls --filter <span class="string">"name=container_name"</span> <span class="comment"># 컨테이너명</span></span><br><span class="line">$ docker container ls --filter <span class="string">"ancestor=image_name"</span> <span class="comment"># 이미지명</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="docker-container-stop"><a class="markdownIt-Anchor" href="#docker-container-stop"></a> docker container stop</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container stop 컨테이너ID_또는_컨테이너명</span><br></pre></td></tr></table></figure><p>실행중인 컨테이너를 종료할 떄 사용한다</p><h1 id="docker-container-restart"><a class="markdownIt-Anchor" href="#docker-container-restart"></a> docker container restart</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container restart 컨테이너ID_또는_컨테이너명</span><br></pre></td></tr></table></figure><p>정지한 컨테이너를 재시작할 때 사용한다</p><blockquote><p>start 와 차이가 뭘까?</p></blockquote><h1 id="docker-container-rm"><a class="markdownIt-Anchor" href="#docker-container-rm"></a> docker container rm</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container rm 컨테이너ID_또는_컨테이너명</span><br></pre></td></tr></table></figure><p>정지된 컨테이너를 완전히 파기할 떄 사용한다<br>실행중인 컨테이너를 강제로 삭제하고 싶다면 <code>-f</code> 옵션을 사용한다</p><h1 id="docker-container-logs"><a class="markdownIt-Anchor" href="#docker-container-logs"></a> docker container logs</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container logs [options] 컨테이너ID_또는_컨테이너명</span><br></pre></td></tr></table></figure><p>컨테이너의 표준 출력으로 출력된 내용을 보여준다<br><code>-f</code> 옵션을 주면 새로 출력되는 표준 출력을 계속 볼 수 있다</p><p>보통은 이 내용을 수집해 웹 브라우저나 명령행 도구를 통해 보여주므로 이 명령을 사용할 일은 많이 없다</p><h1 id="docker-container-exec"><a class="markdownIt-Anchor" href="#docker-container-exec"></a> docker container exec</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container <span class="built_in">exec</span> [options] 컨테이너ID_또는_컨테이너명 컨테이너에서_실행할_명령</span><br></pre></td></tr></table></figure><p>실행 중인 컨테이너에서 원하는 명령을 실행할 수 있다</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker container exec ubuntu_docker pwd</span><br><span class="line">$ docker container exec ubuntu_docker ls</span><br></pre></td></tr></table></figure><p>아예 컨테이너로 접속하고 싶다면 아래와 같이 입력하면 된다</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container exec -it ubuntu_docker sh</span><br></pre></td></tr></table></figure><h1 id="docker-container-cp"><a class="markdownIt-Anchor" href="#docker-container-cp"></a> docker container cp</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker container cp [options] 컨테이너ID_또는_컨테이너명:원본파일 호스트_대상파일</span><br><span class="line">$ docker container cp [options] 호스트_원본파일 컨테이너ID_또는_컨테이너명:대상파일</span><br></pre></td></tr></table></figure><p>실행중인 컨테이너에 파일을 복사하거나 복사해 올 때 사용한다</p><blockquote><p>Dockerfile의 CP는 이미지 빌드시에 호스트 -&gt; 컨테이너 방향으로의 복사만 가능하다</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container cp test_file ubuntu_docker:/tmp/test_file</span><br></pre></td></tr></table></figure><p>참고 :</p><ul><li><a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&amp;mallGb=KOR&amp;barcode=9791158391447&amp;orderClick=LEA&amp;Kc=" rel="external nofollow noopener noreferrer" target="_blank">야마다 아키노리, 『도커/쿠버네티스를 활용한 컨테이너 개발 실전 입문』, 심효섭 옮김, 위키북스(2019)</a></li></ul><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;빌드한 도커 이미지를 실행시키면 도커 컨테이너가 된다&lt;br&gt;
언급했듯이 도커 이미지는 하나의 템플릿이므로, 하나의 도커 이미지로 여러개의 도커 컨테이너를 만들 수 있다&lt;/p&gt;
&lt;h1 id=&quot;도커-컨테이너-생명주기&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#도커-컨테이너-생명주기&quot;&gt;&lt;/a&gt; 도커 컨테이너 생명주기&lt;/h1&gt;
&lt;p&gt;도커 컨테이너는 도커 이미지를 &lt;code&gt;실행&lt;/code&gt;시킨 것이기 때문에 상태를 가지고 있다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;실행 중
&lt;blockquote&gt;
&lt;p&gt;ENTRYPOINT, CMD에 있는 어플리케이션이 실행된 상태를 말한다&lt;br&gt;
명령행 도구 등의 컨테이너는 이 상태가 길게 유지되지 않는다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;정지
&lt;blockquote&gt;
&lt;p&gt;실행 중 상태에 있는 컨테이너를 명시적으로 종료하거나, 컨테이너에서 실행된 어플리케이션이 정상/오류를 막론하고 종료된 경우의 상태를 말한다&lt;br&gt;
정지되어도 그 상태 그대로 디스크에 남아있기 때문에(docker container ls 로 확인 가능) 다시 실행할 수 있다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;파기
&lt;blockquote&gt;
&lt;p&gt;정지된 컨테이너를 명시적으로 삭제하면 파기 상태가 된다(docker container ls 로 확인 불가능)&lt;br&gt;
파기된 컨테이너는 다시 정지된 컨테이너와 같은 상태로 돌아갈 수 없으므로 주의해서 실행해야 한다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;아래는 도커 컨테이너를 관리하면서 자주 사용하는 명령어들과 그에 대한 간단한 설명이다&lt;br&gt;
추가적인 명령어나 옵션이 궁금하다면 &lt;a href=&quot;https://docs.docker.com/engine/reference/commandline/container/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;https://docs.docker.com/engine/reference/commandline/container/&lt;/a&gt; 를 참조한다&lt;/p&gt;
&lt;h1 id=&quot;docker-container-run&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#docker-container-run&quot;&gt;&lt;/a&gt; docker container run&lt;/h1&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ docker container run [options] 이미지명[:태그명] [명령] [명령인자..]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ docker container run [options] 이미지ID [명령] [명령인자..]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;도커 이미지로부터 컨테이너를 생성+실행 하는 명령이다&lt;/p&gt;
&lt;p&gt;유용한 옵션이 많으니 활용하면 좋다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;-d : 백그라운드로 실행&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-p : 포트포워딩&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;-p 9000:8080&lt;/code&gt; == 호스트 포트 9000번을 컨테이너 포트 8080으로 포워딩&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;–name : 컨테이너에 이름 부여&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;매번 컨테이너ID를 조회하는 것이 번거로우므로 이름을 지정할 수 있다&lt;br&gt;
컨테이너 이름은 중복될 수 없기 때문에 개발환경 외에는 잘 사용되지 않는다(운영은 많은수의 컨테이너를 추가/삭제 하므로)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-i, -t : -i는 표준 입력을 받을지 여부이고(파이프라이닝, 키보드 입력), -t는 가상터미널을 제공할지 여부이다&lt;/p&gt;
  &lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ docker container run -it ubuntu:16.04&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;보통 위처럼 -it를 같이 사용하고, 이러면 컨테이너에 쉘에 직접 접근할 수 있게 된다(가상 터미널로 표준 입력을 하는것이 되므로)&lt;/p&gt;
&lt;p&gt;-t 없이 -i 만 사용해도 의미가 있다(파이프라이닝으로 입력하는 방법이 있으므로)&lt;br&gt;
-i 없이 -t 만 사용하는건 의미가 없다(입력을 받지 못하는 상태라 가상터미널을 열어봐야)&lt;br&gt;
-d와 -it를 같이 사용할 수 없다(백그라운드라 입력을 대기하거나 가상터미널을 제공하는것이 불가능하다)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;–rm : 컨테이너를 종료할 때 컨테이너를 파기하는 옵션&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;같은 이름으로 컨테이너를 실행시킬 수 없기 때문에 이 옵션을 사용해주는것이 좋다&lt;br&gt;
보통 &lt;code&gt;--name&lt;/code&gt; 과 같이 사용한다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;컨테이너에 할당할 자원도 어느정도 제어할 수 있다 &lt;a href=&quot;https://jungwoon.github.io/docker/2019/01/13/Docker-6/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;https://jungwoon.github.io/docker/2019/01/13/Docker-6/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;docker-container-ls&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#docker-container-ls&quot;&gt;&lt;/a&gt; docker container ls&lt;/h1&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ docker container ls [options]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;컨테이너의 목록을 보여줌&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;-a : 종료된 컨테이너의 목록도 같이 보여줌(원래는 실행 중인 컨테이너의 목록만 보여줌)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-q : 컨테이너 ID만 추출함&lt;/p&gt;
  &lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ docker container stop $(docker container ls -q)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;처럼 사용할 수 있음&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;–filter : 컨테이너 목록 필터링&lt;/p&gt;
  &lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ docker container ls --filter &lt;span class=&quot;string&quot;&gt;&quot;name=container_name&quot;&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;# 컨테이너명&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ docker container ls --filter &lt;span class=&quot;string&quot;&gt;&quot;ancestor=image_name&quot;&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;# 이미지명&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;docker-container-stop&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#docker-container-stop&quot;&gt;&lt;/a&gt; docker container stop&lt;/h1&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ docker container stop 컨테이너ID_또는_컨테이너명&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;실행중인 컨테이너를 종료할 떄 사용한다&lt;/p&gt;
&lt;h1 id=&quot;docker-container-restart&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#docker-container-restart&quot;&gt;&lt;/a&gt; docker container restart&lt;/h1&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ docker container restart 컨테이너ID_또는_컨테이너명&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;정지한 컨테이너를 재시작할 때 사용한다&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;start 와 차이가 뭘까?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;docker-container-rm&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#docker-container-rm&quot;&gt;&lt;/a&gt; docker container rm&lt;/h1&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ docker container rm 컨테이너ID_또는_컨테이너명&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;정지된 컨테이너를 완전히 파기할 떄 사용한다&lt;br&gt;
실행중인 컨테이너를 강제로 삭제하고 싶다면 &lt;code&gt;-f&lt;/code&gt; 옵션을 사용한다&lt;/p&gt;
&lt;h1 id=&quot;docker-container-logs&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#docker-container-logs&quot;&gt;&lt;/a&gt; docker container logs&lt;/h1&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ docker container logs [options] 컨테이너ID_또는_컨테이너명&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;컨테이너의 표준 출력으로 출력된 내용을 보여준다&lt;br&gt;
&lt;code&gt;-f&lt;/code&gt; 옵션을 주면 새로 출력되는 표준 출력을 계속 볼 수 있다&lt;/p&gt;
&lt;p&gt;보통은 이 내용을 수집해 웹 브라우저나 명령행 도구를 통해 보여주므로 이 명령을 사용할 일은 많이 없다&lt;/p&gt;
&lt;h1 id=&quot;docker-container-exec&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#docker-container-exec&quot;&gt;&lt;/a&gt; docker container exec&lt;/h1&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ docker container &lt;span class=&quot;built_in&quot;&gt;exec&lt;/span&gt; [options] 컨테이너ID_또는_컨테이너명 컨테이너에서_실행할_명령&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;실행 중인 컨테이너에서 원하는 명령을 실행할 수 있다&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ docker container exec ubuntu_docker pwd&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ docker container exec ubuntu_docker ls&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;아예 컨테이너로 접속하고 싶다면 아래와 같이 입력하면 된다&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ docker container exec -it ubuntu_docker sh&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;docker-container-cp&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#docker-container-cp&quot;&gt;&lt;/a&gt; docker container cp&lt;/h1&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ docker container cp [options] 컨테이너ID_또는_컨테이너명:원본파일 호스트_대상파일&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ docker container cp [options] 호스트_원본파일 컨테이너ID_또는_컨테이너명:대상파일&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;실행중인 컨테이너에 파일을 복사하거나 복사해 올 때 사용한다&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Dockerfile의 CP는 이미지 빌드시에 호스트 -&amp;gt; 컨테이너 방향으로의 복사만 가능하다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ docker container cp test_file ubuntu_docker:/tmp/test_file&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;참고 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&amp;amp;mallGb=KOR&amp;amp;barcode=9791158391447&amp;amp;orderClick=LEA&amp;amp;Kc=&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;야마다 아키노리, 『도커/쿠버네티스를 활용한 컨테이너 개발 실전 입문』, 심효섭 옮김, 위키북스(2019)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="docker" scheme="https://joont92.github.io/categories/docker/"/>
    
    
      <category term="도커/쿠버네티스를 활용한 컨테이너 개발 실전 입문" scheme="https://joont92.github.io/tags/%EB%8F%84%EC%BB%A4-%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EA%B0%9C%EB%B0%9C-%EC%8B%A4%EC%A0%84-%EC%9E%85%EB%AC%B8/"/>
    
      <category term="docker container" scheme="https://joont92.github.io/tags/docker-container/"/>
    
  </entry>
  
  <entry>
    <title>[docker] image 다루기</title>
    <link href="https://joont92.github.io/docker/image-%EB%8B%A4%EB%A3%A8%EA%B8%B0/"/>
    <id>https://joont92.github.io/docker/image-다루기/</id>
    <published>2019-06-08T09:50:48.000Z</published>
    <updated>2020-11-02T10:09:30.453Z</updated>
    
    <content type="html"><![CDATA[<p>도커는 크게 도커 이미지와 도커 컨테이너로 나뉜다<br>그 중 도커 이미지는 <strong>컨테이너를 생성하는 템플릿 역할</strong>을 한다</p><p>아래는 도커 이미지를 관리하면서 자주 사용하는 명령어들과 그에 대한 간단한 설명이다<br>추가적인 명령어나 옵션이 궁금하다면 <a href="https://docs.docker.com/engine/reference/commandline/image/" rel="external nofollow noopener noreferrer" target="_blank">https://docs.docker.com/engine/reference/commandline/image/</a> 를 참조한다</p><h1 id="docker-image-build"><a class="markdownIt-Anchor" href="#docker-image-build"></a> docker image build</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image build [options] Dockerfile_경로</span><br></pre></td></tr></table></figure><p><code>Dockerfile</code>에 기술된 내용을 따라 도커 이미지를 생성하는 명령이다</p><blockquote><p><code>Dockerfile</code>은 필수로 필요하다</p></blockquote><p>마지막 인자로 Dockerfile의 <code>경로</code>를 주는것에 유의해야한다</p><h2 id="-t-옵션"><a class="markdownIt-Anchor" href="#-t-옵션"></a> -t 옵션</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image build -t javatest:latest .</span><br></pre></td></tr></table></figure><p>도커 이미지에 이름과 태그를 붙이는 옵션으로 실제 사용에선 거의 <strong>필수적으로 쓰인다</strong><br>지정한 경로에서 <code>Dockerfile</code> 이라는 이름의 파일을 찾고 그 내용을 토대로 이미지를 만든다</p><blockquote><p>태그명은 생략 가능한데, 생략하면 기본적으로 <code>latest</code>가 붙는다</p></blockquote><h2 id="-f-옵션"><a class="markdownIt-Anchor" href="#-f-옵션"></a> -f 옵션</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image build -f Dockerfile_test -t javatest:latest .</span><br></pre></td></tr></table></figure><p><code>Dockerfile</code>이 아닌 다른 이름을 쓰고 싶을 경우 사용한다</p><h2 id="pull-옵션"><a class="markdownIt-Anchor" href="#pull-옵션"></a> –pull 옵션</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image build --pull=<span class="literal">true</span> -t javatest:latest .</span><br></pre></td></tr></table></figure><p>기본적으로 도커 이미지 빌드 시 <code>FROM</code> 인스트럭션에 지정한 이미지를 레지스트리에서 받은 후, 이를 호스트 운영체제 저장해놓고 재사용한다<br>이를 매번 새로 받아오게 하고 싶을 경우 사용하면 좋다</p><p>이 옵션은 아래와 같은 상황을 대비하기 위해 사용하면 좋다</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> somelibrary:latest</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><ol><li>도커 이미지를 빌드한다<ul><li><code>FROM</code> 인스트럭션의 <code>somelibrary:latest</code> 이미지를 받고 로컬에 저장해둔다</li></ul></li><li><code>somelibrary</code> 이미지에 버그가 있어서 수정하고, 다시 <code>latest</code> 태그로 레지스트리에 올렸다</li><li>위의 Dockerfile 로 이미지를 새로 빌드한다</li><li>레지스트리의 변경사항이 생성된 이미지에 반영되지 않는다<ul><li><code>somelibrary:latest</code>가 이미 로컬에 있기 때문에 새로 받아오지 않고 재사용한다</li></ul></li></ol><blockquote><p>이러한 이유로 실무에서는 latest 대신 보통 태그명을 직접 입력한다</p></blockquote><h1 id="docker-search"><a class="markdownIt-Anchor" href="#docker-search"></a> docker search</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker search [options] 검색_키워드</span><br></pre></td></tr></table></figure><p>도커 레지스트리에서 이미지를 검색할 때 사용한다<br>레지스트리를 따로 설정하지 않았다면 기본적으로 도커 허브가 사용된다</p><blockquote><p><strong>도커 허브(Docker Hub)?</strong><br>도커 사 자체에서 관리하는 도커 이미지 레지스트리로, 깃허브처럼 자신의 계정이나 조직 이름으로 리포티저티를 만들고 이미지를 올릴 수 있다<br>도커 허브에는 이미 매우 많은 리포지터리가 등록되어 있어서, 직접 도커 이미지를 만들 필요없이 만들어놓은 이미지를 간단하게 사용할 수 있다</p></blockquote><p>참고로 여기서 몇가지 용어의 혼재가 있을 수 있다</p><ul><li>도커 이미지가 저장되고 관리되는 공간을 도커 레지스트리라고 부른다<blockquote><p>도커 허브, ECR, 사내 도커 레지스트리 등등이 될 수 있다</p></blockquote></li><li>이러한 도커 레지스트리내에서 이미지를 저장해두는 공간을 리포지터리라고 부른다</li><li>그러므로 레지스트리에서 리포지터리를 찾는것은 이미지를 찾는것과 동일한 행위이다<blockquote><p><code>리포지터리명:태그</code>로 접근한다</p></blockquote></li><li>네임스페이스는 레지스트리내에서 리포지터리의 이름이 중복되는 것을 막기 위해 리포지터리 이름 앞에 작성하는 것을 말한다</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker search mysql</span><br><span class="line">$ docker search --<span class="built_in">limit</span> 5 mysql <span class="comment"># 5건만 검색</span></span><br></pre></td></tr></table></figure><p>검색결과는 STARS(깃헙과 동일) 순으로 출력되고, 태그명까지는 검색할 수 없다</p><blockquote><p><code>mysql</code> 처럼 namespace가 없는 애들도 있는데 이는 mysql의 공식 리포지터리라서 그렇다</p></blockquote><h2 id="docker-image-name-format"><a class="markdownIt-Anchor" href="#docker-image-name-format"></a> docker image name format</h2><p>로컬 내에서는 상관없지만, 도커 허브와 같은 registry 를 끼게 되면 이미지 이름(태그)에 일종의 포멧이 생기게 된다</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[레지스트리_호스트/]리포지터리명[:태그]</span><br></pre></td></tr></table></figure><ul><li>레지스트리 호스트를 지정해서 리포지터리를 땡겨올 수 있다<blockquote><p>생략하면 기본적으로 <code>docker.io</code> 가 추가된다(도커 허브)</p></blockquote></li><li>도커 허브를 사용할 경우 리포지터리명 앞에 namespace로 자신의 계정을 줘야한다<blockquote><p>그래야 도커 허브 시스템 내에서 리포지터리를 구분할 수 있다</p></blockquote></li></ul><h1 id="docker-image-pull"><a class="markdownIt-Anchor" href="#docker-image-pull"></a> docker image pull</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image pull [options] 리포지터리명[:태그명]</span><br></pre></td></tr></table></figure><p>도커 레지스트리에서 도커 이미지를 내려받을 때 사용한다</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image pull jenkins</span><br></pre></td></tr></table></figure><p>태그명을 생략하면 default 태그가 사용된다(<code>latest</code>)</p><h1 id="docker-image-ls"><a class="markdownIt-Anchor" href="#docker-image-ls"></a> docker image ls</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls [options] [이미지명[:태그명]]</span><br></pre></td></tr></table></figure><p>현재 호스트 운영체제에 저장된 도커 이미지의 목록을 보여준다</p><p>참고로 여기서 조회되는 IMAGE ID는 CONTAINER ID와는 별개의 것이므로 주의해야 한다</p><h2 id="도커-image-id"><a class="markdownIt-Anchor" href="#도커-image-id"></a> 도커 IMAGE ID</h2><p>도커는 이미지를 빌드할 때 마다 새로운 이미지 ID가 부여된다</p><ol><li><p>docker 파일을 빌드하여 이미지를 만든다</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image build -t javatest:latest .</span><br></pre></td></tr></table></figure></li><li><p>docker image ls로 빌드된 이미지가 잘 저장되었는지 확인한다</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls -a</span><br><span class="line"></span><br><span class="line">REPOSITORY     TAG        IMAGE ID      CREATED      SIZE  </span><br><span class="line">javatest       latest     2327e281c9b2  1 hour ago   4.41MB</span><br></pre></td></tr></table></figure></li><li><p>Dockerfile을 조금 수정하고 다시 빌드하고, docker image ls 로 확인해본다</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker image build -t javatest:latest .</span><br><span class="line">$ docker image ls -a  </span><br><span class="line"></span><br><span class="line">REPOSITORY     TAG        IMAGE ID      CREATED      SIZE  </span><br><span class="line">javatest       latest     57ca5e531d73  1 hour ago   4.40MB </span><br><span class="line">&lt;none&gt;         &lt;none&gt;     2327e281c9b2  2 hour ago   4.41MB</span><br></pre></td></tr></table></figure><blockquote><p>IMAGE ID가 다른 이미지가 새롭게 빌드되었음을 볼 수 있다<br>(Dockerfile을 수정할 때 뿐만 아니라 COPY 되는 대상이 바뀌거나 하여도 새로운 이미지로 빌드된다)<br>똑같은 <code>이미지명:태그명</code> 으로 빌드했기 때문에 기존의 이미지에서 REPOSITORY와 TAG가 <code>&lt;none&gt;</code>으로 표시되는 것을 볼 수 있다</p></blockquote></li></ol><p>결국 IMAGE ID는 도커 이미지의 버전이라고 봐도 무방하다</p><h1 id="docker-image-tag"><a class="markdownIt-Anchor" href="#docker-image-tag"></a> docker image tag</h1><p>위에서 봤다시피 태그는 이미지 ID를 식별하기 위해 붙이는 일종의 별칭이다</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image tag 기반이미지명[:태그] 새이미지명[:태그]</span><br></pre></td></tr></table></figure><p>이미지를 가리키는 태그를 추가 생성할 떄 사용한다<br><code>새이미지명[:태그]</code>가 <code>기반이미지명[:태그]</code>가 가리키고 있던 이미지 ID를 가리키는 상태로 추가된다</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image tag joont92/javatest:latest joont92/javatest:1.0.0</span><br></pre></td></tr></table></figure><p>보통은 이처럼 latest의 특정 시점에 버전 넘버를 태그로 붙이기위해 사용한다<br>이렇게 하면 아래와 같이 생성된다</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">joont92/javatest           1.0.0               4a1fc394fbef</span><br><span class="line">joont92/javatest           latest              4a1fc394fbef</span><br></pre></td></tr></table></figure><blockquote><p>latest 가 가지고 있던 이미지를 가리키는 1.0.0 이 추가로 생성되었다</p></blockquote><h1 id="docker-image-push"><a class="markdownIt-Anchor" href="#docker-image-push"></a> docker image push</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image push [options] 리포지터리명[:태그]</span><br></pre></td></tr></table></figure><p>레지스트리로 도커 허브를 사용할 경우 리포지터리명 앞에 자신의 도커 ID로 네임스페이스를 붙여줘야한다</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 네임스페이스를 추가해주고</span></span><br><span class="line">$ docker image tag javatest:latest joont92/javatest:latest</span><br><span class="line"><span class="comment"># push</span></span><br><span class="line">$ docker image push joont92/javatest:latest</span><br></pre></td></tr></table></figure><p><img src="https://joont92.github.io/temp/%EB%8F%84%EC%BB%A4%ED%97%88%EB%B8%8C-push.png" alt="도커허브-push"><br>리포지터리에 올라갔음을 볼 수 있다</p><p>참고 :</p><ul><li><a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&amp;mallGb=KOR&amp;barcode=9791158391447&amp;orderClick=LEA&amp;Kc=" rel="external nofollow noopener noreferrer" target="_blank">야마다 아키노리, 『도커/쿠버네티스를 활용한 컨테이너 개발 실전 입문』, 심효섭 옮김, 위키북스(2019)</a></li></ul><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;도커는 크게 도커 이미지와 도커 컨테이너로 나뉜다&lt;br&gt;
그 중 도커 이미지는 &lt;strong&gt;컨테이너를 생성하는 템플릿 역할&lt;/strong&gt;을 한다&lt;/p&gt;
&lt;p&gt;아래는 도커 이미지를 관리하면서 자주 사용하는 명령어들과 그에 대한 간단한 설명이다&lt;br&gt;
추가적인 명령어나 옵션이 궁금하다면 &lt;a href=&quot;https://docs.docker.com/engine/reference/commandline/image/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;https://docs.docker.com/engine/reference/commandline/image/&lt;/a&gt; 를 참조한다&lt;/p&gt;
&lt;h1 id=&quot;docker-image-build&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#docker-image-build&quot;&gt;&lt;/a&gt; docker image build&lt;/h1&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ docker image build [options] Dockerfile_경로&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;Dockerfile&lt;/code&gt;에 기술된 내용을 따라 도커 이미지를 생성하는 명령이다&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Dockerfile&lt;/code&gt;은 필수로 필요하다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;마지막 인자로 Dockerfile의 &lt;code&gt;경로&lt;/code&gt;를 주는것에 유의해야한다&lt;/p&gt;
&lt;h2 id=&quot;-t-옵션&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#-t-옵션&quot;&gt;&lt;/a&gt; -t 옵션&lt;/h2&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ docker image build -t javatest:latest .&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;도커 이미지에 이름과 태그를 붙이는 옵션으로 실제 사용에선 거의 &lt;strong&gt;필수적으로 쓰인다&lt;/strong&gt;&lt;br&gt;
지정한 경로에서 &lt;code&gt;Dockerfile&lt;/code&gt; 이라는 이름의 파일을 찾고 그 내용을 토대로 이미지를 만든다&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;태그명은 생략 가능한데, 생략하면 기본적으로 &lt;code&gt;latest&lt;/code&gt;가 붙는다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;-f-옵션&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#-f-옵션&quot;&gt;&lt;/a&gt; -f 옵션&lt;/h2&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ docker image build -f Dockerfile_test -t javatest:latest .&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;Dockerfile&lt;/code&gt;이 아닌 다른 이름을 쓰고 싶을 경우 사용한다&lt;/p&gt;
&lt;h2 id=&quot;pull-옵션&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#pull-옵션&quot;&gt;&lt;/a&gt; –pull 옵션&lt;/h2&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ docker image build --pull=&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt; -t javatest:latest .&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;기본적으로 도커 이미지 빌드 시 &lt;code&gt;FROM&lt;/code&gt; 인스트럭션에 지정한 이미지를 레지스트리에서 받은 후, 이를 호스트 운영체제 저장해놓고 재사용한다&lt;br&gt;
이를 매번 새로 받아오게 하고 싶을 경우 사용하면 좋다&lt;/p&gt;
&lt;p&gt;이 옵션은 아래와 같은 상황을 대비하기 위해 사용하면 좋다&lt;/p&gt;
&lt;figure class=&quot;highlight dockerfile&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;FROM&lt;/span&gt; somelibrary:latest&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;도커 이미지를 빌드한다
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;FROM&lt;/code&gt; 인스트럭션의 &lt;code&gt;somelibrary:latest&lt;/code&gt; 이미지를 받고 로컬에 저장해둔다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;somelibrary&lt;/code&gt; 이미지에 버그가 있어서 수정하고, 다시 &lt;code&gt;latest&lt;/code&gt; 태그로 레지스트리에 올렸다&lt;/li&gt;
&lt;li&gt;위의 Dockerfile 로 이미지를 새로 빌드한다&lt;/li&gt;
&lt;li&gt;레지스트리의 변경사항이 생성된 이미지에 반영되지 않는다
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;somelibrary:latest&lt;/code&gt;가 이미 로컬에 있기 때문에 새로 받아오지 않고 재사용한다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;이러한 이유로 실무에서는 latest 대신 보통 태그명을 직접 입력한다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;docker-search&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#docker-search&quot;&gt;&lt;/a&gt; docker search&lt;/h1&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ docker search [options] 검색_키워드&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;도커 레지스트리에서 이미지를 검색할 때 사용한다&lt;br&gt;
레지스트리를 따로 설정하지 않았다면 기본적으로 도커 허브가 사용된다&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;도커 허브(Docker Hub)?&lt;/strong&gt;&lt;br&gt;
도커 사 자체에서 관리하는 도커 이미지 레지스트리로, 깃허브처럼 자신의 계정이나 조직 이름으로 리포티저티를 만들고 이미지를 올릴 수 있다&lt;br&gt;
도커 허브에는 이미 매우 많은 리포지터리가 등록되어 있어서, 직접 도커 이미지를 만들 필요없이 만들어놓은 이미지를 간단하게 사용할 수 있다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;참고로 여기서 몇가지 용어의 혼재가 있을 수 있다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;도커 이미지가 저장되고 관리되는 공간을 도커 레지스트리라고 부른다
&lt;blockquote&gt;
&lt;p&gt;도커 허브, ECR, 사내 도커 레지스트리 등등이 될 수 있다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;이러한 도커 레지스트리내에서 이미지를 저장해두는 공간을 리포지터리라고 부른다&lt;/li&gt;
&lt;li&gt;그러므로 레지스트리에서 리포지터리를 찾는것은 이미지를 찾는것과 동일한 행위이다
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;리포지터리명:태그&lt;/code&gt;로 접근한다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;네임스페이스는 레지스트리내에서 리포지터리의 이름이 중복되는 것을 막기 위해 리포지터리 이름 앞에 작성하는 것을 말한다&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ docker search mysql&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ docker search --&lt;span class=&quot;built_in&quot;&gt;limit&lt;/span&gt; 5 mysql &lt;span class=&quot;comment&quot;&gt;# 5건만 검색&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;검색결과는 STARS(깃헙과 동일) 순으로 출력되고, 태그명까지는 검색할 수 없다&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;mysql&lt;/code&gt; 처럼 namespace가 없는 애들도 있는데 이는 mysql의 공식 리포지터리라서 그렇다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;docker-image-name-format&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#docker-image-name-format&quot;&gt;&lt;/a&gt; docker image name format&lt;/h2&gt;
&lt;p&gt;로컬 내에서는 상관없지만, 도커 허브와 같은 registry 를 끼게 되면 이미지 이름(태그)에 일종의 포멧이 생기게 된다&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[레지스트리_호스트/]리포지터리명[:태그]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;레지스트리 호스트를 지정해서 리포지터리를 땡겨올 수 있다
&lt;blockquote&gt;
&lt;p&gt;생략하면 기본적으로 &lt;code&gt;docker.io&lt;/code&gt; 가 추가된다(도커 허브)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;도커 허브를 사용할 경우 리포지터리명 앞에 namespace로 자신의 계정을 줘야한다
&lt;blockquote&gt;
&lt;p&gt;그래야 도커 허브 시스템 내에서 리포지터리를 구분할 수 있다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;docker-image-pull&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#docker-image-pull&quot;&gt;&lt;/a&gt; docker image pull&lt;/h1&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ docker image pull [options] 리포지터리명[:태그명]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;도커 레지스트리에서 도커 이미지를 내려받을 때 사용한다&lt;/p&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ docker image pull jenkins&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;태그명을 생략하면 default 태그가 사용된다(&lt;code&gt;latest&lt;/code&gt;)&lt;/p&gt;
&lt;h1 id=&quot;docker-image-ls&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#docker-image-ls&quot;&gt;&lt;/a&gt; docker image ls&lt;/h1&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ docker image ls [options] [이미지명[:태그명]]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;현재 호스트 운영체제에 저장된 도커 이미지의 목록을 보여준다&lt;/p&gt;
&lt;p&gt;참고로 여기서 조회되는 IMAGE ID는 CONTAINER ID와는 별개의 것이므로 주의해야 한다&lt;/p&gt;
&lt;h2 id=&quot;도커-image-id&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#도커-image-id&quot;&gt;&lt;/a&gt; 도커 IMAGE ID&lt;/h2&gt;
&lt;p&gt;도커는 이미지를 빌드할 때 마다 새로운 이미지 ID가 부여된다&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;docker 파일을 빌드하여 이미지를 만든다&lt;/p&gt;
 &lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ docker image build -t javatest:latest .&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;docker image ls로 빌드된 이미지가 잘 저장되었는지 확인한다&lt;/p&gt;
 &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ docker image ls -a&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;REPOSITORY     TAG        IMAGE ID      CREATED      SIZE  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;javatest       latest     2327e281c9b2  1 hour ago   4.41MB&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Dockerfile을 조금 수정하고 다시 빌드하고, docker image ls 로 확인해본다&lt;/p&gt;
 &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ docker image build -t javatest:latest .&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ docker image ls -a  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;REPOSITORY     TAG        IMAGE ID      CREATED      SIZE  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;javatest       latest     57ca5e531d73  1 hour ago   4.40MB &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;none&amp;gt;         &amp;lt;none&amp;gt;     2327e281c9b2  2 hour ago   4.41MB&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;IMAGE ID가 다른 이미지가 새롭게 빌드되었음을 볼 수 있다&lt;br&gt;
(Dockerfile을 수정할 때 뿐만 아니라 COPY 되는 대상이 바뀌거나 하여도 새로운 이미지로 빌드된다)&lt;br&gt;
똑같은 &lt;code&gt;이미지명:태그명&lt;/code&gt; 으로 빌드했기 때문에 기존의 이미지에서 REPOSITORY와 TAG가 &lt;code&gt;&amp;lt;none&amp;gt;&lt;/code&gt;으로 표시되는 것을 볼 수 있다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;결국 IMAGE ID는 도커 이미지의 버전이라고 봐도 무방하다&lt;/p&gt;
&lt;h1 id=&quot;docker-image-tag&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#docker-image-tag&quot;&gt;&lt;/a&gt; docker image tag&lt;/h1&gt;
&lt;p&gt;위에서 봤다시피 태그는 이미지 ID를 식별하기 위해 붙이는 일종의 별칭이다&lt;/p&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ docker image tag 기반이미지명[:태그] 새이미지명[:태그]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;이미지를 가리키는 태그를 추가 생성할 떄 사용한다&lt;br&gt;
&lt;code&gt;새이미지명[:태그]&lt;/code&gt;가 &lt;code&gt;기반이미지명[:태그]&lt;/code&gt;가 가리키고 있던 이미지 ID를 가리키는 상태로 추가된다&lt;/p&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ docker image tag joont92/javatest:latest joont92/javatest:1.0.0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;보통은 이처럼 latest의 특정 시점에 버전 넘버를 태그로 붙이기위해 사용한다&lt;br&gt;
이렇게 하면 아래와 같이 생성된다&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;joont92/javatest           1.0.0               4a1fc394fbef&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;joont92/javatest           latest              4a1fc394fbef&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;latest 가 가지고 있던 이미지를 가리키는 1.0.0 이 추가로 생성되었다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;docker-image-push&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#docker-image-push&quot;&gt;&lt;/a&gt; docker image push&lt;/h1&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ docker image push [options] 리포지터리명[:태그]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;레지스트리로 도커 허브를 사용할 경우 리포지터리명 앞에 자신의 도커 ID로 네임스페이스를 붙여줘야한다&lt;/p&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 네임스페이스를 추가해주고&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ docker image tag javatest:latest joont92/javatest:latest&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# push&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ docker image push joont92/javatest:latest&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;https://joont92.github.io/temp/%EB%8F%84%EC%BB%A4%ED%97%88%EB%B8%8C-push.png&quot; alt=&quot;도커허브-push&quot;&gt;&lt;br&gt;
리포지터리에 올라갔음을 볼 수 있다&lt;/p&gt;
&lt;p&gt;참고 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&amp;amp;mallGb=KOR&amp;amp;barcode=9791158391447&amp;amp;orderClick=LEA&amp;amp;Kc=&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;야마다 아키노리, 『도커/쿠버네티스를 활용한 컨테이너 개발 실전 입문』, 심효섭 옮김, 위키북스(2019)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="docker" scheme="https://joont92.github.io/categories/docker/"/>
    
    
      <category term="도커/쿠버네티스를 활용한 컨테이너 개발 실전 입문" scheme="https://joont92.github.io/tags/%EB%8F%84%EC%BB%A4-%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EA%B0%9C%EB%B0%9C-%EC%8B%A4%EC%A0%84-%EC%9E%85%EB%AC%B8/"/>
    
      <category term="docker image" scheme="https://joont92.github.io/tags/docker-image/"/>
    
  </entry>
  
  <entry>
    <title>[docker] Dockerfile</title>
    <link href="https://joont92.github.io/docker/Dockerfile/"/>
    <id>https://joont92.github.io/docker/Dockerfile/</id>
    <published>2019-06-07T21:07:24.000Z</published>
    <updated>2020-11-02T10:09:30.453Z</updated>
    
    <content type="html"><![CDATA[<h1 id="dockerfile이란"><a class="markdownIt-Anchor" href="#dockerfile이란"></a> Dockerfile이란?</h1><p>도커 이미지를 만들 때 꼭 필요한 설정파일이다<br>이 파일내에 작성된 인스트럭션들을 참조하여 이미지가 만들어진다</p><p>기본으로 <code>Dockerfile</code> 이라는 이름을 사용하고, 이름을 변경하고 싶다면 이미지 빌드시에 추가 옵션을 줘야한다(-f)</p><h1 id="인스트럭션"><a class="markdownIt-Anchor" href="#인스트럭션"></a> 인스트럭션</h1><p><code>Dockerfile</code> 내에 있는 명령어들을 말한다<br>아래는 각 인스트럭션에 대해 간단히 나열한 것이며, 자세한 내용이 궁금하면 <a href="https://docs.docker.com/engine/reference/builder/" rel="external nofollow noopener noreferrer" target="_blank">https://docs.docker.com/engine/reference/builder/</a> 를 참조한다</p><h2 id="자주-사용하는-인스트럭션"><a class="markdownIt-Anchor" href="#자주-사용하는-인스트럭션"></a> 자주 사용하는 인스트럭션</h2><p>예시로 사용할 자바 어플리케이션과 Dockerfile 이다</p><p>Test.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dockerfile</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FROM openjdk:8-jdk</span><br><span class="line"></span><br><span class="line">COPY Test.java .</span><br><span class="line">RUN javac Test.java</span><br><span class="line"></span><br><span class="line">CMD [&quot;java&quot;, &quot;Test&quot;]</span><br></pre></td></tr></table></figure><h3 id="from"><a class="markdownIt-Anchor" href="#from"></a> FROM</h3><p>해당 도커 이미지의 바탕이 될 베이스 이미지를 지정하는 인스트럭션이다<br>openjdk를 베이스 이미지로 땡겨왔기 때문에 javac, java 명령어가 실행 가능함을 볼 수 있다</p><blockquote><p>openjdk의 Dockerfile을 따라가보면 FROM에 ubuntu를 사용하고 있다<br>이런식으로 이미지가 겹겹이 포장되어 빌드되는 형식이다</p></blockquote><p>openjdk 는 이미지명이며, 8-jdk는 태그명이다<br>레지스트리를 따로 지정하지 않았기 때문에 도커 허브에서 땡겨온다</p><h3 id="copy"><a class="markdownIt-Anchor" href="#copy"></a> COPY</h3><p>호스트 머신의 파일이나 디렉터리를 도커 컨테이너 안으로 복사하는 인스트럭션이다<br><code>이미지가 빌드될 때 1번만 실행</code>되는 명령어이다</p><p>컨테이너안의 현재 디렉토리로 호스트 머신의 Test.java 이 복사된다</p><h3 id="add"><a class="markdownIt-Anchor" href="#add"></a> ADD</h3><p>기본적인 기능은 COPY와 동일하고, 아래의 기능이 추가로 더 있다</p><ul><li>source가 remote URL 이면 다운받은 뒤 destination 에 복사한다</li><li>source가 잘 알려진 압축파일 형식이면(tar, zip 등) 압축을 풀어준다</li><li>source가 remote URL + 압축파일 형식이면 압축을 풀지는 않는다</li></ul><p>아무래도 위와 같이 특수한 상황이 아니라면 COPY를 쓰는게 낫다<br>명시적이기 때문이다</p><h3 id="run"><a class="markdownIt-Anchor" href="#run"></a> RUN</h3><p>도커 이미지를 <code>실행할 컨테이너 안에서</code> 실행할 명령을 정의한다<br>이 또한 <code>이미지가 빌드될 때 1번만 실행</code>되는 명령어이다</p><p>복사된 Test.java를 javac로 컴파일하고 있다</p><h3 id="cmd"><a class="markdownIt-Anchor" href="#cmd"></a> CMD</h3><p>컨테이너 안에서 실행할 프로세스(명령)를 지정한다<br>이는 <code>이미지가 컨테이너화 될 때(실행될 때)마다 실행</code>되는 명령어이다</p><p>컴파일된 Test.class 파일을 실행하고 있다</p><p>작성법이 조금 특이한데, 총 3가지 작성법을 제공한다</p><ul><li><p>CMD command param1 param2 […]</p><ul><li>가장 익숙한 형태이다</li><li>FROM 으로 설정한 이미지에 포함된 쉘 파일을 사용하여 명령을 실행한다</li><li>쉘 스크립트 구문을 사용할 수 있다</li></ul></li><li><p>CMD [“executable”, “param1”, “param2” [, …]]</p><ul><li><p>쉘 없이 바로 실행하면서 매개변수를 던져주는 형태이다</p></li><li><p>도커에서 권장하는 형태이다</p></li><li><p>쉘 스크립트 구문을 사용할 수 없다</p>  <figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"echo"</span>, <span class="string">"Hello, <span class="variable">$name</span>"</span>]</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">$ Hello <span class="variable">$name</span></span></span><br></pre></td></tr></table></figure></li><li><p>만약 쉘 스크립트를 사용하고 싶다면 쉘을 실행시키면서 인자로 전달해줘야 한다</p>  <figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"/bin/bash"</span>, <span class="string">"-c"</span>, <span class="string">"echo Hello, <span class="variable">$name</span>"</span>]</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>CMD [“param1”, “param2” [, …]]</p><ul><li>ENTRYPOINT에 지정된 명령에 사용할 인자를 전달한다</li></ul></li></ul><h4 id="cmd는-dockerfile-내에-하나만-작성할-수-있다"><a class="markdownIt-Anchor" href="#cmd는-dockerfile-내에-하나만-작성할-수-있다"></a> CMD는 Dockerfile 내에 하나만 작성할 수 있다</h4><p>만약 CMD를 여러개 작성한다면 가장 앞부분껀 전부 무시되고 가장 마지막에 있는 명령만이 실행된다</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"javac"</span>, <span class="string">"Test.java"</span>]</span></span><br><span class="line"><span class="bash">CMD [<span class="string">"java"</span>, <span class="string">"Test"</span>]</span></span><br></pre></td></tr></table></figure><p>했다가 안되서 찾아봤음…</p><h4 id="cmd-명령-오버라이드도-가능하다"><a class="markdownIt-Anchor" href="#cmd-명령-오버라이드도-가능하다"></a> CMD 명령 오버라이드도 가능하다</h4><p>위와 같이 선언된 상황에서</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run javatest:latest <span class="built_in">echo</span> joont92</span><br><span class="line">$ joont92 <span class="comment"># 출력</span></span><br></pre></td></tr></table></figure><p>CMD 명령이 무시됨을 볼 수 있다</p><h2 id="그-외-인스트럭션"><a class="markdownIt-Anchor" href="#그-외-인스트럭션"></a> 그 외 인스트럭션</h2><h3 id="entrypoint"><a class="markdownIt-Anchor" href="#entrypoint"></a> ENTRYPOINT</h3><p>CMD와 마찬가지로 컨테이너 안에서 실행될 프로세스(명령)를 지정하는 인스트럭션이다<br>CMD와 다른점은 조금 기준점(?) 이 되는 프로세스를 지정하는 것이랄까…<br>ENTRYPOINT를 입력하면 CMD에 전달된 인자들은 전부 ENTRYPOINT의 인자로 전달된다</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:jdk-<span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"java"</span>]</span></span><br><span class="line"><span class="bash">CMD [<span class="string">"version"</span>]</span></span><br></pre></td></tr></table></figure><p>또한 아래와 같이 사용해서 컨테이너의 용도를 어느정도 제한 할수도 있다</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"go"</span>]</span></span><br><span class="line"><span class="bash">CMD [<span class="string">""</span>]</span></span><br></pre></td></tr></table></figure><p>자동으로 go 가 입력된 상태라고 보면 된다<br>go 이후의 명령어만 인자로 넘기면 된다</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run gotest:latest version</span><br><span class="line">$ go version go1.10.3 linux/amd64 <span class="comment"># 출력</span></span><br></pre></td></tr></table></figure><h3 id="label"><a class="markdownIt-Anchor" href="#label"></a> LABEL</h3><p>이미지를 만든 사람의 이름 등을 적을 수 있다</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="bash"> maintainer=<span class="string">"joont92@github.com"</span></span></span><br></pre></td></tr></table></figure><h3 id="env"><a class="markdownIt-Anchor" href="#env"></a> ENV</h3><p>도커 안에서 사용할 환경 변수를 지정한다</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> CLASSPATH=/workspace/javatest</span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"java"</span>, <span class="string">"Main"</span>]</span></span><br></pre></td></tr></table></figure><h3 id="arg"><a class="markdownIt-Anchor" href="#arg"></a> ARG</h3><p>이미지 빌드할 떄 환경변수를 정의하여 사용할 수 있다</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ARG</span> classpath=.</span><br><span class="line"><span class="keyword">ENV</span> CLASSPATH=$&#123;classpath&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"java"</span>, <span class="string">"Main"</span>]</span></span><br></pre></td></tr></table></figure><p>외부에서 환경변수를 전달 받을수도 있다<br><code>--build-arg</code>를 통해 인자를 전달한다</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image build --build-arg classpath=/workapce/javatest -t javatest:latest .</span><br></pre></td></tr></table></figure><blockquote><p>이미지 빌드시에만 사용할 수 있다<br>컨테이너 생성시에 클래스패스를 바꾸는 것은 불가능하다</p></blockquote><p>참고 :</p><ul><li><a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&amp;mallGb=KOR&amp;barcode=9791158391447&amp;orderClick=LEA&amp;Kc=" rel="external nofollow noopener noreferrer" target="_blank">야마다 아키노리, 『도커/쿠버네티스를 활용한 컨테이너 개발 실전 입문』, 심효섭 옮김, 위키북스(2019)</a></li></ul><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;dockerfile이란&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#dockerfile이란&quot;&gt;&lt;/a&gt; Dockerfile이란?&lt;/h1&gt;
&lt;p&gt;도커 이미지를 만들 때 꼭 필요한 설정파일이다&lt;br&gt;
이 파일내에 작성된 인스트럭션들을 참조하여 이미지가 만들어진다&lt;/p&gt;
&lt;p&gt;기본으로 &lt;code&gt;Dockerfile&lt;/code&gt; 이라는 이름을 사용하고, 이름을 변경하고 싶다면 이미지 빌드시에 추가 옵션을 줘야한다(-f)&lt;/p&gt;
&lt;h1 id=&quot;인스트럭션&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#인스트럭션&quot;&gt;&lt;/a&gt; 인스트럭션&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;Dockerfile&lt;/code&gt; 내에 있는 명령어들을 말한다&lt;br&gt;
아래는 각 인스트럭션에 대해 간단히 나열한 것이며, 자세한 내용이 궁금하면 &lt;a href=&quot;https://docs.docker.com/engine/reference/builder/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;https://docs.docker.com/engine/reference/builder/&lt;/a&gt; 를 참조한다&lt;/p&gt;
&lt;h2 id=&quot;자주-사용하는-인스트럭션&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#자주-사용하는-인스트럭션&quot;&gt;&lt;/a&gt; 자주 사용하는 인스트럭션&lt;/h2&gt;
&lt;p&gt;예시로 사용할 자바 어플리케이션과 Dockerfile 이다&lt;/p&gt;
&lt;p&gt;Test.java&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Test&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;Hello World!&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Dockerfile&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;FROM openjdk:8-jdk&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;COPY Test.java .&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RUN javac Test.java&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CMD [&amp;quot;java&amp;quot;, &amp;quot;Test&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;from&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#from&quot;&gt;&lt;/a&gt; FROM&lt;/h3&gt;
&lt;p&gt;해당 도커 이미지의 바탕이 될 베이스 이미지를 지정하는 인스트럭션이다&lt;br&gt;
openjdk를 베이스 이미지로 땡겨왔기 때문에 javac, java 명령어가 실행 가능함을 볼 수 있다&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;openjdk의 Dockerfile을 따라가보면 FROM에 ubuntu를 사용하고 있다&lt;br&gt;
이런식으로 이미지가 겹겹이 포장되어 빌드되는 형식이다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;openjdk 는 이미지명이며, 8-jdk는 태그명이다&lt;br&gt;
레지스트리를 따로 지정하지 않았기 때문에 도커 허브에서 땡겨온다&lt;/p&gt;
&lt;h3 id=&quot;copy&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#copy&quot;&gt;&lt;/a&gt; COPY&lt;/h3&gt;
&lt;p&gt;호스트 머신의 파일이나 디렉터리를 도커 컨테이너 안으로 복사하는 인스트럭션이다&lt;br&gt;
&lt;code&gt;이미지가 빌드될 때 1번만 실행&lt;/code&gt;되는 명령어이다&lt;/p&gt;
&lt;p&gt;컨테이너안의 현재 디렉토리로 호스트 머신의 Test.java 이 복사된다&lt;/p&gt;
&lt;h3 id=&quot;add&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#add&quot;&gt;&lt;/a&gt; ADD&lt;/h3&gt;
&lt;p&gt;기본적인 기능은 COPY와 동일하고, 아래의 기능이 추가로 더 있다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;source가 remote URL 이면 다운받은 뒤 destination 에 복사한다&lt;/li&gt;
&lt;li&gt;source가 잘 알려진 압축파일 형식이면(tar, zip 등) 압축을 풀어준다&lt;/li&gt;
&lt;li&gt;source가 remote URL + 압축파일 형식이면 압축을 풀지는 않는다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;아무래도 위와 같이 특수한 상황이 아니라면 COPY를 쓰는게 낫다&lt;br&gt;
명시적이기 때문이다&lt;/p&gt;
&lt;h3 id=&quot;run&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#run&quot;&gt;&lt;/a&gt; RUN&lt;/h3&gt;
&lt;p&gt;도커 이미지를 &lt;code&gt;실행할 컨테이너 안에서&lt;/code&gt; 실행할 명령을 정의한다&lt;br&gt;
이 또한 &lt;code&gt;이미지가 빌드될 때 1번만 실행&lt;/code&gt;되는 명령어이다&lt;/p&gt;
&lt;p&gt;복사된 Test.java를 javac로 컴파일하고 있다&lt;/p&gt;
&lt;h3 id=&quot;cmd&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#cmd&quot;&gt;&lt;/a&gt; CMD&lt;/h3&gt;
&lt;p&gt;컨테이너 안에서 실행할 프로세스(명령)를 지정한다&lt;br&gt;
이는 &lt;code&gt;이미지가 컨테이너화 될 때(실행될 때)마다 실행&lt;/code&gt;되는 명령어이다&lt;/p&gt;
&lt;p&gt;컴파일된 Test.class 파일을 실행하고 있다&lt;/p&gt;
&lt;p&gt;작성법이 조금 특이한데, 총 3가지 작성법을 제공한다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;CMD command param1 param2 […]&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;가장 익숙한 형태이다&lt;/li&gt;
&lt;li&gt;FROM 으로 설정한 이미지에 포함된 쉘 파일을 사용하여 명령을 실행한다&lt;/li&gt;
&lt;li&gt;쉘 스크립트 구문을 사용할 수 있다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CMD [“executable”, “param1”, “param2” [, …]]&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;쉘 없이 바로 실행하면서 매개변수를 던져주는 형태이다&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;도커에서 권장하는 형태이다&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;쉘 스크립트 구문을 사용할 수 없다&lt;/p&gt;
  &lt;figure class=&quot;highlight dockerfile&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;CMD&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; [&lt;span class=&quot;string&quot;&gt;&quot;echo&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Hello, &lt;span class=&quot;variable&quot;&gt;$name&lt;/span&gt;&quot;&lt;/span&gt;]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bash&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bash&quot;&gt;$ Hello &lt;span class=&quot;variable&quot;&gt;$name&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;만약 쉘 스크립트를 사용하고 싶다면 쉘을 실행시키면서 인자로 전달해줘야 한다&lt;/p&gt;
  &lt;figure class=&quot;highlight dockerfile&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;CMD&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; [&lt;span class=&quot;string&quot;&gt;&quot;/bin/bash&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;-c&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;echo Hello, &lt;span class=&quot;variable&quot;&gt;$name&lt;/span&gt;&quot;&lt;/span&gt;]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CMD [“param1”, “param2” [, …]]&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ENTRYPOINT에 지정된 명령에 사용할 인자를 전달한다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;cmd는-dockerfile-내에-하나만-작성할-수-있다&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#cmd는-dockerfile-내에-하나만-작성할-수-있다&quot;&gt;&lt;/a&gt; CMD는 Dockerfile 내에 하나만 작성할 수 있다&lt;/h4&gt;
&lt;p&gt;만약 CMD를 여러개 작성한다면 가장 앞부분껀 전부 무시되고 가장 마지막에 있는 명령만이 실행된다&lt;/p&gt;
&lt;figure class=&quot;highlight dockerfile&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;CMD&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; [&lt;span class=&quot;string&quot;&gt;&quot;javac&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Test.java&quot;&lt;/span&gt;]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bash&quot;&gt;CMD [&lt;span class=&quot;string&quot;&gt;&quot;java&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Test&quot;&lt;/span&gt;]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;했다가 안되서 찾아봤음…&lt;/p&gt;
&lt;h4 id=&quot;cmd-명령-오버라이드도-가능하다&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#cmd-명령-오버라이드도-가능하다&quot;&gt;&lt;/a&gt; CMD 명령 오버라이드도 가능하다&lt;/h4&gt;
&lt;p&gt;위와 같이 선언된 상황에서&lt;/p&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ docker container run javatest:latest &lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; joont92&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ joont92 &lt;span class=&quot;comment&quot;&gt;# 출력&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;CMD 명령이 무시됨을 볼 수 있다&lt;/p&gt;
&lt;h2 id=&quot;그-외-인스트럭션&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#그-외-인스트럭션&quot;&gt;&lt;/a&gt; 그 외 인스트럭션&lt;/h2&gt;
&lt;h3 id=&quot;entrypoint&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#entrypoint&quot;&gt;&lt;/a&gt; ENTRYPOINT&lt;/h3&gt;
&lt;p&gt;CMD와 마찬가지로 컨테이너 안에서 실행될 프로세스(명령)를 지정하는 인스트럭션이다&lt;br&gt;
CMD와 다른점은 조금 기준점(?) 이 되는 프로세스를 지정하는 것이랄까…&lt;br&gt;
ENTRYPOINT를 입력하면 CMD에 전달된 인자들은 전부 ENTRYPOINT의 인자로 전달된다&lt;/p&gt;
&lt;figure class=&quot;highlight dockerfile&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;FROM&lt;/span&gt; openjdk:jdk-&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;ENTRYPOINT&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; [&lt;span class=&quot;string&quot;&gt;&quot;java&quot;&lt;/span&gt;]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bash&quot;&gt;CMD [&lt;span class=&quot;string&quot;&gt;&quot;version&quot;&lt;/span&gt;]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;또한 아래와 같이 사용해서 컨테이너의 용도를 어느정도 제한 할수도 있다&lt;/p&gt;
&lt;figure class=&quot;highlight dockerfile&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;FROM&lt;/span&gt; golang:&lt;span class=&quot;number&quot;&gt;1.10&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;ENTRYPOINT&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; [&lt;span class=&quot;string&quot;&gt;&quot;go&quot;&lt;/span&gt;]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bash&quot;&gt;CMD [&lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;자동으로 go 가 입력된 상태라고 보면 된다&lt;br&gt;
go 이후의 명령어만 인자로 넘기면 된다&lt;/p&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ docker container run gotest:latest version&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ go version go1.10.3 linux/amd64 &lt;span class=&quot;comment&quot;&gt;# 출력&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;label&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#label&quot;&gt;&lt;/a&gt; LABEL&lt;/h3&gt;
&lt;p&gt;이미지를 만든 사람의 이름 등을 적을 수 있다&lt;/p&gt;
&lt;figure class=&quot;highlight dockerfile&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;LABEL&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; maintainer=&lt;span class=&quot;string&quot;&gt;&quot;joont92@github.com&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;env&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#env&quot;&gt;&lt;/a&gt; ENV&lt;/h3&gt;
&lt;p&gt;도커 안에서 사용할 환경 변수를 지정한다&lt;/p&gt;
&lt;figure class=&quot;highlight dockerfile&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;ENV&lt;/span&gt; CLASSPATH=/workspace/javatest&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;CMD&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; [&lt;span class=&quot;string&quot;&gt;&quot;java&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Main&quot;&lt;/span&gt;]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;arg&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#arg&quot;&gt;&lt;/a&gt; ARG&lt;/h3&gt;
&lt;p&gt;이미지 빌드할 떄 환경변수를 정의하여 사용할 수 있다&lt;/p&gt;
&lt;figure class=&quot;highlight dockerfile&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;ARG&lt;/span&gt; classpath=.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;ENV&lt;/span&gt; CLASSPATH=$&amp;#123;classpath&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;CMD&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; [&lt;span class=&quot;string&quot;&gt;&quot;java&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Main&quot;&lt;/span&gt;]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;외부에서 환경변수를 전달 받을수도 있다&lt;br&gt;
&lt;code&gt;--build-arg&lt;/code&gt;를 통해 인자를 전달한다&lt;/p&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ docker image build --build-arg classpath=/workapce/javatest -t javatest:latest .&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;이미지 빌드시에만 사용할 수 있다&lt;br&gt;
컨테이너 생성시에 클래스패스를 바꾸는 것은 불가능하다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;참고 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&amp;amp;mallGb=KOR&amp;amp;barcode=9791158391447&amp;amp;orderClick=LEA&amp;amp;Kc=&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;야마다 아키노리, 『도커/쿠버네티스를 활용한 컨테이너 개발 실전 입문』, 심효섭 옮김, 위키북스(2019)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="docker" scheme="https://joont92.github.io/categories/docker/"/>
    
    
      <category term="docker" scheme="https://joont92.github.io/tags/docker/"/>
    
      <category term="도커/쿠버네티스를 활용한 컨테이너 개발 실전 입문" scheme="https://joont92.github.io/tags/%EB%8F%84%EC%BB%A4-%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EA%B0%9C%EB%B0%9C-%EC%8B%A4%EC%A0%84-%EC%9E%85%EB%AC%B8/"/>
    
      <category term="docker image" scheme="https://joont92.github.io/tags/docker-image/"/>
    
  </entry>
  
  <entry>
    <title>[docker] 도커(docker)란?</title>
    <link href="https://joont92.github.io/docker/%EB%8F%84%EC%BB%A4-docker-%EB%9E%80/"/>
    <id>https://joont92.github.io/docker/도커-docker-란/</id>
    <published>2019-06-07T20:57:30.000Z</published>
    <updated>2020-11-02T10:09:30.453Z</updated>
    
    <content type="html"><![CDATA[<h1 id="기존의-가상화-기술"><a class="markdownIt-Anchor" href="#기존의-가상화-기술"></a> 기존의 가상화 기술</h1><p>기존에 우리가 알고 있는 가상화는 하이퍼바이저(VMM)라는 기술을 이용하여 구현된 것이다<br>하이퍼바이저는 호스트 컴퓨터에서 다수의 운영체제를 동시에 실행하기 위한 논리적 플랫폼을 말한다</p><p>하이퍼바이저를 이용한 가상화 방식에는 크게 2가지가 있다</p><h2 id="virtual-machine-type1native"><a class="markdownIt-Anchor" href="#virtual-machine-type1native"></a> Virtual Machine Type1(native)</h2><p>호스트 OS 없이 하이퍼바이저가 하드웨어 바로 위에서 직접 동작하는 방식이다<br>중간에 OS가 없으므로 하드웨어에서 가상화 기술을 지원해줘야 하는 단점이 있지만, 요즘 CPU들은 대부분 가상화를 기본으로 지원하기 떄문에 그다지 단점이 되진 않는다</p><p>type1에서도 구현방식이 또 2가지로 나뉜다</p><h3 id="전가상화"><a class="markdownIt-Anchor" href="#전가상화"></a> 전가상화</h3><p>하드웨어 전체를 가상화한 뒤 가상머신을 올리는 방법을 말한다<br>모든 가상머신의 요청은 항상 하이퍼바이저를 통해서 가게 된다</p><h3 id="반가상화"><a class="markdownIt-Anchor" href="#반가상화"></a> 반가상화</h3><p>하드웨어 전체를 다 가상화하진 않는 방식을 말한다<br>특정 요청은 하드웨어에 직접 요청가능하고, 특정 요청은 하이퍼바이저를 통해서만 가능하다(CPU, 메모리 할당 등)<br>이러한 특성 때문에 OS를 조금 수정해줘야하는 단점이 있지만, 속도면에서는 당연히 더 빠르다는 장점이 있다</p><h2 id="virtual-machine-type2hosted"><a class="markdownIt-Anchor" href="#virtual-machine-type2hosted"></a> Virtual Machine Type2(hosted)</h2><p>호스트 운영체제 위에서 하이퍼바이저가 동작하는 방식이다<br>우리가 잘 아는 VMWare, VirtualBox 등이 여기 속한다<br>당연히 속도는 더 느리다</p><h1 id="컨테이너-가상화-기술"><a class="markdownIt-Anchor" href="#컨테이너-가상화-기술"></a> 컨테이너 가상화 기술?</h1><p>우리가 원하는건 특정 환경에 종속되지 않은 상태로 어플리케이션을 띄우는 것이다<br>하지만 말 그대로, 단순히 어플리케이션만을 띄우고 싶을 뿐인데 OS까지 띄우는것은 엄청난 낭비이다<br>하지만 이러한 요구를 만족시키기 위해선 <code>어플리케이션 격리</code>를 해결해야 한다</p><blockquote><p>필요한 것 : 격리된 CPU, 메모리, 디스크, 네트워크를 가진 공간을 만들고 이 공간에서 프로세스를 실행해서 유저에게 서비스</p></blockquote><h2 id="cgroup-namespace"><a class="markdownIt-Anchor" href="#cgroup-namespace"></a> Cgroup, namespace</h2><p>위의 필요한 부분을 달성하기 위해 사용한 대표적인 2가지 기술이다(리눅스 기술이다)</p><p>Croup는 CPU, 시스템 메모리, 네트워크 대역폭과 같은 자원을 시스템에서 실행 중인 프로세스에 할당할 수 있는 기술을 말한다<br>처음에는 process containers 라는 이름으로 구글에서 개발되었으나, 이후 Cgroup 으로 이름이 변경되었다<br>개발 이후 리눅스 메인 커널에 하나의 기능으로 들어갔다</p><p>namespace는 리소스들을 서로 다른 네임스페이스 그룹으로 나눠서, 서로 다른 네임스페이스에서는 볼 수 없다록 하는 기술이다<br>네임스페이스를 구성하는 방식에는 pid, uts, network 등등 총 6가지의 방법이 있다(?)</p><p>결과적으로 이 <code>Cgroup</code>와 <code>namespace</code>를 사용하여 <code>컨테이너</code>라는 기술이 탄생하게 된다</p><ul><li>Cgroup을 이용하여 프로세스에 리소스를 할당</li><li>namespace를 이용하여 리소스간 볼 수 없게하여 격리시킴</li></ul><blockquote><p>이 Cgroups, namespaces를 표준으로 정의해둔 것을 OCI 스펙이라고 하고, 도커에서 사용했던 LXC나 현재 사용하는 runC는 모두 이 스펙을 구현한 구현체이다</p></blockquote><hr><h1 id="도커란"><a class="markdownIt-Anchor" href="#도커란"></a> 도커란?</h1><p><strong>컨테이너 기반의 오픈소스 가상화 플랫폼</strong>을 말한다<br>앞서 언급했던 <code>컨테이너 가상화 기술</code>을 사용하는 것은 물론이고, 그것을 관리하기 위한 명령어들, 이미지 버전관리, 도커 레지스트리 등등의 많은 기능을 제공한다</p><blockquote><p>이곳에 잘 설명되어 있다 <a href="https://subicura.com/2017/01/19/docker-guide-for-beginners-1.html" rel="external nofollow noopener noreferrer" target="_blank">https://subicura.com/2017/01/19/docker-guide-for-beginners-1.html</a></p></blockquote><p>제공하는 기능 외에 도커의 주요 장점을 간단히 살펴보면 아래와 같다</p><h2 id="코드로-관리하는-인프라와-불변-인프라"><a class="markdownIt-Anchor" href="#코드로-관리하는-인프라와-불변-인프라"></a> 코드로 관리하는 인프라와 불변 인프라</h2><p>알다시피 애플리케이션 배포는 항상 <code>인프라의 가변성</code>을 포함하고 있어서 문제가 많다<br>(어플리케이션이 동일하더라도 배포하는 서버의 환경에 따라 여러가지 문제를 가져올 수 있다)<br>이러한 문제를 해결하는 가장 좋은 방법은 <code>애플리케이션이 의존하는 환경의 차이를 가능한 한 배제하는 것</code> 이다</p><p>도커는 특정 시점의 서버 상태를 복제하는 기능(docker image)과 이를 코드로 관리할 수 있는 기능(Dockerfile)을 제공한다<br>그리고 애플리케이션과 환경을 같이 묶어서 빌드할 수 있게 함으로써 기존에 존재하던 환경의 차이를 최소한으로 줄여버렸다</p><blockquote><p>이로인해 높은 이식성 또한 갖추게 되었다<br>빌드된 이미지는 도커가 설치된 머신이라면 어디서든 실행할 수 있기 때문이다</p></blockquote><h2 id="구성관리의-용이함"><a class="markdownIt-Anchor" href="#구성관리의-용이함"></a> 구성관리의 용이함</h2><p>일정규모를 넘는 시스템은 보통 여러개의 어플리케이션과 미들웨어를 조합하는 형태로 구성된다<br>도커를 사용한다고해도 이 부분은 여전히 어려운 문제이다</p><p>하지만 도커는 이 문제를 해결했다<br>설정파일을 사용하여 컨테이너 간 의존 관계와 시작 순서롤 제어할 수 있는 docker compose를 개발했고,<br>대규모 트래픽에 맞춰 어플리케이션을 오케스트레이션 해주는 docker swarm 을 개발했다<br>그리고 최근에는 끝판왕으로 등장한 구글의 <code>쿠버네티스</code>가 있다</p><p>이렇듯 도커는, 도커를 편리하게 사용할 수 있게 해주는 주변 도구가 잘 갖춰져 있다는 장점도 가지고 있다</p><blockquote><p>이러한 장점으로 도커는 굉장히 빠른 속도로 전파되어갔고, 사실상 표준(de fecto)가 되어 새로운 개발스타일을 많이 만들어내게 되었다</p></blockquote><h1 id="도커-설치-및-실행"><a class="markdownIt-Anchor" href="#도커-설치-및-실행"></a> 도커 설치 및 실행</h1><p>앞서 언급한 Cgroups, namespaces는 리눅스 기술이기 때문에 mac이나 Windows에서 바로 사용할 수 없다<br>그러므로 LinuxKit 이라는 경량 시스템을 실행하고, 그 위에서 컨테이너를 실행하는 구조로 동작한다<br>물론 직접 설치할 필요는 없고 mac, windows 용 도커 설치하고 실행 시 자동으로 같이 실행된다</p><p>설치 및 실행법은 좋은 글이 있어서 아래의 글로 대체한다<br><a href="https://subicura.com/2017/01/19/docker-guide-for-beginners-2.html" rel="external nofollow noopener noreferrer" target="_blank">https://subicura.com/2017/01/19/docker-guide-for-beginners-2.html</a></p><p>참고 :</p><ul><li><a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&amp;mallGb=KOR&amp;barcode=9791158391447&amp;orderClick=LEA&amp;Kc=" rel="external nofollow noopener noreferrer" target="_blank">야마다 아키노리, 『도커/쿠버네티스를 활용한 컨테이너 개발 실전 입문』, 심효섭 옮김, 위키북스(2019)</a></li><li><a href="https://www.joinc.co.kr/w/man/12/docker/InfrastructureForDocker/about" rel="external nofollow noopener noreferrer" target="_blank">https://www.joinc.co.kr/w/man/12/docker/InfrastructureForDocker/about</a></li><li><a href="https://tech.ssut.me/what-even-is-a-container/" rel="external nofollow noopener noreferrer" target="_blank">https://tech.ssut.me/what-even-is-a-container/</a></li></ul><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;기존의-가상화-기술&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#기존의-가상화-기술&quot;&gt;&lt;/a&gt; 기존의 가상화 기술&lt;/h1&gt;
&lt;p&gt;기존에 우리가 알고 있는 가상화는 하이퍼바이저(VMM)라는 기술을 이용하여 구현된 것이다&lt;br&gt;
하이퍼바이저는 호스트 컴퓨터에서 다수의 운영체제를 동시에 실행하기 위한 논리적 플랫폼을 말한다&lt;/p&gt;
&lt;p&gt;하이퍼바이저를 이용한 가상화 방식에는 크게 2가지가 있다&lt;/p&gt;
&lt;h2 id=&quot;virtual-machine-type1native&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#virtual-machine-type1native&quot;&gt;&lt;/a&gt; Virtual Machine Type1(native)&lt;/h2&gt;
&lt;p&gt;호스트 OS 없이 하이퍼바이저가 하드웨어 바로 위에서 직접 동작하는 방식이다&lt;br&gt;
중간에 OS가 없으므로 하드웨어에서 가상화 기술을 지원해줘야 하는 단점이 있지만, 요즘 CPU들은 대부분 가상화를 기본으로 지원하기 떄문에 그다지 단점이 되진 않는다&lt;/p&gt;
&lt;p&gt;type1에서도 구현방식이 또 2가지로 나뉜다&lt;/p&gt;
&lt;h3 id=&quot;전가상화&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#전가상화&quot;&gt;&lt;/a&gt; 전가상화&lt;/h3&gt;
&lt;p&gt;하드웨어 전체를 가상화한 뒤 가상머신을 올리는 방법을 말한다&lt;br&gt;
모든 가상머신의 요청은 항상 하이퍼바이저를 통해서 가게 된다&lt;/p&gt;
&lt;h3 id=&quot;반가상화&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#반가상화&quot;&gt;&lt;/a&gt; 반가상화&lt;/h3&gt;
&lt;p&gt;하드웨어 전체를 다 가상화하진 않는 방식을 말한다&lt;br&gt;
특정 요청은 하드웨어에 직접 요청가능하고, 특정 요청은 하이퍼바이저를 통해서만 가능하다(CPU, 메모리 할당 등)&lt;br&gt;
이러한 특성 때문에 OS를 조금 수정해줘야하는 단점이 있지만, 속도면에서는 당연히 더 빠르다는 장점이 있다&lt;/p&gt;
&lt;h2 id=&quot;virtual-machine-type2hosted&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#virtual-machine-type2hosted&quot;&gt;&lt;/a&gt; Virtual Machine Type2(hosted)&lt;/h2&gt;
&lt;p&gt;호스트 운영체제 위에서 하이퍼바이저가 동작하는 방식이다&lt;br&gt;
우리가 잘 아는 VMWare, VirtualBox 등이 여기 속한다&lt;br&gt;
당연히 속도는 더 느리다&lt;/p&gt;
&lt;h1 id=&quot;컨테이너-가상화-기술&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#컨테이너-가상화-기술&quot;&gt;&lt;/a&gt; 컨테이너 가상화 기술?&lt;/h1&gt;
&lt;p&gt;우리가 원하는건 특정 환경에 종속되지 않은 상태로 어플리케이션을 띄우는 것이다&lt;br&gt;
하지만 말 그대로, 단순히 어플리케이션만을 띄우고 싶을 뿐인데 OS까지 띄우는것은 엄청난 낭비이다&lt;br&gt;
하지만 이러한 요구를 만족시키기 위해선 &lt;code&gt;어플리케이션 격리&lt;/code&gt;를 해결해야 한다&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;필요한 것 : 격리된 CPU, 메모리, 디스크, 네트워크를 가진 공간을 만들고 이 공간에서 프로세스를 실행해서 유저에게 서비스&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;cgroup-namespace&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#cgroup-namespace&quot;&gt;&lt;/a&gt; Cgroup, namespace&lt;/h2&gt;
&lt;p&gt;위의 필요한 부분을 달성하기 위해 사용한 대표적인 2가지 기술이다(리눅스 기술이다)&lt;/p&gt;
&lt;p&gt;Croup는 CPU, 시스템 메모리, 네트워크 대역폭과 같은 자원을 시스템에서 실행 중인 프로세스에 할당할 수 있는 기술을 말한다&lt;br&gt;
처음에는 process containers 라는 이름으로 구글에서 개발되었으나, 이후 Cgroup 으로 이름이 변경되었다&lt;br&gt;
개발 이후 리눅스 메인 커널에 하나의 기능으로 들어갔다&lt;/p&gt;
&lt;p&gt;namespace는 리소스들을 서로 다른 네임스페이스 그룹으로 나눠서, 서로 다른 네임스페이스에서는 볼 수 없다록 하는 기술이다&lt;br&gt;
네임스페이스를 구성하는 방식에는 pid, uts, network 등등 총 6가지의 방법이 있다(?)&lt;/p&gt;
&lt;p&gt;결과적으로 이 &lt;code&gt;Cgroup&lt;/code&gt;와 &lt;code&gt;namespace&lt;/code&gt;를 사용하여 &lt;code&gt;컨테이너&lt;/code&gt;라는 기술이 탄생하게 된다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Cgroup을 이용하여 프로세스에 리소스를 할당&lt;/li&gt;
&lt;li&gt;namespace를 이용하여 리소스간 볼 수 없게하여 격리시킴&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;이 Cgroups, namespaces를 표준으로 정의해둔 것을 OCI 스펙이라고 하고, 도커에서 사용했던 LXC나 현재 사용하는 runC는 모두 이 스펙을 구현한 구현체이다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;도커란&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#도커란&quot;&gt;&lt;/a&gt; 도커란?&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;컨테이너 기반의 오픈소스 가상화 플랫폼&lt;/strong&gt;을 말한다&lt;br&gt;
앞서 언급했던 &lt;code&gt;컨테이너 가상화 기술&lt;/code&gt;을 사용하는 것은 물론이고, 그것을 관리하기 위한 명령어들, 이미지 버전관리, 도커 레지스트리 등등의 많은 기능을 제공한다&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;이곳에 잘 설명되어 있다 &lt;a href=&quot;https://subicura.com/2017/01/19/docker-guide-for-beginners-1.html&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;https://subicura.com/2017/01/19/docker-guide-for-beginners-1.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;제공하는 기능 외에 도커의 주요 장점을 간단히 살펴보면 아래와 같다&lt;/p&gt;
&lt;h2 id=&quot;코드로-관리하는-인프라와-불변-인프라&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#코드로-관리하는-인프라와-불변-인프라&quot;&gt;&lt;/a&gt; 코드로 관리하는 인프라와 불변 인프라&lt;/h2&gt;
&lt;p&gt;알다시피 애플리케이션 배포는 항상 &lt;code&gt;인프라의 가변성&lt;/code&gt;을 포함하고 있어서 문제가 많다&lt;br&gt;
(어플리케이션이 동일하더라도 배포하는 서버의 환경에 따라 여러가지 문제를 가져올 수 있다)&lt;br&gt;
이러한 문제를 해결하는 가장 좋은 방법은 &lt;code&gt;애플리케이션이 의존하는 환경의 차이를 가능한 한 배제하는 것&lt;/code&gt; 이다&lt;/p&gt;
&lt;p&gt;도커는 특정 시점의 서버 상태를 복제하는 기능(docker image)과 이를 코드로 관리할 수 있는 기능(Dockerfile)을 제공한다&lt;br&gt;
그리고 애플리케이션과 환경을 같이 묶어서 빌드할 수 있게 함으로써 기존에 존재하던 환경의 차이를 최소한으로 줄여버렸다&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;이로인해 높은 이식성 또한 갖추게 되었다&lt;br&gt;
빌드된 이미지는 도커가 설치된 머신이라면 어디서든 실행할 수 있기 때문이다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;구성관리의-용이함&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#구성관리의-용이함&quot;&gt;&lt;/a&gt; 구성관리의 용이함&lt;/h2&gt;
&lt;p&gt;일정규모를 넘는 시스템은 보통 여러개의 어플리케이션과 미들웨어를 조합하는 형태로 구성된다&lt;br&gt;
도커를 사용한다고해도 이 부분은 여전히 어려운 문제이다&lt;/p&gt;
&lt;p&gt;하지만 도커는 이 문제를 해결했다&lt;br&gt;
설정파일을 사용하여 컨테이너 간 의존 관계와 시작 순서롤 제어할 수 있는 docker compose를 개발했고,&lt;br&gt;
대규모 트래픽에 맞춰 어플리케이션을 오케스트레이션 해주는 docker swarm 을 개발했다&lt;br&gt;
그리고 최근에는 끝판왕으로 등장한 구글의 &lt;code&gt;쿠버네티스&lt;/code&gt;가 있다&lt;/p&gt;
&lt;p&gt;이렇듯 도커는, 도커를 편리하게 사용할 수 있게 해주는 주변 도구가 잘 갖춰져 있다는 장점도 가지고 있다&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;이러한 장점으로 도커는 굉장히 빠른 속도로 전파되어갔고, 사실상 표준(de fecto)가 되어 새로운 개발스타일을 많이 만들어내게 되었다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;도커-설치-및-실행&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#도커-설치-및-실행&quot;&gt;&lt;/a&gt; 도커 설치 및 실행&lt;/h1&gt;
&lt;p&gt;앞서 언급한 Cgroups, namespaces는 리눅스 기술이기 때문에 mac이나 Windows에서 바로 사용할 수 없다&lt;br&gt;
그러므로 LinuxKit 이라는 경량 시스템을 실행하고, 그 위에서 컨테이너를 실행하는 구조로 동작한다&lt;br&gt;
물론 직접 설치할 필요는 없고 mac, windows 용 도커 설치하고 실행 시 자동으로 같이 실행된다&lt;/p&gt;
&lt;p&gt;설치 및 실행법은 좋은 글이 있어서 아래의 글로 대체한다&lt;br&gt;
&lt;a href=&quot;https://subicura.com/2017/01/19/docker-guide-for-beginners-2.html&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;https://subicura.com/2017/01/19/docker-guide-for-beginners-2.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;참고 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&amp;amp;mallGb=KOR&amp;amp;barcode=9791158391447&amp;amp;orderClick=LEA&amp;amp;Kc=&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;야마다 아키노리, 『도커/쿠버네티스를 활용한 컨테이너 개발 실전 입문』, 심효섭 옮김, 위키북스(2019)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.joinc.co.kr/w/man/12/docker/InfrastructureForDocker/about&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;https://www.joinc.co.kr/w/man/12/docker/InfrastructureForDocker/about&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://tech.ssut.me/what-even-is-a-container/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;https://tech.ssut.me/what-even-is-a-container/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="docker" scheme="https://joont92.github.io/categories/docker/"/>
    
    
      <category term="docker" scheme="https://joont92.github.io/tags/docker/"/>
    
      <category term="도커/쿠버네티스를 활용한 컨테이너 개발 실전 입문" scheme="https://joont92.github.io/tags/%EB%8F%84%EC%BB%A4-%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EA%B0%9C%EB%B0%9C-%EC%8B%A4%EC%A0%84-%EC%9E%85%EB%AC%B8/"/>
    
      <category term="도커" scheme="https://joont92.github.io/tags/%EB%8F%84%EC%BB%A4/"/>
    
      <category term="가상화" scheme="https://joont92.github.io/tags/%EA%B0%80%EC%83%81%ED%99%94/"/>
    
      <category term="컨테이너 가상화" scheme="https://joont92.github.io/tags/%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EA%B0%80%EC%83%81%ED%99%94/"/>
    
  </entry>
  
  <entry>
    <title>[aws] VPC, subnet</title>
    <link href="https://joont92.github.io/aws/VPC-subnet/"/>
    <id>https://joont92.github.io/aws/VPC-subnet/</id>
    <published>2019-06-06T13:30:12.000Z</published>
    <updated>2020-11-02T10:09:30.449Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vpc"><a class="markdownIt-Anchor" href="#vpc"></a> VPC</h1><p>우리가 공유기 깔고 네트워크 구성하듯이, VPC는 AWS 내에서 논리적 가상 네트워크를 구성할 수 있는 기능을 말한다<br>EC2 인스턴스, RDS 인스턴스 같은 리소스들은 전부 VPC 내에 등록하게 되며, VPC에 ACL 적용, Security Group 적용 등 여러가지 보안 정책을 추가할 수 있다</p><blockquote><p>참고로 VPC 메뉴를 가면 이미 VPC가 하나 생성되어 있는것을 볼 수 있는데, 이는 AWS 계정 생성시 자동으로 생성되는 default VPC이다<br>172.31.0.0/16 대역을 사용하며 각 리전마다 1개씩 생성되어 있다(VPC는 리전을 기준으로 생성할 수 있다)<br>default VPC는 리전마다 1개만 설정할 수 있다</p></blockquote><p>VPC 메뉴로 가서 <code>Create VPC</code> 버튼을 눌러 간단하게 등록할 수 있다<br><img src="/temp/VPC-%EC%83%9D%EC%84%B1.png" alt="VPC 생성"></p><p>나만의 작은 IDC(혹은 공유기 환경) 생성한다고 생각하면 편하다<br>VPC 이름과 IP 대역(CIDR 형식)을 입력해줘서 간단히 생성할 수 있다</p><blockquote><p><strong>CIDR 형식</strong><br>서브넷 마스크를 2진수로 바꿨을 때 1의 개수를 나타낸다 e.g. 255.255.255.0 == 24<br>192.168.0.0 IP 대역을 사용하고, 255.255.255.0 의 서브넷마스크를 사용한다면 <code>192.168.0.0/24</code>와 같이 표기한다</p></blockquote><p>IP 대역에는 가상 네트워크를 구성할 것이기 IP 대역을 입력한다<br>RFC 1918에 정의된 사설 IP 대역을 입력해주면 된다(10.0.0.0 ~ 10.255.255.255, 172.16.0.0 ~ 172.31.255.255, 192.168.0.0 ~ 192.168.255.255)</p><blockquote><p>AWS에서는 이처럼 RFC 1918에 정의된 사설 IP 대역을 사용하는 것을 권장한다고 하는데, 공인 IP 대역을 입력할 수 있기나 한가?<br>공인 IP 대역을 사용하면 같은 공인 IP를 만났을 때 통신이 불가능하지 않는가?</p></blockquote><p>만약 192.168.0.0/16의 형태로 입력했다고 하면 해당 VPC는 192.168.0.1 ~ 192.168.255.254 까지의 IP 대역을 가지게 되는 것이다</p><blockquote><p>만약 이 IP 영역내에 AWS에서 사용하는 예약 IP가 있다면 이는 제외된다</p></blockquote><h1 id="서브넷"><a class="markdownIt-Anchor" href="#서브넷"></a> 서브넷</h1><p>아쉽게도 VPC에서 네트워크 대역을 설정했다고 해서 바로 그 대역을 사용할 수 있는것이 아니다<br>생성된 VPC 대역 내에서 실제로 사용할 대역을 추가로 설정하고, 어떤 AZ에 위치시킬지 설정하는 <code>서브넷</code>이라는 것을 하위에 추가로 만들어줘야 한다</p><blockquote><p>서브넷은 가용영역을 기준으로 생성한다</p></blockquote><p>아래는 AWS 계정 생성 시 자동으로 생성되는 default VPC 안에 들어있는 default 서브넷 목록이다<br><img src="/temp/default-%EC%84%9C%EB%B8%8C%EB%84%B7-%EB%AA%A9%EB%A1%9D.png" alt="default 서브넷 목록"></p><p>default VPC의 IP 대역대는 172.31.0.0/16 이었고(172.31.0.0 ~ 172.31.255.255),<br>이를 다시 3개로 쪼개서(CIDR 20) 각각 다른 AZ에 할당한 것을 볼 수 있다</p><blockquote><p>VPC 생성시에 172.31.0.0/20 으로 생성하면 자동으로 3개로 나눠질텐데, 굳이 이렇게 하는 이유는 AZ를 설정하기 위함일까?<br>그렇다면 위에서 CIDR 값을 받을 필요가 없지않나?</p></blockquote><p>이제 AWS 리소스를 생성할 때 이렇게 생성된 VPC와 서브넷 대역을 지정해주면 영역 내에서의 IP가 private IP로 리소스에 박히게 된다</p><blockquote><p>첫번째 서브넷을 선택하면 172.31.0.1 ~ 172.31.15.255 사이의 IP가 private IP로 박히게 된다</p></blockquote><p>리소스 자체에 public IP를 박을 수 있는데, 이는 어떻게 처리되는 것인지?<br>VPC에서 NAT를 수행해서 통신 가능하게끔 해주는 것인지?<br>게이트웨이, 라우팅테이블을 읽어보면 이 부분이 해소될 것 같다<br>추가로 ACL, SG 설정하는 부분도 봐야할 듯</p><p><a href="https://bcho.tistory.com/779" rel="external nofollow noopener noreferrer" target="_blank">https://bcho.tistory.com/779</a></p><ul><li>private, public subnet을 나누는 기준이 뭔가?<ul><li>외부 통신 기준인가?</li></ul></li><li>통신은 어떻게 하는가?</li><li>gateway에 ip가 많은 이유는 동적할당을 위해서?</li><li>VPC 의 CIDR 값은 서브넷 값을 더 크게 설정하지 못하기 위한 일종의 fence 같은 것</li></ul><p>AWS 계정 전용 가상 네트워크, AZ가 달라도 논리적으로 묶어서 VPC 형성 가능<br>다른 가상 네트워크들과 논리적으로 분리<br>서브넷은 VPC IP 주소 범위. AWS 리소스 생성시에는 VPC가 필요함<br>AWS 리소스 보호를 위해 ACL 등등을 서브넷에 설정할 수 있다<br>기본 VPC에는 인터넷 게이트웨이가 포함된다</p><p>퍼블릭 IP를 가진 인스턴스가 있는 서브넷의 경우 퍼블릭 서브넷이라고 부른다<br>라우터는 각각 서브넷 앞에 있어야하지… 않는가?<br>그러므로 VPN 연결되는 서브넷을 VPN 전용 서브넷이라고 하는것은 이해가 간다</p><p>퍼블릭 IP주소는 직접 지정해줘야하고, 프라이빗 IP 주소는 항상 있음<br>기본적인 공유기 환경에서 NAT 를 타고 인터넷에 접속하는것과는 다른 구조<br>VPC 내의 라우터는 VPC 내 서브넷간의 통신만을 담당한다<br>여기 인터넷 게이트웨이를 붙임으로써 외부 통신이 가능해진다</p><p>인터넷 게이트웨이는 외부와 private IP를 이어주는 역할인 것 같다<br>외부와 통신하려면 무조건 인터넷 게이트웨이를 연결해야한다<br>그러므로 VPC 내의 모든 인스턴스가 외부 통신을 가능하게 하려면 NAT 디바이스를 사용하고, 이를 인터넷 게이트웨이와 연결시켜 줘야한다</p><p>인터넷 게이트웨이는 private IP, public IP의 mapping 정도를 해주는 애라서 가장 바깥쪽(VPC)에 있다<br>서브넷은 각각 라우터를 가지는데, 여기에 NAT를 붙이고 다시 이 NAT가 인터넷 게이트웨이와 붙어서 서브넷 내의 모든 리소스들의 외부 통신이 가능해진다</p><p><strong>VPC 생성하면 Route Table, ACL, SG가 기본으로 생긴다</strong><br>기본세팅으로 설정되어 있음<br>라우트테이블의 경우 local 이 들어가있는데, 이는 서브넷간의 리소스들은 모두 통신할 수 있음을 말함</p><ul><li>Route Table<br>VPC 내의 서브넷간의 통신?<br>모든 서브넷은 생성시 private 서브넷으로 생성되고, 기본적으로 다른 서브넷간의 연결을 제한함<br>인터넷 게이트웨이를 만드려면 무조건 라우트테이블을 생성하고 등록해줘야한다<br>여기서 추가설정으로 서브넷간 통신이나 인터넷 게이트웨이 등을 연결할 수 있다</li></ul><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;vpc&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#vpc&quot;&gt;&lt;/a&gt; VPC&lt;/h1&gt;
&lt;p&gt;우리가 공유기 깔고 네트워크 구성하듯이, VPC는 AWS 내에서 논리적 가상 네트워크를 구성할 수 있는 기능을 말한다&lt;br&gt;
EC2 인스턴스, RDS 인스턴스 같은 리소스들은 전부 VPC 내에 등록하게 되며, VPC에 ACL 적용, Security Group 적용 등 여러가지 보안 정책을 추가할 수 있다&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;참고로 VPC 메뉴를 가면 이미 VPC가 하나 생성되어 있는것을 볼 수 있는데, 이는 AWS 계정 생성시 자동으로 생성되는 default VPC이다&lt;br&gt;
172.31.0.0/16 대역을 사용하며 각 리전마다 1개씩 생성되어 있다(VPC는 리전을 기준으로 생성할 수 있다)&lt;br&gt;
default VPC는 리전마다 1개만 설정할 수 있다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;VPC 메뉴로 가서 &lt;code&gt;Create VPC&lt;/code&gt; 버튼을 눌러 간단하게 등록할 수 있다&lt;br&gt;
&lt;img src=&quot;/temp/VPC-%EC%83%9D%EC%84%B1.png&quot; alt=&quot;VPC 생성&quot;&gt;&lt;/p&gt;
&lt;p&gt;나만의 작은 IDC(혹은 공유기 환경) 생성한다고 생각하면 편하다&lt;br&gt;
VPC 이름과 IP 대역(CIDR 형식)을 입력해줘서 간단히 생성할 수 있다&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;CIDR 형식&lt;/strong&gt;&lt;br&gt;
서브넷 마스크를 2진수로 바꿨을 때 1의 개수를 나타낸다 e.g. 255.255.255.0 == 24&lt;br&gt;
192.168.0.0 IP 대역을 사용하고, 255.255.255.0 의 서브넷마스크를 사용한다면 &lt;code&gt;192.168.0.0/24&lt;/code&gt;와 같이 표기한다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;IP 대역에는 가상 네트워크를 구성할 것이기 IP 대역을 입력한다&lt;br&gt;
RFC 1918에 정의된 사설 IP 대역을 입력해주면 된다(10.0.0.0 ~ 10.255.255.255, 172.16.0.0 ~ 172.31.255.255, 192.168.0.0 ~ 192.168.255.255)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;AWS에서는 이처럼 RFC 1918에 정의된 사설 IP 대역을 사용하는 것을 권장한다고 하는데, 공인 IP 대역을 입력할 수 있기나 한가?&lt;br&gt;
공인 IP 대역을 사용하면 같은 공인 IP를 만났을 때 통신이 불가능하지 않는가?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;만약 192.168.0.0/16의 형태로 입력했다고 하면 해당 VPC는 192.168.0.1 ~ 192.168.255.254 까지의 IP 대역을 가지게 되는 것이다&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;만약 이 IP 영역내에 AWS에서 사용하는 예약 IP가 있다면 이는 제외된다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;서브넷&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#서브넷&quot;&gt;&lt;/a&gt; 서브넷&lt;/h1&gt;
&lt;p&gt;아쉽게도 VPC에서 네트워크 대역을 설정했다고 해서 바로 그 대역을 사용할 수 있는것이 아니다&lt;br&gt;
생성된 VPC 대역 내에서 실제로 사용할 대역을 추가로 설정하고, 어떤 AZ에 위치시킬지 설정하는 &lt;code&gt;서브넷&lt;/code&gt;이라는 것을 하위에 추가로 만들어줘야 한다&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;서브넷은 가용영역을 기준으로 생성한다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;아래는 AWS 계정 생성 시 자동으로 생성되는 default VPC 안에 들어있는 default 서브넷 목록이다&lt;br&gt;
&lt;img src=&quot;/temp/default-%EC%84%9C%EB%B8%8C%EB%84%B7-%EB%AA%A9%EB%A1%9D.png&quot; alt=&quot;default 서브넷 목록&quot;&gt;&lt;/p&gt;
&lt;p&gt;default VPC의 IP 대역대는 172.31.0.0/16 이었고(172.31.0.0 ~ 172.31.255.255),&lt;br&gt;
이를 다시 3개로 쪼개서(CIDR 20) 각각 다른 AZ에 할당한 것을 볼 수 있다&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;VPC 생성시에 172.31.0.0/20 으로 생성하면 자동으로 3개로 나눠질텐데, 굳이 이렇게 하는 이유는 AZ를 설정하기 위함일까?&lt;br&gt;
그렇다면 위에서 CIDR 값을 받을 필요가 없지않나?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이제 AWS 리소스를 생성할 때 이렇게 생성된 VPC와 서브넷 대역을 지정해주면 영역 내에서의 IP가 private IP로 리소스에 박히게 된다&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;첫번째 서브넷을 선택하면 172.31.0.1 ~ 172.31.15.255 사이의 IP가 private IP로 박히게 된다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;리소스 자체에 public IP를 박을 수 있는데, 이는 어떻게 처리되는 것인지?&lt;br&gt;
VPC에서 NAT를 수행해서 통신 가능하게끔 해주는 것인지?&lt;br&gt;
게이트웨이, 라우팅테이블을 읽어보면 이 부분이 해소될 것 같다&lt;br&gt;
추가로 ACL, SG 설정하는 부분도 봐야할 듯&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://bcho.tistory.com/779&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;https://bcho.tistory.com/779&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;private, public subnet을 나누는 기준이 뭔가?
&lt;ul&gt;
&lt;li&gt;외부 통신 기준인가?&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;통신은 어떻게 하는가?&lt;/li&gt;
&lt;li&gt;gateway에 ip가 많은 이유는 동적할당을 위해서?&lt;/li&gt;
&lt;li&gt;VPC 의 CIDR 값은 서브넷 값을 더 크게 설정하지 못하기 위한 일종의 fence 같은 것&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;AWS 계정 전용 가상 네트워크, AZ가 달라도 논리적으로 묶어서 VPC 형성 가능&lt;br&gt;
다른 가상 네트워크들과 논리적으로 분리&lt;br&gt;
서브넷은 VPC IP 주소 범위. AWS 리소스 생성시에는 VPC가 필요함&lt;br&gt;
AWS 리소스 보호를 위해 ACL 등등을 서브넷에 설정할 수 있다&lt;br&gt;
기본 VPC에는 인터넷 게이트웨이가 포함된다&lt;/p&gt;
&lt;p&gt;퍼블릭 IP를 가진 인스턴스가 있는 서브넷의 경우 퍼블릭 서브넷이라고 부른다&lt;br&gt;
라우터는 각각 서브넷 앞에 있어야하지… 않는가?&lt;br&gt;
그러므로 VPN 연결되는 서브넷을 VPN 전용 서브넷이라고 하는것은 이해가 간다&lt;/p&gt;
&lt;p&gt;퍼블릭 IP주소는 직접 지정해줘야하고, 프라이빗 IP 주소는 항상 있음&lt;br&gt;
기본적인 공유기 환경에서 NAT 를 타고 인터넷에 접속하는것과는 다른 구조&lt;br&gt;
VPC 내의 라우터는 VPC 내 서브넷간의 통신만을 담당한다&lt;br&gt;
여기 인터넷 게이트웨이를 붙임으로써 외부 통신이 가능해진다&lt;/p&gt;
&lt;p&gt;인터넷 게이트웨이는 외부와 private IP를 이어주는 역할인 것 같다&lt;br&gt;
외부와 통신하려면 무조건 인터넷 게이트웨이를 연결해야한다&lt;br&gt;
그러므로 VPC 내의 모든 인스턴스가 외부 통신을 가능하게 하려면 NAT 디바이스를 사용하고, 이를 인터넷 게이트웨이와 연결시켜 줘야한다&lt;/p&gt;
&lt;p&gt;인터넷 게이트웨이는 private IP, public IP의 mapping 정도를 해주는 애라서 가장 바깥쪽(VPC)에 있다&lt;br&gt;
서브넷은 각각 라우터를 가지는데, 여기에 NAT를 붙이고 다시 이 NAT가 인터넷 게이트웨이와 붙어서 서브넷 내의 모든 리소스들의 외부 통신이 가능해진다&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;VPC 생성하면 Route Table, ACL, SG가 기본으로 생긴다&lt;/strong&gt;&lt;br&gt;
기본세팅으로 설정되어 있음&lt;br&gt;
라우트테이블의 경우 local 이 들어가있는데, 이는 서브넷간의 리소스들은 모두 통신할 수 있음을 말함&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Route Table&lt;br&gt;
VPC 내의 서브넷간의 통신?&lt;br&gt;
모든 서브넷은 생성시 private 서브넷으로 생성되고, 기본적으로 다른 서브넷간의 연결을 제한함&lt;br&gt;
인터넷 게이트웨이를 만드려면 무조건 라우트테이블을 생성하고 등록해줘야한다&lt;br&gt;
여기서 추가설정으로 서브넷간 통신이나 인터넷 게이트웨이 등을 연결할 수 있다&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="aws" scheme="https://joont92.github.io/categories/aws/"/>
    
    
      <category term="AWS" scheme="https://joont92.github.io/tags/AWS/"/>
    
      <category term="VPC" scheme="https://joont92.github.io/tags/VPC/"/>
    
      <category term="subnet" scheme="https://joont92.github.io/tags/subnet/"/>
    
  </entry>
  
  <entry>
    <title>[aws] region, az</title>
    <link href="https://joont92.github.io/aws/region-az/"/>
    <id>https://joont92.github.io/aws/region-az/</id>
    <published>2019-06-03T23:31:15.000Z</published>
    <updated>2020-11-02T10:09:30.449Z</updated>
    
    <content type="html"><![CDATA[<h1 id="region"><a class="markdownIt-Anchor" href="#region"></a> region</h1><ul><li>AWS의 모든 서비스(리소스)가 위치하고 있는 물리적인 장소<ul><li>정확히 물리적인 장소는 아니고 조금은 추상적 개념</li></ul></li><li>네트워크 기술이 아무리 발전했더라도, 물리적으로 먼 거리는 시간이 많이 걸릴 수 밖에 없음<ul><li>경유하는 라우터의 개수가 많기 떄문</li><li>어떻게든 물리적인 거리를 좁히는게 최적의 방법임</li><li>리전을 바꾸고 테스트해보면 속도차이를 확실히 느낄 수 있음 <a href="https://dezang.github.io/aws-ping-latency-check/" rel="external nofollow noopener noreferrer" target="_blank">https://dezang.github.io/aws-ping-latency-check/</a></li></ul></li><li>전 세계 주요 지역에 위치하고 있음<ul><li><a href="https://aws.amazon.com/ko/about-aws/global-infrastructure/" rel="external nofollow noopener noreferrer" target="_blank">https://aws.amazon.com/ko/about-aws/global-infrastructure/</a></li></ul></li><li>서비스가 크다면 자연재해 등을 대비하여 여러 리전을 사용하는것을 권장함<ul><li>seoul 리전이 맛탱이 갔을때 쿠팡, 배민 등의 서비스가 모두 중지되었었다</li><li>영업 손실이 보통 수준이 아니었을 것이다</li></ul></li><li>리전간 리소스는 공유되지 않음<ul><li>리전간 리소스 복사는 가능함</li></ul></li><li>계정당 액세스 할 수 있는 리전이 정해져있다?<ul><li>한국은 여러곳에 열려있다?</li><li>e.g. 중국은 몇몇 지역 접근 못함</li><li>각자가 사용할 수 있는 리전과 가용영역이 있다</li></ul></li></ul><h1 id="가용영역az-avaliability-zone"><a class="markdownIt-Anchor" href="#가용영역az-avaliability-zone"></a> 가용영역(AZ, Avaliability Zone)</h1><ul><li>실질적으로 IDC 센터가 위치하는 장소<ul><li>리전은 여러개의 AZ를 가짐</li><li>Seoul 리전이라고 해서 서울에 IDC가 있는것이 아님<ul><li>수도이기 때문에 그렇게 표기한 것임</li></ul></li><li>가용영역의 위치가 실제 IDC가 있는 위치임</li><li>Seoul 리전의 경우 3개의 AZ가 있는데, 이는 한국에 AWS IDC가 3군데 있음을 뜻함<ul><li>가용영역의 위치는 비공개임</li><li>물리적 피해를 막기 위함</li></ul></li></ul></li><li>가용영역간 fail over를 elastic IP로 해결할 수 있다?</li><li>리소스가 리전의 가용 영역에 걸쳐 배포될 수 있도록 AWS는 각 AWS 계정의 이름에 가용 영역을 독립적으로 매핑합니다. 예를 들어 AWS 계정의 us-east-1a 가용 영역은 다른 AWS 계정에 대한 us-east-1a 가용 영역과 위치가 동일하지 않을 수 있습니다<ul><li>1a가 특정 위치를 명시하는게 아닐 수 있음을 말하는 듯?</li><li>AZ ID를 설정하면 특정 위치를 아예 지정할 수 있다</li></ul></li><li>이번 AZ 추가가 테라폼 설정에 왜 문제가 되었을까?</li></ul><hr><ul><li>AZ간 통신은 가능한가?</li><li>리전간 통신은 가능한가?</li><li>AZ간 VPC는 묶지만, 리전간은 안된다?</li><li>리전간 failover는 가능한가?<ul><li>리전간 스위칭이 가능한가?(seoul -&gt; tokyo)</li><li>최종 도메인에 연결되는 AWS 주소를 바꿔주면 될 듯 하다<ul><li>데이터베이스 동기화는 어떻게하는가?</li></ul></li></ul></li><li>AZ가 망가지는 경우?</li><li>리전이 망가지는 경우?</li><li>컨테이너 4개를 띄운다고 하면 2개는 2a에 2개는 2c에?</li><li>가용영역에 영향받을 수 있는 리소스들은 가용영역을 선택하지 않는다<ul><li>아마도 모든 가용영역끼리 복사되어있지 않을까?</li><li>e.g. Elastic Beanstalk 등</li></ul></li><li>beanstalk 은 가용영역이 없고 ec2 를 가용영역을 선택해서 띄운다</li><li>loadbalancer에서 az 범위 선택하고 그 범위 내에서 로드밸런싱</li></ul><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;region&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#region&quot;&gt;&lt;/a&gt; region&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;AWS의 모든 서비스(리소스)가 위치하고 있는 물리적인 장소
&lt;ul&gt;
&lt;li&gt;정확히 물리적인 장소는 아니고 조금은 추상적 개념&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;네트워크 기술이 아무리 발전했더라도, 물리적으로 먼 거리는 시간이 많이 걸릴 수 밖에 없음
&lt;ul&gt;
&lt;li&gt;경유하는 라우터의 개수가 많기 떄문&lt;/li&gt;
&lt;li&gt;어떻게든 물리적인 거리를 좁히는게 최적의 방법임&lt;/li&gt;
&lt;li&gt;리전을 바꾸고 테스트해보면 속도차이를 확실히 느낄 수 있음 &lt;a href=&quot;https://dezang.github.io/aws-ping-latency-check/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;https://dezang.github.io/aws-ping-latency-check/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;전 세계 주요 지역에 위치하고 있음
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://aws.amazon.com/ko/about-aws/global-infrastructure/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;https://aws.amazon.com/ko/about-aws/global-infrastructure/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;서비스가 크다면 자연재해 등을 대비하여 여러 리전을 사용하는것을 권장함
&lt;ul&gt;
&lt;li&gt;seoul 리전이 맛탱이 갔을때 쿠팡, 배민 등의 서비스가 모두 중지되었었다&lt;/li&gt;
&lt;li&gt;영업 손실이 보통 수준이 아니었을 것이다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;리전간 리소스는 공유되지 않음
&lt;ul&gt;
&lt;li&gt;리전간 리소스 복사는 가능함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;계정당 액세스 할 수 있는 리전이 정해져있다?
&lt;ul&gt;
&lt;li&gt;한국은 여러곳에 열려있다?&lt;/li&gt;
&lt;li&gt;e.g. 중국은 몇몇 지역 접근 못함&lt;/li&gt;
&lt;li&gt;각자가 사용할 수 있는 리전과 가용영역이 있다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;가용영역az-avaliability-zone&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#가용영역az-avaliability-zone&quot;&gt;&lt;/a&gt; 가용영역(AZ, Avaliability Zone)&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;실질적으로 IDC 센터가 위치하는 장소
&lt;ul&gt;
&lt;li&gt;리전은 여러개의 AZ를 가짐&lt;/li&gt;
&lt;li&gt;Seoul 리전이라고 해서 서울에 IDC가 있는것이 아님
&lt;ul&gt;
&lt;li&gt;수도이기 때문에 그렇게 표기한 것임&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;가용영역의 위치가 실제 IDC가 있는 위치임&lt;/li&gt;
&lt;li&gt;Seoul 리전의 경우 3개의 AZ가 있는데, 이는 한국에 AWS IDC가 3군데 있음을 뜻함
&lt;ul&gt;
&lt;li&gt;가용영역의 위치는 비공개임&lt;/li&gt;
&lt;li&gt;물리적 피해를 막기 위함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;가용영역간 fail over를 elastic IP로 해결할 수 있다?&lt;/li&gt;
&lt;li&gt;리소스가 리전의 가용 영역에 걸쳐 배포될 수 있도록 AWS는 각 AWS 계정의 이름에 가용 영역을 독립적으로 매핑합니다. 예를 들어 AWS 계정의 us-east-1a 가용 영역은 다른 AWS 계정에 대한 us-east-1a 가용 영역과 위치가 동일하지 않을 수 있습니다
&lt;ul&gt;
&lt;li&gt;1a가 특정 위치를 명시하는게 아닐 수 있음을 말하는 듯?&lt;/li&gt;
&lt;li&gt;AZ ID를 설정하면 특정 위치를 아예 지정할 수 있다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;이번 AZ 추가가 테라폼 설정에 왜 문제가 되었을까?&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;AZ간 통신은 가능한가?&lt;/li&gt;
&lt;li&gt;리전간 통신은 가능한가?&lt;/li&gt;
&lt;li&gt;AZ간 VPC는 묶지만, 리전간은 안된다?&lt;/li&gt;
&lt;li&gt;리전간 failover는 가능한가?
&lt;ul&gt;
&lt;li&gt;리전간 스위칭이 가능한가?(seoul -&amp;gt; tokyo)&lt;/li&gt;
&lt;li&gt;최종 도메인에 연결되는 AWS 주소를 바꿔주면 될 듯 하다
&lt;ul&gt;
&lt;li&gt;데이터베이스 동기화는 어떻게하는가?&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;AZ가 망가지는 경우?&lt;/li&gt;
&lt;li&gt;리전이 망가지는 경우?&lt;/li&gt;
&lt;li&gt;컨테이너 4개를 띄운다고 하면 2개는 2a에 2개는 2c에?&lt;/li&gt;
&lt;li&gt;가용영역에 영향받을 수 있는 리소스들은 가용영역을 선택하지 않는다
&lt;ul&gt;
&lt;li&gt;아마도 모든 가용영역끼리 복사되어있지 않을까?&lt;/li&gt;
&lt;li&gt;e.g. Elastic Beanstalk 등&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;beanstalk 은 가용영역이 없고 ec2 를 가용영역을 선택해서 띄운다&lt;/li&gt;
&lt;li&gt;loadbalancer에서 az 범위 선택하고 그 범위 내에서 로드밸런싱&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="aws" scheme="https://joont92.github.io/categories/aws/"/>
    
    
  </entry>
  
  <entry>
    <title>매개변수 제거</title>
    <link href="https://joont92.github.io/refactoring/%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98-%EC%A0%9C%EA%B1%B0/"/>
    <id>https://joont92.github.io/refactoring/매개변수-제거/</id>
    <published>2019-06-01T11:33:27.000Z</published>
    <updated>2020-11-02T10:09:30.457Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>메서드가 어떤 매개변수를 더 이상 사용하지 않을 땐 그 매개변수를 삭제하자</p></blockquote><h1 id="동기"><a class="markdownIt-Anchor" href="#동기"></a> 동기</h1><ul><li>프로그래머는 매개변수 추가는 부담없이 하면서도 매개변수 삭제는 꺼린다<ul><li>껍데기뿐인 매개변수를 놔둔다고 문제가 생기진 않을테고, 혹시 나중에 다시 필요할수도 있다는 <strong>자기합리화</strong> 때문이다</li></ul></li><li>매개변수는 필요한 정보를 나타낸다<ul><li>호출 부분에서 무슨 값을 전달할지 신중해야 한다</li><li>매개변수를 제거하지 않으면 그 메서드를 사용하는 모든곳이 불필요한 추가 작업을 수행하게 된다</li><li>이는 매우 혹독한 대가이고, 매개변수 제거가 어렵지 않다라는 사실을 생각하면 더욱 혹독한 대가이다</li></ul></li></ul><h1 id="방법"><a class="markdownIt-Anchor" href="#방법"></a> 방법</h1><ol><li>메서드 시그니쳐가 상위클래스나 하위클래스에 선언되어 있는지 검사한다<ul><li><strong>재정의 된 곳에서 해당 매개변수를 사용하지 않는지 확인해봐야 한다</strong></li><li>메서드 추가나 메서드 변경보다 좀 더 신중해야한다</li></ul></li><li>매개변수를 제거한 새 메서드를 선언하고, 원본 메서드의 내용을 복사한다</li><li>원본 메서드에서 새 메서드를 호출하도록 수정한다<ul><li>참조하는 부분이 별로 없다면 생략 가능하다</li></ul></li><li>원본 메서드 호출 부분을 전부 찾아서 새 메서드 호출로 바꾼다</li><li>원본 메서드를 삭제한다<ul><li>원본 메서드의 모든 호출 부분에 접근할 수 없다면 <code>@Deprecated</code>로 표시한다</li></ul></li></ol><p>참고 : <a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&amp;mallGb=KOR&amp;barcode=9788979149715&amp;orderClick=LAG&amp;Kc=" rel="external nofollow noopener noreferrer" target="_blank">마틴 파울러, 『리팩토링』, 김지원 옮김, 한빛미디어(2012)</a></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;메서드가 어떤 매개변수를 더 이상 사용하지 않을 땐 그 매개변수를 삭제하자&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;동기&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#동기&quot;&gt;&lt;/a&gt; 동기&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;프로그래머는 매개변수 추가는 부담없이 하면서도 매개변수 삭제는 꺼린다
&lt;ul&gt;
&lt;li&gt;껍데기뿐인 매개변수를 놔둔다고 문제가 생기진 않을테고, 혹시 나중에 다시 필요할수도 있다는 &lt;strong&gt;자기합리화&lt;/strong&gt; 때문이다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;매개변수는 필요한 정보를 나타낸다
&lt;ul&gt;
&lt;li&gt;호출 부분에서 무슨 값을 전달할지 신중해야 한다&lt;/li&gt;
&lt;li&gt;매개변수를 제거하지 않으면 그 메서드를 사용하는 모든곳이 불필요한 추가 작업을 수행하게 된다&lt;/li&gt;
&lt;li&gt;이는 매우 혹독한 대가이고, 매개변수 제거가 어렵지 않다라는 사실을 생각하면 더욱 혹독한 대가이다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;방법&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#방법&quot;&gt;&lt;/a&gt; 방법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;메서드 시그니쳐가 상위클래스나 하위클래스에 선언되어 있는지 검사한다
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;재정의 된 곳에서 해당 매개변수를 사용하지 않는지 확인해봐야 한다&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;메서드 추가나 메서드 변경보다 좀 더 신중해야한다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;매개변수를 제거한 새 메서드를 선언하고, 원본 메서드의 내용을 복사한다&lt;/li&gt;
&lt;li&gt;원본 메서드에서 새 메서드를 호출하도록 수정한다
&lt;ul&gt;
&lt;li&gt;참조하는 부분이 별로 없다면 생략 가능하다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;원본 메서드 호출 부분을 전부 찾아서 새 메서드 호출로 바꾼다&lt;/li&gt;
&lt;li&gt;원본 메서드를 삭제한다
&lt;ul&gt;
&lt;li&gt;원본 메서드의 모든 호출 부분에 접근할 수 없다면 &lt;code&gt;@Deprecated&lt;/code&gt;로 표시한다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;참고 : &lt;a href=&quot;http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&amp;amp;mallGb=KOR&amp;amp;barcode=9788979149715&amp;amp;orderClick=LAG&amp;amp;Kc=&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;마틴 파울러, 『리팩토링』, 김지원 옮김, 한빛미디어(2012)&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="refactoring" scheme="https://joont92.github.io/categories/refactoring/"/>
    
    
      <category term="리팩토링" scheme="https://joont92.github.io/tags/%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81/"/>
    
      <category term="remove parameter" scheme="https://joont92.github.io/tags/remove-parameter/"/>
    
  </entry>
  
  <entry>
    <title>[ddd] 리포지터리와 모델구현(JPA)</title>
    <link href="https://joont92.github.io/ddd/%EB%A6%AC%ED%8F%AC%EC%A7%80%ED%84%B0%EB%A6%AC%EC%99%80-%EB%AA%A8%EB%8D%B8%EA%B5%AC%ED%98%84-JPA/"/>
    <id>https://joont92.github.io/ddd/리포지터리와-모델구현-JPA/</id>
    <published>2019-05-29T22:14:21.000Z</published>
    <updated>2020-11-02T10:09:30.453Z</updated>
    
    <content type="html"><![CDATA[<p>데이터 보관소로 RDBMS를 사용할 때 객체 기반의 도메인 모델과 관계형 데이터 모델간의 매핑을 처리하는 기술로 ORM 만한 것이 없다</p><h1 id="리파지토리-구현"><a class="markdownIt-Anchor" href="#리파지토리-구현"></a> 리파지토리 구현</h1><h2 id="모듈-위치"><a class="markdownIt-Anchor" href="#모듈-위치"></a> 모듈 위치</h2><p>리포지터리 인터페이스는 애그리거트와 같이 도메인 영역에 속하고, 리포지터리를 구현한 클래스는 인프라스트럭쳐 영역에 속한다</p><blockquote><p>리포지터리 구현 클래스를 domain.impl 같은 패키지에 위치시키는 것은 좋은 설계 방법이 아니다</p></blockquote><h2 id="기본-기능-구현"><a class="markdownIt-Anchor" href="#기본-기능-구현"></a> 기본 기능 구현</h2><p>리포지터리의 기본 기능은 다음 2가지 이다</p><ul><li>아이디로 애그리거트 조회</li><li>애그리거트 저장</li></ul><p>이를 제공하는 인터페이스의 형식은 다음과 같다</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">OrderRepository</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Order <span class="title">findById</span><span class="params">(OrderNo no)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Order order)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>인터페이스는 애그리거트 루트를 기준으로 작성한다</li><li>애그리거트를 조회하는 기능의 이름을 지을 때 널리 사용되는 규칙은 <code>findBy프로퍼티(프로퍼티 값)</code> 의 형식을 사용하는 것이다<ul><li>e.g. findById, findByName, findByOrdererId</li><li>ID가 아닌 값으로 조회할때는 JPQL을 이용한다</li></ul></li><li>조회에 해당하는 애그리거트가 존재하면 애그리거트 도메인(e.g. Order)를 반환하고, 존재하지 않는다면 null이나 Optional을 반환한다</li><li>1건이상 존재하면 List 컬렉션을 반환한다</li><li>JPA는 트랜잭션 범위에서 변경한 데이터를 자동으로 DB에 반영하므로 따로 수정 메서드를 추가할 필요없다</li><li>삭제 기능을 구현한다면 삭제할 애그리거트 객체를 파라미터로 전달받게끔 한다<ul><li>soft delete로 구현하는 것이 좋다</li></ul></li></ul><h1 id="모델매핑-구현"><a class="markdownIt-Anchor" href="#모델매핑-구현"></a> 모델(매핑) 구현</h1><h2 id="기본-매핑"><a class="markdownIt-Anchor" href="#기본-매핑"></a> 기본 매핑</h2><p><img src="/temp/%EC%97%94%ED%8B%B0%ED%8B%B0%EC%99%80-%EB%B2%A8%EB%A5%98%EA%B0%80-%ED%95%9C-%ED%85%8C%EC%9D%B4%EB%B8%94%EC%97%90-%EB%A7%A4%ED%95%91.png" alt="엔티티와 벨류가 한 테이블에 매핑"></p><ul><li><p>애그리거트 루트는 엔티티이므로 <code>@Entity</code>로 매핑한다</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>벨류는 <code>@Embeddable</code>로 매핑한다</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Embeddable</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orderer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>밸류를 사용하는 곳에서는 <code>@Embedded</code>로 매핑한다</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Embedded</span></span><br><span class="line">    <span class="keyword">private</span> Orderer orderer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>벨류가 다른 벨류를 포함할 수 있다</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Embeddable</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orderer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Embedded</span></span><br><span class="line">    <span class="keyword">private</span> MemberId memberId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>데이터베이스 컬럼명이 다를 경우 <code>@AttributeOverride(s)</code> 어노테이션을 사용한다</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Embeddable</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShippigInfo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Embedded</span></span><br><span class="line">    <span class="meta">@AttributeOverrides</span>(&#123;</span><br><span class="line">        <span class="meta">@AttributeOverride</span>(name = <span class="string">"zipcode"</span>, column = <span class="meta">@Column</span>(name=<span class="string">"shipping_zipcode"</span>)),</span><br><span class="line">        <span class="meta">@AttributeOverride</span>(name = <span class="string">"address1"</span>, column = <span class="meta">@Column</span>(name=<span class="string">"shipping_address1"</span>)),</span><br><span class="line">        <span class="meta">@AttributeOverride</span>(name = <span class="string">"address2"</span>, column = <span class="meta">@Column</span>(name=<span class="string">"shipping_address2"</span>)),</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="기본-생성자"><a class="markdownIt-Anchor" href="#기본-생성자"></a> 기본 생성자</h2><p>생성자는 기본적으로 객체를 생성할 때 필요한 것을 받는 용도로 사용되는 것이다</p><blockquote><p>벨류 오브젝트의 경우 생성 시점에 모든 값을 전달받고, setter를 제공하지 않으므로, 기본 생성자가 필요없다</p></blockquote><p>하지만 JPA의 <code>@Entity</code>나 <code>@Embeddable</code>을 사용하려면 기본 생성자를 제공해야한다</p><blockquote><p>기존 객체를 상속한 프록시 객체를 사용하여 지연로딩 기능을 구현하기 때문이다</p></blockquote><p>이러한 이유 때문에 기본 생성자를 추가해줘야하는데, 알다시피 기본 생성자를 추가하면 객체가 온전하지 못한 상태로 제공될 수 있게된다<br>그러므로 기본 생성자를 <code>protected</code>로 선언해서 상속한 프록시 객체에서만 사용할 수 있게 해야한다</p><h2 id="필드-접근-방식-사용"><a class="markdownIt-Anchor" href="#필드-접근-방식-사용"></a> 필드 접근 방식 사용</h2><p>JPA는 기본적으로 필드와 메서드(프로퍼티)의 두가지 방식으로 매핑을 처리할 수 있다</p><ul><li><p>필드</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Access</span>(AccessType.FIELD)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"state"</span>)</span><br><span class="line">    <span class="meta">@Enumberated</span>(EnumType.STRING)</span><br><span class="line">    <span class="keyword">private</span> OrderState state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>메서드(프로퍼티)</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Access</span>(AccessType.PROPERTY)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"state"</span>)</span><br><span class="line">    <span class="meta">@Enumerated</span>(EnumType.STRING)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> OrderState <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(OrderState state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>하이버네이트는 <code>@Access</code>가 없으면 <code>@Id</code>나 <code>@EmbeddedId</code>를 보고 접근 방식을 결정한다</p></blockquote><p>공개 getter/setter를 추가하는 <code>메서드(프로퍼티)</code> 방식을 사용하게 되면 도메인의 의도가 사라지고, 객체가 아닌 데이터 기반으로 엔티티를 구현할 가능성이 높아지게 된다<br>그러므로 가능하다면 <code>필드</code> 방식을 사용해서 객체가 제공할 기능 중심으로 구현하게끔 해야한다</p><h2 id="attributeconverter를-이용한-벨류-매핑"><a class="markdownIt-Anchor" href="#attributeconverter를-이용한-벨류-매핑"></a> AttributeConverter를 이용한 벨류 매핑</h2><p>개발하다보면 가끔 벨류 프로퍼티 하나를 한 개 컬럼에 매핑해야 할 때가 있다</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 이 벨류 오브젝트를 DB 컬럼 "WIDTH VARCHAR(20)" 에 매핑</span></span><br><span class="line"><span class="comment"> * e.g. 1000mm</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Length</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">private</span> String unit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이럴땐 JPA 2.1 이후로 추가된 <code>AttributeConverter</code>를 이용하면 된다</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AttributeConverter</span>&lt;<span class="title">X</span>, <span class="title">Y</span>&gt; </span>&#123; <span class="comment">// X = 벨류 타입, Y = DB 타입</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Y <span class="title">convertToDatabaseColumn</span><span class="params">(X attribute)</span></span>; <span class="comment">// 벨류 타입 -&gt; DB 컬럼 값</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Y <span class="title">convertToEntityAttribute</span><span class="params">(Y dbData)</span></span>; <span class="comment">// DB 컬럼 값 -&gt; 벨류 타입</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MoneyConverter</span> <span class="keyword">implements</span> <span class="title">AttributeConverter</span>&lt;<span class="title">Money</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">converToDatabaseColumn</span><span class="params">(Money money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> money.getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Money <span class="title">convertToEntityAttribute</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Money(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>작성한 컨버터를 적용시키려면 아래 2가지 방법을 사용하면 된다<br>(컨버터를 사용했기 때문에 <code>@Embedded</code>를 사용하지 않고 <code>@Column</code>으로 직접 매핑한다)</p><ul><li><p>특정 시점에만 적용</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"totalAmounts"</span>)</span><br><span class="line">    <span class="meta">@Converter</span>(converter = MoneyConverter.class)</span><br><span class="line">    <span class="keyword">private</span> Money totalAmounts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>리포지터리로 Order 를 handling 할 때 적용된다</p></blockquote></li><li><p>모든 벨류 오브젝트에 적용</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Converter</span>(autoApply = <span class="keyword">true</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MoneyConverter</span> <span class="keyword">implements</span> <span class="title">AttributeConverter</span>&lt;<span class="title">Money</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>모든 <code>Money</code> 타입 프로퍼티에 자동 적용된다</p></blockquote></li></ul><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;데이터 보관소로 RDBMS를 사용할 때 객체 기반의 도메인 모델과 관계형 데이터 모델간의 매핑을 처리하는 기술로 ORM 만한 것이 없다&lt;/p&gt;
&lt;h1 id=&quot;리파지토리-구현&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#리파지토리-구현&quot;&gt;&lt;/a&gt; 리파지토리 구현&lt;/h1&gt;
&lt;h2 id=&quot;모듈-위치&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#모듈-위치&quot;&gt;&lt;/a&gt; 모듈 위치&lt;/h2&gt;
&lt;p&gt;리포지터리 인터페이스는 애그리거트와 같이 도메인 영역에 속하고, 리포지터리를 구현한 클래스는 인프라스트럭쳐 영역에 속한다&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;리포지터리 구현 클래스를 domain.impl 같은 패키지에 위치시키는 것은 좋은 설계 방법이 아니다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;기본-기능-구현&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#기본-기능-구현&quot;&gt;&lt;/a&gt; 기본 기능 구현&lt;/h2&gt;
&lt;p&gt;리포지터리의 기본 기능은 다음 2가지 이다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;아이디로 애그리거트 조회&lt;/li&gt;
&lt;li&gt;애그리거트 저장&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이를 제공하는 인터페이스의 형식은 다음과 같다&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;OrderRepository&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Order &lt;span class=&quot;title&quot;&gt;findById&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(OrderNo no)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;save&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Order order)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;인터페이스는 애그리거트 루트를 기준으로 작성한다&lt;/li&gt;
&lt;li&gt;애그리거트를 조회하는 기능의 이름을 지을 때 널리 사용되는 규칙은 &lt;code&gt;findBy프로퍼티(프로퍼티 값)&lt;/code&gt; 의 형식을 사용하는 것이다
&lt;ul&gt;
&lt;li&gt;e.g. findById, findByName, findByOrdererId&lt;/li&gt;
&lt;li&gt;ID가 아닌 값으로 조회할때는 JPQL을 이용한다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;조회에 해당하는 애그리거트가 존재하면 애그리거트 도메인(e.g. Order)를 반환하고, 존재하지 않는다면 null이나 Optional을 반환한다&lt;/li&gt;
&lt;li&gt;1건이상 존재하면 List 컬렉션을 반환한다&lt;/li&gt;
&lt;li&gt;JPA는 트랜잭션 범위에서 변경한 데이터를 자동으로 DB에 반영하므로 따로 수정 메서드를 추가할 필요없다&lt;/li&gt;
&lt;li&gt;삭제 기능을 구현한다면 삭제할 애그리거트 객체를 파라미터로 전달받게끔 한다
&lt;ul&gt;
&lt;li&gt;soft delete로 구현하는 것이 좋다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;모델매핑-구현&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#모델매핑-구현&quot;&gt;&lt;/a&gt; 모델(매핑) 구현&lt;/h1&gt;
&lt;h2 id=&quot;기본-매핑&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#기본-매핑&quot;&gt;&lt;/a&gt; 기본 매핑&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/temp/%EC%97%94%ED%8B%B0%ED%8B%B0%EC%99%80-%EB%B2%A8%EB%A5%98%EA%B0%80-%ED%95%9C-%ED%85%8C%EC%9D%B4%EB%B8%94%EC%97%90-%EB%A7%A4%ED%95%91.png&quot; alt=&quot;엔티티와 벨류가 한 테이블에 매핑&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;애그리거트 루트는 엔티티이므로 &lt;code&gt;@Entity&lt;/code&gt;로 매핑한다&lt;/p&gt;
  &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Entity&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Order&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;벨류는 &lt;code&gt;@Embeddable&lt;/code&gt;로 매핑한다&lt;/p&gt;
  &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Embeddable&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Orderer&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;밸류를 사용하는 곳에서는 &lt;code&gt;@Embedded&lt;/code&gt;로 매핑한다&lt;/p&gt;
  &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Entity&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Order&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Embedded&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; Orderer orderer;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;벨류가 다른 벨류를 포함할 수 있다&lt;/p&gt;
  &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Embeddable&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Orderer&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Embedded&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; MemberId memberId;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;데이터베이스 컬럼명이 다를 경우 &lt;code&gt;@AttributeOverride(s)&lt;/code&gt; 어노테이션을 사용한다&lt;/p&gt;
  &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Embeddable&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ShippigInfo&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Embedded&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@AttributeOverrides&lt;/span&gt;(&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;meta&quot;&gt;@AttributeOverride&lt;/span&gt;(name = &lt;span class=&quot;string&quot;&gt;&quot;zipcode&quot;&lt;/span&gt;, column = &lt;span class=&quot;meta&quot;&gt;@Column&lt;/span&gt;(name=&lt;span class=&quot;string&quot;&gt;&quot;shipping_zipcode&quot;&lt;/span&gt;)),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;meta&quot;&gt;@AttributeOverride&lt;/span&gt;(name = &lt;span class=&quot;string&quot;&gt;&quot;address1&quot;&lt;/span&gt;, column = &lt;span class=&quot;meta&quot;&gt;@Column&lt;/span&gt;(name=&lt;span class=&quot;string&quot;&gt;&quot;shipping_address1&quot;&lt;/span&gt;)),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;meta&quot;&gt;@AttributeOverride&lt;/span&gt;(name = &lt;span class=&quot;string&quot;&gt;&quot;address2&quot;&lt;/span&gt;, column = &lt;span class=&quot;meta&quot;&gt;@Column&lt;/span&gt;(name=&lt;span class=&quot;string&quot;&gt;&quot;shipping_address2&quot;&lt;/span&gt;)),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; Address address;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;기본-생성자&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#기본-생성자&quot;&gt;&lt;/a&gt; 기본 생성자&lt;/h2&gt;
&lt;p&gt;생성자는 기본적으로 객체를 생성할 때 필요한 것을 받는 용도로 사용되는 것이다&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;벨류 오브젝트의 경우 생성 시점에 모든 값을 전달받고, setter를 제공하지 않으므로, 기본 생성자가 필요없다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;하지만 JPA의 &lt;code&gt;@Entity&lt;/code&gt;나 &lt;code&gt;@Embeddable&lt;/code&gt;을 사용하려면 기본 생성자를 제공해야한다&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;기존 객체를 상속한 프록시 객체를 사용하여 지연로딩 기능을 구현하기 때문이다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이러한 이유 때문에 기본 생성자를 추가해줘야하는데, 알다시피 기본 생성자를 추가하면 객체가 온전하지 못한 상태로 제공될 수 있게된다&lt;br&gt;
그러므로 기본 생성자를 &lt;code&gt;protected&lt;/code&gt;로 선언해서 상속한 프록시 객체에서만 사용할 수 있게 해야한다&lt;/p&gt;
&lt;h2 id=&quot;필드-접근-방식-사용&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#필드-접근-방식-사용&quot;&gt;&lt;/a&gt; 필드 접근 방식 사용&lt;/h2&gt;
&lt;p&gt;JPA는 기본적으로 필드와 메서드(프로퍼티)의 두가지 방식으로 매핑을 처리할 수 있다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;필드&lt;/p&gt;
  &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Entity&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Access&lt;/span&gt;(AccessType.FIELD)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Order&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Column&lt;/span&gt;(name = &lt;span class=&quot;string&quot;&gt;&quot;state&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Enumberated&lt;/span&gt;(EnumType.STRING)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; OrderState state;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;메서드(프로퍼티)&lt;/p&gt;
  &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Entity&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Access&lt;/span&gt;(AccessType.PROPERTY)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Order&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Column&lt;/span&gt;(name = &lt;span class=&quot;string&quot;&gt;&quot;state&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Enumerated&lt;/span&gt;(EnumType.STRING)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; OrderState &lt;span class=&quot;title&quot;&gt;getState&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; state;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setState&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(OrderState state)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.state = state;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;하이버네이트는 &lt;code&gt;@Access&lt;/code&gt;가 없으면 &lt;code&gt;@Id&lt;/code&gt;나 &lt;code&gt;@EmbeddedId&lt;/code&gt;를 보고 접근 방식을 결정한다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;공개 getter/setter를 추가하는 &lt;code&gt;메서드(프로퍼티)&lt;/code&gt; 방식을 사용하게 되면 도메인의 의도가 사라지고, 객체가 아닌 데이터 기반으로 엔티티를 구현할 가능성이 높아지게 된다&lt;br&gt;
그러므로 가능하다면 &lt;code&gt;필드&lt;/code&gt; 방식을 사용해서 객체가 제공할 기능 중심으로 구현하게끔 해야한다&lt;/p&gt;
&lt;h2 id=&quot;attributeconverter를-이용한-벨류-매핑&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#attributeconverter를-이용한-벨류-매핑&quot;&gt;&lt;/a&gt; AttributeConverter를 이용한 벨류 매핑&lt;/h2&gt;
&lt;p&gt;개발하다보면 가끔 벨류 프로퍼티 하나를 한 개 컬럼에 매핑해야 할 때가 있다&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * 이 벨류 오브젝트를 DB 컬럼 &quot;WIDTH VARCHAR(20)&quot; 에 매핑&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * e.g. 1000mm&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; **/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Length&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; String unit;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;이럴땐 JPA 2.1 이후로 추가된 &lt;code&gt;AttributeConverter&lt;/code&gt;를 이용하면 된다&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;AttributeConverter&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;X&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;Y&lt;/span&gt;&amp;gt; &lt;/span&gt;&amp;#123; &lt;span class=&quot;comment&quot;&gt;// X = 벨류 타입, Y = DB 타입&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Y &lt;span class=&quot;title&quot;&gt;convertToDatabaseColumn&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(X attribute)&lt;/span&gt;&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 벨류 타입 -&amp;gt; DB 컬럼 값&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Y &lt;span class=&quot;title&quot;&gt;convertToEntityAttribute&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Y dbData)&lt;/span&gt;&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// DB 컬럼 값 -&amp;gt; 벨류 타입&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MoneyConverter&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;AttributeConverter&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;Money&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;Integer&lt;/span&gt;&amp;gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Integer &lt;span class=&quot;title&quot;&gt;converToDatabaseColumn&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Money money)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; money.getValue();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Money &lt;span class=&quot;title&quot;&gt;convertToEntityAttribute&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Integer value)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Money(value);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;작성한 컨버터를 적용시키려면 아래 2가지 방법을 사용하면 된다&lt;br&gt;
(컨버터를 사용했기 때문에 &lt;code&gt;@Embedded&lt;/code&gt;를 사용하지 않고 &lt;code&gt;@Column&lt;/code&gt;으로 직접 매핑한다)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;특정 시점에만 적용&lt;/p&gt;
  &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Order&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Column&lt;/span&gt;(name = &lt;span class=&quot;string&quot;&gt;&quot;totalAmounts&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Converter&lt;/span&gt;(converter = MoneyConverter.class)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; Money totalAmounts;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;리포지터리로 Order 를 handling 할 때 적용된다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;모든 벨류 오브젝트에 적용&lt;/p&gt;
  &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Converter&lt;/span&gt;(autoApply = &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MoneyConverter&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;AttributeConverter&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;Money&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;Integer&lt;/span&gt;&amp;gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;모든 &lt;code&gt;Money&lt;/code&gt; 타입 프로퍼티에 자동 적용된다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="ddd" scheme="https://joont92.github.io/categories/ddd/"/>
    
    
      <category term="DDD start!" scheme="https://joont92.github.io/tags/DDD-start/"/>
    
      <category term="리포지터리" scheme="https://joont92.github.io/tags/%EB%A6%AC%ED%8F%AC%EC%A7%80%ED%84%B0%EB%A6%AC/"/>
    
  </entry>
  
  <entry>
    <title>메서드명 변경</title>
    <link href="https://joont92.github.io/refactoring/%EB%A9%94%EC%84%9C%EB%93%9C%EB%AA%85-%EB%B3%80%EA%B2%BD/"/>
    <id>https://joont92.github.io/refactoring/메서드명-변경/</id>
    <published>2019-05-26T14:17:34.000Z</published>
    <updated>2020-11-02T10:09:30.457Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>메서드명을 봐도 기능을 알 수 없을땐 메서드를 직관적인 이름으로 바꾸자</p></blockquote><h1 id="동기"><a class="markdownIt-Anchor" href="#동기"></a> 동기</h1><ul><li>복잡한 메서드를 잘게 쪼개는 것은 중요하지만, 이를 잘못 적용하면 오히려 그 작은 메서드들의 역할을 파악하기 힘들어질 수도 있다<ul><li>이러한 문제를 방지하려면 메서드명을 잘 지어야 한다</li></ul></li><li><strong>메서드명만 봐도 그 메서드의 의도를 한눈에 알 수 있어야 한다</strong></li><li>메서드명이 적절치 않다면 반드시 변경해야 한다<ul><li>코드는 컴퓨터보다 인간이 알아보기 쉽게 작성해야 한다</li></ul></li><li>이름을 잘 짓게 되는 것이야말로 진정으로 노련한 프로그래머가 되는 열쇠다</li><li>매개변수를 재정렬해서 코드를 알아보기 쉬워진다면 매개변수 재정렬을 실시해야한다</li></ul><h1 id="방법"><a class="markdownIt-Anchor" href="#방법"></a> 방법</h1><ol><li>메서드 시그니쳐가 상위클래스나 하위클래스에 선언되어 있는지 검사한다<ul><li>구현되어 있다면 이 과정을 모든 구현부마다 실행한다</li></ul></li><li>새 이름으로 메서드를 선언하고, 원본 코드를 복사한 뒤 적절히 수정한다</li><li>새 메서드를 호출하게 원본 메서드의 내용을 수정한다</li><li>원본 메서드 호출 부분을 전부 찾아서 새 메서드 호출로 바꾼다</li><li>원본 메서드를 삭제한다<ul><li>원본 메서드의 모든 호출 부분에 접근할 수 없다면 <code>@Deprecated</code>로 표시한다</li></ul></li></ol><blockquote><p>요즘 IDE에서는 2~5번이 필요없이 매우 간단히 수행할 수 있다<br>인텔리제이 짱짱</p></blockquote><p>참고 : <a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&amp;mallGb=KOR&amp;barcode=9788979149715&amp;orderClick=LAG&amp;Kc=" rel="external nofollow noopener noreferrer" target="_blank">마틴 파울러, 『리팩토링』, 김지원 옮김, 한빛미디어(2012)</a></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;메서드명을 봐도 기능을 알 수 없을땐 메서드를 직관적인 이름으로 바꾸자&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;동기&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#동기&quot;&gt;&lt;/a&gt; 동기&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;복잡한 메서드를 잘게 쪼개는 것은 중요하지만, 이를 잘못 적용하면 오히려 그 작은 메서드들의 역할을 파악하기 힘들어질 수도 있다
&lt;ul&gt;
&lt;li&gt;이러한 문제를 방지하려면 메서드명을 잘 지어야 한다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;메서드명만 봐도 그 메서드의 의도를 한눈에 알 수 있어야 한다&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;메서드명이 적절치 않다면 반드시 변경해야 한다
&lt;ul&gt;
&lt;li&gt;코드는 컴퓨터보다 인간이 알아보기 쉽게 작성해야 한다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;이름을 잘 짓게 되는 것이야말로 진정으로 노련한 프로그래머가 되는 열쇠다&lt;/li&gt;
&lt;li&gt;매개변수를 재정렬해서 코드를 알아보기 쉬워진다면 매개변수 재정렬을 실시해야한다&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;방법&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#방법&quot;&gt;&lt;/a&gt; 방법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;메서드 시그니쳐가 상위클래스나 하위클래스에 선언되어 있는지 검사한다
&lt;ul&gt;
&lt;li&gt;구현되어 있다면 이 과정을 모든 구현부마다 실행한다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;새 이름으로 메서드를 선언하고, 원본 코드를 복사한 뒤 적절히 수정한다&lt;/li&gt;
&lt;li&gt;새 메서드를 호출하게 원본 메서드의 내용을 수정한다&lt;/li&gt;
&lt;li&gt;원본 메서드 호출 부분을 전부 찾아서 새 메서드 호출로 바꾼다&lt;/li&gt;
&lt;li&gt;원본 메서드를 삭제한다
&lt;ul&gt;
&lt;li&gt;원본 메서드의 모든 호출 부분에 접근할 수 없다면 &lt;code&gt;@Deprecated&lt;/code&gt;로 표시한다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;요즘 IDE에서는 2~5번이 필요없이 매우 간단히 수행할 수 있다&lt;br&gt;
인텔리제이 짱짱&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;참고 : &lt;a href=&quot;http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&amp;amp;mallGb=KOR&amp;amp;barcode=9788979149715&amp;amp;orderClick=LAG&amp;amp;Kc=&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;마틴 파울러, 『리팩토링』, 김지원 옮김, 한빛미디어(2012)&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="refactoring" scheme="https://joont92.github.io/categories/refactoring/"/>
    
    
      <category term="리팩토링" scheme="https://joont92.github.io/tags/%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81/"/>
    
      <category term="rename method" scheme="https://joont92.github.io/tags/rename-method/"/>
    
  </entry>
  
  <entry>
    <title>매개변수 추가</title>
    <link href="https://joont92.github.io/refactoring/%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98-%EC%B6%94%EA%B0%80/"/>
    <id>https://joont92.github.io/refactoring/매개변수-추가/</id>
    <published>2019-05-26T13:58:20.000Z</published>
    <updated>2020-11-02T10:09:30.457Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>메서드가 자신을 호출한 부분의 정보를 더 많이 알아야 할 땐<br>그 정보를 전달할 수 있는 매개변수를 추가한다</p></blockquote><h1 id="동기"><a class="markdownIt-Anchor" href="#동기"></a> 동기</h1><ul><li><strong>사실 이 리팩토링은 자주 실행되면 안된다</strong><ul><li>매개변수를 추가하는 대신 다른 방법을 사용할 수 있을 때도 많고, 그럴 땐 가능하면 그 대안을 사용하는 것이 낫다</li><li>매개변수를 추가하면 매개변수 세트가 더 길어지고, 기억하거나 알아보기 힘들어진다</li></ul></li><li>대안이 없다면 실행해도 된다</li><li>기존 매개변수 세트를 살펴보면서 새 매개변수를 추가하면 어떻게 될지 생각해봐야 한다</li></ul><h1 id="방법"><a class="markdownIt-Anchor" href="#방법"></a> 방법</h1><ol><li><p>메서드 시그니쳐가 상위클래스나 하위클래스에 선언되어 있는지 검사한다</p><ul><li>구현되어 있다면 이 과정을 모든 구현부마다 실행한다</li></ul></li><li><p>추가한 매개변수를 전달받는 새 메서드를 선언하고, 원본 메서드의 내용을 복사한다</p></li><li><p>새 메서드를 호출하게 원본 메서드의 내용을 수정한다</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">originMethod</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> newMethod(a, b, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">newMethod</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do somtehing</span></span><br><span class="line">    <span class="keyword">return</span> someVar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>새 매개변수가 객체일 경우는 보통 null을 전달한다</li><li>primitive 타입일 경우는 명백히 이상한 값을 전달해서 참조하는 부분을 찾아낸다(?)<ul><li>int일 경우 보통 0을 전달한다</li></ul></li><li>참조하는 부분이 별로 없다면 생략 가능하다</li></ul></li><li><p>원본 메서드 호출 부분을 전부 찾아서 새 메서드 호출로 바꾼다</p></li><li><p>원본 메서드를 삭제한다</p><ul><li>원본 메서드의 모든 호출 부분에 접근할 수 없다면 <code>@Deprecated</code>로 표시한다</li></ul></li></ol><p>참고 : <a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&amp;mallGb=KOR&amp;barcode=9788979149715&amp;orderClick=LAG&amp;Kc=" rel="external nofollow noopener noreferrer" target="_blank">마틴 파울러, 『리팩토링』, 김지원 옮김, 한빛미디어(2012)</a></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;메서드가 자신을 호출한 부분의 정보를 더 많이 알아야 할 땐&lt;br&gt;
그 정보를 전달할 수 있는 매개변수를 추가한다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;동기&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#동기&quot;&gt;&lt;/a&gt; 동기&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;사실 이 리팩토링은 자주 실행되면 안된다&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;매개변수를 추가하는 대신 다른 방법을 사용할 수 있을 때도 많고, 그럴 땐 가능하면 그 대안을 사용하는 것이 낫다&lt;/li&gt;
&lt;li&gt;매개변수를 추가하면 매개변수 세트가 더 길어지고, 기억하거나 알아보기 힘들어진다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;대안이 없다면 실행해도 된다&lt;/li&gt;
&lt;li&gt;기존 매개변수 세트를 살펴보면서 새 매개변수를 추가하면 어떻게 될지 생각해봐야 한다&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;방법&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#방법&quot;&gt;&lt;/a&gt; 방법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;메서드 시그니쳐가 상위클래스나 하위클래스에 선언되어 있는지 검사한다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;구현되어 있다면 이 과정을 모든 구현부마다 실행한다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;추가한 매개변수를 전달받는 새 메서드를 선언하고, 원본 메서드의 내용을 복사한다&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;새 메서드를 호출하게 원본 메서드의 내용을 수정한다&lt;/p&gt;
 &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;originMethod&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; b)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; newMethod(a, b, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;newMethod&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; b, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; c)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// do somtehing&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; someVar;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;새 매개변수가 객체일 경우는 보통 null을 전달한다&lt;/li&gt;
&lt;li&gt;primitive 타입일 경우는 명백히 이상한 값을 전달해서 참조하는 부분을 찾아낸다(?)
&lt;ul&gt;
&lt;li&gt;int일 경우 보통 0을 전달한다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;참조하는 부분이 별로 없다면 생략 가능하다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;원본 메서드 호출 부분을 전부 찾아서 새 메서드 호출로 바꾼다&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;원본 메서드를 삭제한다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;원본 메서드의 모든 호출 부분에 접근할 수 없다면 &lt;code&gt;@Deprecated&lt;/code&gt;로 표시한다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;참고 : &lt;a href=&quot;http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&amp;amp;mallGb=KOR&amp;amp;barcode=9788979149715&amp;amp;orderClick=LAG&amp;amp;Kc=&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;마틴 파울러, 『리팩토링』, 김지원 옮김, 한빛미디어(2012)&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="refactoring" scheme="https://joont92.github.io/categories/refactoring/"/>
    
    
      <category term="리팩토링" scheme="https://joont92.github.io/tags/%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81/"/>
    
      <category term="add parameter" scheme="https://joont92.github.io/tags/add-parameter/"/>
    
  </entry>
  
  <entry>
    <title>매개변수 세트를 객체로 전환</title>
    <link href="https://joont92.github.io/refactoring/%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98-%EC%84%B8%ED%8A%B8%EB%A5%BC-%EA%B0%9D%EC%B2%B4%EB%A1%9C-%EC%A0%84%ED%99%98/"/>
    <id>https://joont92.github.io/refactoring/매개변수-세트를-객체로-전환/</id>
    <published>2019-05-25T17:11:51.000Z</published>
    <updated>2020-11-02T10:09:30.457Z</updated>
    
    <content type="html"><![CDATA[<p>참고 : <a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&amp;mallGb=KOR&amp;barcode=9788979149715&amp;orderClick=LAG&amp;Kc=" rel="external nofollow noopener noreferrer" target="_blank">마틴 파울러, 『리팩토링』, 김지원 옮김, 한빛미디어(2012)</a></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;참고 : &lt;a href=&quot;http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&amp;amp;mallGb=KOR&amp;amp;barcode=9788979149715&amp;amp;orderClick=LAG&amp;amp;Kc=&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;마틴 파울러, 『리팩토링』, 김지원 옮김, 한빛미디어(2012)&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="refactoring" scheme="https://joont92.github.io/categories/refactoring/"/>
    
    
  </entry>
  
</feed>
