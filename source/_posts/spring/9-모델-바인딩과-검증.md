---
title: 모델 바인딩과 검증
date: 2018-03-08 00:51:40
tags:
---

메서드에 @ModelAttribute를 파라미터로 선언했을 경우 처리되는 과정은 다음과 같다.  

1. 파라미터 타입의 오브젝트를 새로 만든다. 때문에 디폴트 생성자가 필수로 필요하다.  
@SessionAttributes를 통해 저장된 오브젝트가 있으면 새로 만들지 않고 세션에서 가져온다.  

2. HTTP 요청을 생성(혹은 가져온) 오브젝트 프로퍼티에 바인딩 해준다.  
이 과정에서 각 프로퍼티에 맞게 타입을 변환해준다.  
만약 타입 변환 오류가 발생할 시 BindingResults 오브젝트에 오류를 저장해서 컨트롤러로 넘겨준다.  

3. 검증작업을 수행한다. 2번의 과정에서 타입에 대한 검증은 이미 끝냈고, 그 외의 검증은 검증기를 통해 등록할 수 있다.  

---

### 프로퍼티 바인딩
프로퍼티 바인딩이란 오브젝트의 프로퍼티에 값을 넣는 행위를 말한다.  
프로퍼티에 맞게 타입을 적절히 변환하고 해당 프로퍼티의 수정자 메서드를 호출하는 것이다.  

스프링에선 크게 두가지의 프로퍼티 바인딩을 지원하는데  
첫번째는 애플리케이션 컨텍스트 XML 설정파일로 빈을 정의할 때 사용했던 <property> 태그이다.  
이 태그를 통해 빈의 프로퍼티에 값을 주입했었다.  
두번째는 HTTP 요청 파라미터를 모델 오브젝트 등으로 변환하는 경우이다.  
@ModelAttribute 뿐만 아니라 @RequestParam, @PathVariable 등도 해당된다.  

근데 잘 생각해보면, 프로퍼티 바인딩이 일반 primitive 타입이 아닌 경우에도 가능했던 적이 있었다.  
루트 웹 애플리케이션 컨텍스트에서 dataSource 빈을 설정할 때다.  

```xml
<bean id="dataSource" class="SimpleDriverDataSource">
  <property name="driverClass" value="com.mysql.jdbc.Driver" />
</bean>
```
보다시피 value에 문자열로 클래스명을 전달하고 있다.  
그런데 driverClass 프로퍼티는 String 타입이 아닌 Class 타입이다. 하지만 잘 바인딩 된다.  
이는 스프링이 제공하는 프로퍼티 바인딩 기능을 사용했기 때문이다.  
스프링은 프로퍼티 바인딩을 위해 2가지 API를 제공한다.  

#### PropertyEditor
스프링이 기본적으로 제공하는 바인딩용 타입 변환 API이다.  
> PropertyEditor는 스프링 API가 아니라 자바빈 표준에 정의된 API이다.  
GUI 환경에서 비주얼 컴포넌트를 만들 때 사용하도록 설계되었고, 기본적인 기능은 문자열과 자바빈 프로퍼티 사이의 타입 변환이다.  
스프링은 이 PropertyEditor를 문자열-오브젝트 상호변환이 필요한 XML 설정이나 HTTP 파라미터 변환에 유용하게 사용할 수 있다고 판단하여 이를 일찍부터 사용해왔다.  

##### 디폴트 PropertyEditor
스프링은 20여가지 정도의 디폴트 PropertyEditor를 제공한다.  
아래의 링크에서 확인할 수 있다.  
<https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/beans/propertyeditors/package-summary.html>  
바인딩 과정에서 파라미터 타입에 맞는 PropertyEditor가 자동으로 선정되어 사용된다.  

##### 커스텀 PropertyEditor
디폴트 프로퍼티 데이터에 등록되지 않은 타입을 파라미터로 사용하고 싶을 경우, 직접 PropertyEditor를 만들어 적용할 수 있다.  
아래와 같은 enum이 하나 있고,  
```java
public enum Level {
	GOLD(3), SILVER(2), BASIC(3);

    private Integer level;

    Level(Integer level){
        this.level = level;
    }

    // 숫자를 받으면 해당하는 enum을 리턴
    public static Level convert(Integer level){
        switch(level){
            case 3 : return GOLD;
            case 2 : return SILVER;
            case 1 : return BASIC;
            default : throw new RuntimeException();
        }
    }
}
```

아래와 같이 컨트롤러를 등록하고 `/user?level=1` 과 같이 호출하면 자동으로 Level enum으로 변환해서 받고 싶다고 하자.  
```java
public class UserController{
  @RequestMapping("/user", method=RequestMethod.GET)
  public String userSearch(@RequestParam Level level){
    // ...
  }
}
```
현재는 당연히 변환이 불가능하므로 오류가 발생한다.  

Level 타입에 대한 PropertyEditor를 만들어야 한다.  
아래는 프로퍼티 에디터가 변환할 때의 동작 방식이다.  
![프로퍼티 에디터 동작원리 (출처 : 토비의 스프링 vol2)](https://cloud2.zoolz.com/MyComputers/Images/Image.aspx?q=bT00MDcyNDcma2V5PTE5MzMyMjM0MDUmdHlwZT1sJno9MjAxOC8wMy8wOSAwMDo0NA==)  
setValue(), getValue()는 그냥 getter,setter이기 때문에 손댈 것 없고,  
실제로 우리가 구현해야 할 메서드는 setAsText()와 getAsText()이다.  

현재 우리한테 필요한 부분은 문자열 -> 오브젝트의 과정이므로 setAsText() 메서드를 구현해서 Level enum에 대한 PropertyEditor를 만들어보겠다.  


<!-- more -->
