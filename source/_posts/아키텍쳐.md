---
title: 아키텍쳐
date: 2019-05-04 00:48:03
tags:
    - DDD start!
    - DIP
    - DI
---

# 4개의 영역
아키텍쳐를 설계할 때 출현하는 전형적인 영역은 아래와 같다  
- 표현
    > HTTP 요청을 응용 영역이 필요로 하는 형식으로 변환해서 응용 영역에 전달하고, 응용 영역의 응답을 HTTP 응답으로 변환해서 전송한다  
    > e.g. 요청 파라미터를 객체로 받고 결과를 JSON으로 리턴  
- 응용
    > 시스템이 사용자에게 제공해야 할 기능을 구현한다  
    - **응용 영역은 기능을 구현하기 위해 도메인 영역의 도메인 모델을 사용한다**  
    - **응용 서비스는 로직을 직접 수행하기보다는 도메인 모델에 로직 수행을 위임한다**
- 도메인
    > 도메인의 핵심 로직을 구현한다  
    > e.g. 주문 도메인의 경우 '배송지 변경', '결제 완료' 같은 핵심 로직을 도메인 모델에서 구현한다  
- 인프라스트럭쳐
    > 구현 기술에 대한 것을 다룬다  
    > e.g. RDBMS 연동, 몽고 DB, 메시징 큐 전송 등  

# 계층 구조 아키텍쳐
```
   표현
    ↓
   응용
    ↓
   도메인
    ↓
인프라스트럭쳐
```
- 계층 구조는 상위 계층에서 하위 계층으로의 의존만 존재하고 하위 계층에서 상위 계층에 의존하지는 않는다
- 계층 구조를 엄격하게 적용하면 상위 계층은 바로 아래 계층에만 의존을 가져야하지만, 구현의 편리함을 위해 계층 구조를 유연하게 적용한다

여기서 중요한 점은 **표현, 응용, 도메인 계층이 상세한 구현 기술을 다루는 인프라스트럭쳐에 의존한다는 점이다**  
예를 들면 아래처럼 될 수 있다  
```java
class CalculateDiscountService { 
    private DroolsRuleEngine ruleEngine = new DroolsRuleEngine();

    public Money calculateDiscount(List<OrderLine> orderLines, String customerId) {
        Customer customer = findCustomer(customerId);

        // 초기 돈
        MutableMoney money = new MutableMoney(0);
        
        // 조건들 추가하고
        List<?> facts = Arrays.asList(customer, money);
        facts.addAll(orderLines);

        // DroolsRulsEngine을 이용해 할인율 적용
        ruleEngine.evaluate("discountCalculation", facts);

        return money.toImmutableMoney();
    }
}
```

> 위 처럼 도메인에 메시지를 보내는 것 외에 특정 엔진을 사용해야하는 상황이다  
> (특정 엔진을 사용하는 것이 더 나은 상황)  

하지만 위 코드는 아래 2가지 문제점을 가지고 있다
- 테스트하기 어렵다
    - `DroolsRuleEngine`이 완벽하게 동작해야만 `CalculateDiscountService`를 테스트할 수 있다
- 구현 방식을 변경하기 어렵다
    - `DroolsRuleEngine`이 아니라 다른 엔진을 사용하도록 변경하고자 한다면 많은 부분이 변경되어야 할 것이다

고수준 모둘이 제대로 동작하려면 저수준 모듈을 사용해야 하는데, **인프라스트럭쳐의 경우 특정 기술을 직접 구현하므로** 이런 문제점이 발생하게 된다.  
이를 어떻게 처리할 수 있을까?  

# DIP
정답은 **저수준 모델이 고수준 모델에 의존하도록 바꾸는 것이다**  
다시 한번 `CalculateDiscountService`를 살펴보면, discount를 얻는데 어떤 엔진을 사용했느냐는 중요하지 않다  
단지 `고객정보와 구매정보에 룰을 적용해서 할인 금액을 구한다`는 것이 중요할 뿐이다  
이 부분을 추상화해서 인터페이스로 만들 수 있다  
```java
interface RuleDiscounter {
    public Money applyRules(Customer customer, List<OrderLine> orderLines);
}
```

이 인터페이스를 사용하여 `CalculateDiscountService`에서 `DroolsRuleEngine`을 제거할 수 있다  
```java
class CalculateDiscountService { 
    private RuleDiscounter ruleDiscounter;

    public CalculateDiscountService(RuleDiscounter ruleDiscounter) {
        this.ruleDiscounter = ruleDiscounter;
    }

    public Money calculateDiscount(List<OrderLine> orderLines, String customerId) {
        Customer customer = findCustomer(customerId);
        return ruleDiscounter.applyRules(customer, orderLines);
    }
}

class DroolsRuleDiscounter implements RuleDiscounter {
    // ...
}
```

`CalculateDiscountService`는 더 이상 구현기술인 `Drools`(저수준)에 의존하지 않고,  
`룰을 이용한 할인 금액 계산` 을 표현하는 `RuleDiscounter` 인터페이스(고수준)에 의존한다  

![저수준이 고수준에 의존](/temp/저수준-고수준-의존.png)  

그림에서 보이다시피 고수준 모듈이 저수준 모듈을 사용함에도 불구하고 **저수준 모듈이 고수준 모듈에 의존하고 있다**  
이를 **DIP(Dependency Inversion Principle, 의존 역전 원칙)** 이라고 부른다  

그리고 인터페이스를 구현한 저수준 모듈은 외부에서 생성해 주입(Dependency Injection) 해주게 된다  

이와 같이 DIP를 적용함으로써 기존의 `고수준 모듈에서 저수준 모듈 사용`에서 오던 문제점들을 해결할 수 있게 된다  
1. 테스트하기 어렵다
    - 특정 클래스가 아니라 인터페이스에 의존하므로 mockito를 사용한 stub 등을 사용한다면 직접 구현체를 구현하지 않고도 테스트를 진행할 수 있게 된다
2. 구현 방식을 변경하기 어렵다
    - 저수준 모듈에 강하게 결합되어 있는 구조가 아니기 때문에, 구현 방식을 변경하고 싶다면 인터페이스를 구현한 구현체를 하나 더 만들어서 DI 해주면 `CalculateDiscountService`의 코드변경 없이 구현 방식을 변경할 수 있다

## DIP 주의사항
![잘못된 DIP](/temp/잘못된-DIP.png)  

DIP 결과 구조만 보고 인터페이스를 잘못 추출한 결과이다  
**`RuleEngine`은 고수준 모델인 도메인 관점이 아니라 엔진이라는 저수준 모듈 관점에서 도출된 것이다**  
즉, 여전히 고수준 모듈이 저수준 모듈에 의존하고 있는 셈이다  

DIP를 적용할 때 하위 기능을 추상화한 인터페이스는 **고수준 모듈 관점에서 도출해야 한다**  

---

로직을 구현하다보면 여러 도메인을 묶어서 뭔가를 얻어내야 할 떄도 있다  
> 이 때는 어떻게 해야할까?  
> A, B 를 계산해서 C 라는 클래스를 만들어내야하는데, 계산 로직을 어디에도 넣기가 애매할때는?  

<!-- more -->