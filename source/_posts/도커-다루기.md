---
title: Dockerfile, 도커 이미지
date: 2019-06-07 21:07:24
tags:
    - 도커/쿠버네티스를 활용한 컨테이너 개발 실전 입문
    - docker
    - docker image
    - Dockerfile
---

도커는 크게 도커 이미지와 도커 컨테이너로 나뉜다  
- 도커 이미지는 **컨테이너를 생성하는 템플릿 역할**을 한다  
- 도커 컨테이너는 도커 이미지를 기반으로 생성되어 실행되어 있는 상태를 말한다   
- 도커 이미지 하나로 여러 도커 컨테이너를 만들 수 있다  

즉, 도커를 실행시키려면 도커 이미지를 만들고 이를 컨테이너화 시켜야 하는 것이다  

# Dockerfile
도커이미지를 만들 때 참조하는 설정파일이다  
도커 이미지 빌드시에 이 파일의 인스트럭션들을 참조하여 이미지를 만든다  

기본으로 `Dockerfile` 이라는 이름을 사용하고, 이름을 변경하고 싶다면 이미지 빌드시에 추가 옵션을 줘야한다

# 인스트럭션
`Dockerfile` 내에 있는 명령어들을 말한다  
아래는 각 인스트럭션에 대해 간단히 나열한 것이며, 자세한 내용이 궁금하면 <https://docs.docker.com/engine/reference/builder/> 를 참조한다  

## 자주 사용하는 인스트럭션
예시로 사용할 자바 어플리케이션과 Dockerfile 이다  

Test.java
```java
public class Test {
    public static void main(String[] args) {
        System.out.println("Hello World!");
    }
}
```

Dockerfile
```
FROM openjdk:8-jdk

COPY Test.java .
RUN javac Test.java

CMD ["java", "Test"]
```

### FROM
해당 도커 이미지의 바탕이 될 베이스 이미지를 지정하는 인스트럭션이다  
현재는 java 파일을 실행해야 하므로 openjdk를 떙겨오고 있는 모습이다  
(openjdk 는 이미지명이며, 8-jdk는 태그명이다)  
레지스트리를 따로 지정하지 않았기 때문에 도커 허브에서 땡겨온다  

### COPY
호스트 머신의 파일이나 디렉터리를 도커 컨테이너 안으로 복사하는 인스트럭션이다  
이전에 만든 컨테이너안의 현재 디렉토리로 호스트 머신의 Test.java 를 복사하는 과정이다  

### RUN
도커 이미지를 `실행할 컨테이너 안에서` 실행할 명령을 정의한다  
복사된 Test.java를 javac로 컴파일하는 과정이다  
호스트 머신에 Test.class가 없나 확인하지 말자  

### CMD
컨테이너 안에서 실행할 프로세스(명령)를 지정한다  
컴파일된 Test.class 파일을 실행하는 과정이다  

작성법이 조금 특이한데, 총 3가지 작성법을 제공한다  
- CMD command param1 param2 [...]
    - 가장 익숙한 형태이다  
    - FROM 으로 설정한 이미지에 포함된 쉘 파일을 사용하여 명령을 실행한다  
    - 쉘 스크립트 구문을 사용할 수 있다  
- CMD ["executable", "param1", "param2" [, ...]]
    - 쉘 없이 바로 실행하면서 매개변수를 던져주는 형태이다  
    - 도커에서 권장하는 형태이다
    - 쉘 스크립트 구문을 사용할 수 없다
        ```
        CMD ["echo", "Hello, $name"]

        $ Hello $name
        ```
    - 만약 쉘 스크립트를 사용하고 싶다면 쉘을 실행시키면서 인자로 전달해줘야 한다
        ```
        CMD ["/bin/bash", "-c", "echo Hello, $name"]
        ```
- CMD ["param1", "param2" [, ...]]
    - ENTRYPOINT에 지정된 명령에 사용할 인자를 전달한다

#### CMD는 Dockerfile 내에 하나만 작성할 수 있다
만약 CMD를 여러개 작성한다면 가장 앞부분껀 전부 무시되고 가장 마지막에 있는 명령만이 실행된다  
```
CMD ["javac", "Test.java"]
CMD ["java", "Test"]
```
했다가 안되서 찾아봤음...  

#### CMD 명령 오버라이드도 가능하다
위와 같이 선언된 상황에서 
```sh
$ docker container run joont92/javatest:latest echo joont92
$ joont92 # 출력
```
CMD 명령이 무시됨을 볼 수 있다  

## 그 외 인스트럭션
### ENTRYPOINT
CMD와 마찬가지로 컨테이너 안에서 실행될 프로세스(명령)를 지정하는 인스트럭션이다  
CMD와 다른점은 조금 기준점(?) 이 되는 프로세스를 지정하는 것이랄까..  
ENTRYPOINT를 입력하면 CMD에 전달된 인자들은 전부 ENTRYPOINT의 인자로 전달된다  
```
FROM openjdk:jdk-8

ENTRYPOINT ["java"]
CMD ["version"]
```

또한 아래와 같이 사용해서 컨테이너의 용도를 어느정도 제한 할수도 있다  
```
FROM golang:1.10

ENTRYPOINT ["go"]
CMD [""]
```

자동으로 go 가 입력된 상태라고 보면 된다  
go 이후의 명령어만 인자로 넘기면 된다  
```sh
$ docker container run joont92/gotest:latest version
$ go version go1.10.3 linux/amd64 # 출력
```

### LABEL
이미지를 만든 사람의 이름 등을 적을 수 있다  
```
LABEL maintainer="joont92@github.com"
```

### ENV
도커 안에서 사용할 환경 변수를 지정한다  
```
ENV CLASSPATH=/workspace/javatest

CMD ["java", "Main"]
```

### ARG
이미지 빌드할 떄 환경변수를 전달받게끔 하기 위해 사용한다  
이미지 빌드시에만 사용할 수 있다  
```
ARG classpath
ENV CLASSPATH=${classpath}

CMD ["java", "Main"]
```

`--build-arg`를 통해 인자를 전달한다  
```sh
$ docker image build --build-arg classpath=/workapce/javatest -t joont92/javatest:latest .
```

# 빌드
```sh
$ docker image build -t joont92:javatest .
```

아래는 도커 이미지를 관리하면서 자주 사용하는 명령어들과 그에 대한 간단한 설명이다  
추가적인 명령어나 옵션이 궁금하다면 <https://docs.docker.com/engine/reference/commandline/image/> 를 참조한다  

# docker image build
```sh
$ docker image build [options] 이미지명[:태그명] Dockerfile_경로
```
`Dockerfile`에 기술된 내용을 따라 도커 이미지를 생성하는 명령이다  
> `Dockerfile`이 없다면 도커 이미지를 빌드할 수 없다

## -t 옵션
```sh
$ docker image build -t joont92:latest .
```
도커 이미지에 이름과 태그를 붙이는 것으로 실제 사용에선 거의 필수적으로 쓰인다  
지정한 경로에서 `Dockerfile` 이라는 이름의 파일을 찾고 그 내용을 토대로 이미지를 만든다  

## -f 옵션
```sh
$ docker image build -f Dockerfile_test -t joont92:latest .
```
`Dockerfile`이 아닌 다른 이름을 쓰고 싶을 경우 사용한다  

## --pull 옵션
```sh
$ docker image build --pull=true -t joont92:latest .
```
기본적으로 도커 이미지 빌드 시 `FROM` 인스트럭션에 지정한 이미지를 레지스트리에서 받은 후, 이를 호스트 운영체제 저장해놓고 재사용한다  

즉 아래와 같다  
1. 도커 이미지를 빌드한다
    - `FROM` 인스트럭션의 `test:1.0.0` 이미지를 받고 로컬에 저장해둔다
2. 레지스트리의 `test:1.0.0` 이미지의 내용이 변경되었다
3. 도커 이미지를 다시 빌드한다
    - `FROM` 인스트럭션의 `test:1.0.0`은 이미 로컬에 있으므로 재사용한다
4. 레지스트리의 변경사항이 생성된 이미지에 반영되지 않는다

이런 상황을 대비해 확실히 최신 베이스 이미지를 사용하고 싶다면 `pull=true`를 붙여주면 된다  
> `latest` 태그의 경우 매번 `pull=true`를 붙여줘야하는데, 이러면 빌드 속도가 느려지므로 실무에서는 보통 태그명을 직접 입력한다  

# docker search
```sh
$ docker search [options] 검색_키워드
```
도커 레지스트리에서 이미지를 검색할 때 사용한다  
레지스트리를 따로 설정하지 않았다면 기본적으로 도커 허브가 사용된다  
> **도커 허브(Docker Hub)?**  
> 도커 사 자체에서 관리하는 도커 이미지 레지스트리로, 깃허브처럼 자신의 계정이나 조직 이름으로 리포티저티를 만들고 이미지를 올릴 수 있다  
> 도커 허브에는 이미 매우 많은 리포지터리가 등록되어 있어서, 직접 도커 이미지를 만들 필요없이 만들어놓은 이미지를 간단하게 사용할 수 있다  

```sh
$ docker search mysql
$ docker search --limit 5 mysql # 5건만 검색
```
검색결과는 STARS 순으로 출력된다(깃헙과 동일)  
리포지터리와 이미지는 검색할 수 있으나 태그명까지는 검색할 수 없다  
> 리포지터리 = 네임스페이스 = 계정명? 
> 리포지터리명이라는 말이 왜 갑자기.. 
> 리포지터리와 이미지의 차이가 뭔지?  

# docker image pull
```sh
$ docker image pull [options] 이미지명[:태그명]
```
도커 레지스트리에서 도커 이미지를 내려받을 때 사용한다  
```sh
$ docker image pull jenkins:latest
```
태그명을 생략하면 기본으로 지정된 태그가 사용되는데 대부분 `latest` 이다  

# docker image ls
```sh
$ docker image ls [options] [이미지명[:태그명]]
```
현재 호스트 운영체제에 저장된 도커 이미지의 목록을 보여준다  

참고로 여기서 조회되는 IMAGE ID는 CONTAINER ID와는 별개의 것이므로 주의해야 한다  

# docker image tag
도커는 이미지의 버전을 이미지 ID로 관리한다  
1. docker 파일을 빌드하여 이미지를 만든다  
    ```sh
    $ docker image build -t joont92/test:latest .
    ```
2. docker image ls로 빌드된 이미지가 잘 저장되었는지 확인한다
    ```
    $ docker image ls -a

    REPOSITORY     TAG        IMAGE ID      CREATED      SIZE  
    joont92/test   latest     57ca5e531d73  1 hour ago   4.41MB 
    ```
3. Dockerfile을 조금 수정하고 다시 빌드하고, docker image ls 로 확인해본다
    ```
    $ docker image build -t joont92/test:latest .
    $ docker image ls -a  

    REPOSITORY     TAG        IMAGE ID      CREATED      SIZE  
    joont92/test   latest     57ca5e531d73  1 hour ago   4.40MB 
    <none>         <none>     2327e281c9b2  2 hour ago   4.41MB
    ```
    > IMAGE ID가 다르게 이미지가 새롭게 빌드되었음을 볼 수 있다  
    > 이처럼 Dockerfile을 수정할 때 뿐만 아니라 COPY 되는 대상이 바뀌거나 하여도 새로운 이미지로 빌드된다

`<none>` 이라고 붙은 이미지는 `joont92/test` 이미지의 이전 잔재다  
파일을 수정하고 새로 빌드하면서 동일한 이미지와 태그명을 사용했으므로  
새롭게 빌드된 이미지에 해당 이미지명과 태그명이 매핑되고, 기존 이미지는 이름과 태그가 해제되었기 때문에 `<none>`으로 표시된다  

# docker image push
```sh
$ docker image push [options] 이미지명[:태그]
```

<!-- more -->