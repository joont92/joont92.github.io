---
title: CPU
date: 2018-02-12 00:12:40
tags:
---  

# 명령어  
- 컴퓨터가 하드웨어에게 일을 시키기 위한 수단  
- 기본적으로 위에서 아래로(하향식) 실행되며, 다음 명령어를 가리키는 레지스터(Instruction Pointer)를 따라가므로 위아래로 움직일 수 있다(조건문, 반복문 등)  

## 명령어의 구조
- 크게 두 부분으로 나뉜다
- 실행코드(OPCODE), 피연산자(OPERAND)
    ```
        ADD     R1 R2 R3
    <-OPCODE-> <-OPERAND->
    ```
    - 32bit 기준으로 OPCODE 1byte, OPERAND 3byte 이다  

## Instruction Pointer  
- 실행되고 있는 실행코드가 저장된 메모리의 주소를 가리키는 상태 레지스터  
- 이 레지스터를 참고하여 다음 명령을 진행하게 됨  
    - 프로그램의 실행이 진행됨에 따라 자동 증가  
    - 제어문의 실행에 따라 자동으로 변경
- 직접 접근이 불가능함
    - 이 부분이 수정가능하면 프로그램의 실행제어가 가능해지기 때문(제품기 입력 스킵 등)  

# 명령어 집합구조(Instcution Set Architecture)
- 기계어를 매핑해놓은 어셈블리어 세트 정도로 보면 될 듯 하다  
- MIPS, ARM, x86 등이 있다(CPU마다 명령어 세트가 다르다)  

## 명령어 집합구조 설계  
- 어셈블리어 세트를 만드는 작업이다(맞나? 이게?)  
- 하드웨어, 운영체제 등을 다 고려해야 하는 작업이라 매우 어렵다  
- 아래의 기준등에 따라 ISA를 설계한다  
    - 연산의 종류는 어떤것을 사용할 것인지?  
        - 처리, 제어, 입출력 등  
    - 데이터 형식과 처리는 어떻게 할 것인지?
        - 데이터 의미, 저장방식 등
    - 명령어 형식은 어떻게 할 것인가?
    - 피연산자를 위한 주소 지정방식은 어떻게 할 것인가?  
        - 위치를 어떻게 할 것인가?
        - 메모리에 담을것인가, 레지스터에 담을 것인가?

---

하드웨어 연산  

# 산술연산
- 덧셈, 뺄셈, 곱셉, 나눗셈의 사칙연산 계산을 하는 것
- 컴퓨터는 레지스터와 ALU를 통해 산술연산을 수행

# MIPS 산술명령어
- 반드시 한 종류의 연산만을 지시한다  
- 항상 피연산자 3개를 갖는 형식을 가진다(간단하게 설계하기 위해서는 규칙적인 것이 좋으므로)  
- a에 b,c,d,e 의 합을 넣는 경우(operand 3개씩 순차적으로 진행해줘야 한다)  
    > a = b + c  
    > a = a + d   
    > a = a + e  

# MIPS 레지스터  
레지스터란 CPU내에 값을 저장해놓는(연산 등을 위해) 아주 작은 공간이다.  
MIPS에서 사용하는 레지스터는 아래와 같다.  

![MIPS 레지스터](/temp/MIPS-register-set.png)  

- t와 s가 가장 많이 사용된다  
    - s : 일반적인 변수  
    - t : 대체적으로 임시 값들이 저장(연산을 했지만 나머지 연산이 남아있는 경우라는데, 잘 모르곘음)  
- zero : 고정된 0  
- v : 리턴값. 리턴은 항상 하나만 하므로 여러 값이 필요하지 않으므로 2개면 충분하다  
- sp, fp : 스택프레임에서 사용되는 레지스터로, 가장 중요한 레지스터이다  
- ra : 함수호출 후 돌아올 주소가 저장된 곳  

# 스택프레임  
- 함수가 실행될 때 마다 가지는 자신만의 고유한 스택 영역  
- CPU 스택은 어셈블리 명령 하나에 대한 스택이고, 메모리 스택은 프로그래밍 언어 함수 하나에 대한 스택이다(?)  
fp : 스택프레임의 시작점  
sp : 


t와 s가 가장 많이 사용됨  
가장 중요한 레지스터 : sp, fp가 가장 중요한 레지스터
함수를 처리하기 위해 스택프레임으로 이동한다  
sp : 스택프레임의 베이스 포인트, fp : 값이 증가할 때 마다 

## 산술

피연산자가 반드시 3개인 경우는 규칙적인것이 간단한 설계가 편하고, 최적화된, 오류없는 명령어를 만들기 편함  

a에 b,c,d,e 합을 넣는 경우
operand 3개씩 순차적으로 진행해줘야 한다  

레지스터
s = 변수, t = 임시값들이 대체적으로 저장  
(연산을 했지만 나머지 연산이 남아있는 경우 t에 저장함)  
zero = 그냥 값이 0으로 고정  
v는 리턴값. 리턴은 하나밖에 하지 않기떄문에 2개밖에 존재하지 않음  

스택프레임  
처음엔 fp, sp가 같은 위치에 있는 형태의 스택이었다가  
add 연산이 수행될때 전달받은 매개변수의 크기만큼 스택의 크기를 증가시킨다(sp의 값을 늘린다)  
스택에 있는 2개의 변수를 add해서 임시공간(v)에 저장  

ra = 리턴포인트
를 통해 add를 출력하기 전으로 돌아오는것  

---

피연산자  
레지스터는 데이터를 저장하는 장치중 속도가 가장 빠르므로, 일반적인 계산을 위해 레지스터를 전부 투입시키는 것은 비용적으로 효율이 떨어지고, 실제로도 그러지 않는다.  
s 레지스터가 꽉 찼다고 해서 ra레지스터를 변수 저장에 사용하지 않는다는 의미이다. ra 레지스터를 변수저장에 사용하게 되면 결과적으로 리턴포인트 저장을 다른 공간(레지스터보다 느린 공간)에 해야하므로 비용적으로 손해보는게 훨씬 많다.  
그러므로 더 적은 레지스터를 필요로 하는 순서로 연산을 진행하는 것이 좋다.  

32bit라서 피연산자 데이터 단위의 최대가 32bit라고 하는데, 주소값 + 명령어 길이로 해야할텐데 그럼 4GB가 넘을텐데..  

32bit CPU에서 명령어는 1byte opcode + 3byte operand로 이루어져 있음  
레지스터의 크기는 32bit CPU가 읽을 수 있는 최대크기인 32bit로 구성되어 있음. 레지스터는 CPU에 있는 영역이므로 메모리 주소.. 뭐 그딴거랑 관계없음  

배열은 레지스터에 어떻게 담을 수 있을까?  
> 못담음. 메모리 공간에 저장하여 불러오는 방식으로 사용할 수 있음  
> 배열은 스택에 담기게 됨  
> 메모리 주소를 레지스터에 담게 됨  

메모리와 레지스터간 데이터를 주고받는 명령어를 데이터 전송 명령어라고 함  

메모리의 내용을 레지스터에 담는 것을 `적재`라고 함  
- 메모리에 주소에 저장된 데이터의 크기가 4바이트가 넘는다면?  

4(s3) == s3의 주소위치에서 4를 더함  
12(s3) == s3의 주소위치에서 12를 더함  

A[1] == 4($s3). 1은 2번쨰 원소이기 때문이다.  
자료구조의 시작을 가르키는 부분을 base register라고 함  
4바이트 단위로 저장하므로 무조건 4의 배수여야함  

레지스터의 값을 메모리에 저장하는것을 저장이라고 함  

$t0에 있는 값을 32($s3)의 위치에 저장하겠다 라는 것  

상수의 경우 레지스터나 메모리에 저장하지 않고 바로 연산을 수행할 수 있다?