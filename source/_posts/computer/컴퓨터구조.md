---
title: 컴퓨터 기초
date: 2018-07-13 20:22:21
tags:
---

# 컴퓨터란  
- 전자 회로를 이용하여 데이터를 처리하는 장치  
    > 전기는 작은 입자의 흐름이고, 이 작은 입자를 전자라고 함  
- 방대하고 복잡한 데이터 저장, 계산  
- 입출력, 제어, 기억, 연산 등의 기능을 가지고 있음  
- 네트워크 통신 가능
- 유래없는 발명품  

1. 1940년대 쯤 폰노이만 아키텍쳐 등장(현재까지도 범용적)  
    > <https://github.com/baecheese/ios_study/issues/7>  
2. 1970년 C, UNIX 등장  
3. 1980년 MS-DOS, 매킨토시 등장  
4. 1990년 Linux, Windows 등장  
5. 1990년 인터넷 포탈(야후, 구글) 등장  
6. 2000년 스마트폰, 빅데이터, AI  

# 컴퓨터 분야의 8가지 위대한 아이디어  
1. 무어의 법칙  
    - 18~24개월마다 집적회로에 집적되는 소자의 수가 2배가 된다는 법칙  
2. 추상화  
    - 자원의 수가 많아져서 설계시간이 길어지고, 생산성이 저하됨  
    - 하위 수준의 상세한 사항을 안보이게 상위 수준 모델을 단순화함으로써 설계시간을 줄임  
3. Common case fast  
    - 자주 발생하는 일은 빠르게  
    - Common case가 무엇인지 알고있다는 가정  
    - 캐싱  
4. 병렬성  
    - 큰 문제를 여러개의 작은 문제로 나누어서 해결  
    - 쓰레드
5. 파이프라이닝  
    - 병렬성의 특별한 형태  
    - 이전단계 출력이 다음단계 입력으로 이어지는 구조  
6. 예측  
7. 메모리 계층구조  
    - 최상위는 비싸고 제일 빠른 메모리  
    - 최하위는 느리고 값이 싼 메모리  
    - 레지스터 -> 램 -> 디스크  
8. 신용도 개선  
    - 가용성 향상  
    - 장애대처, 백업  

# 컴퓨터 구성요소  
1. 프로세서  
    - 인간의 두뇌와 같음  
    - 제어유닛(CU)은 메모리로부터 명령을 받아와 해독하여 제어신호로 변환  
    - ALU에서 제어신호를 연산하고(산술, 논리연산 가능) 결과를 다시 제어유닛에 돌려줌  
    - 연산의 결과를 주변장치에 전송함으로써 한개의 명령이 끝남  
    - 연산에 필요한 데이터를 레지스터에 저장하고, 연산 결과도 레지스터에 저장함  
    - GPU도 프로세스임 <https://light-tree.tistory.com/25>  
- 메모리  
    - 명령어 및 데이터 적재  
    - 정보를 저장해뒀다가 필요할 때 읽어들이는 저장소  
    - 레지스터의 용량이 너무 작아서 출시됨  
    - RAM, ROM, 캐시 등  
- 입/출력장치  
    - 데이터를 입력하거나 출력하기 위한 컴퓨터 외부장치  
    - 입력 : 키보드, 마우스, 스캐너 등  
    - 출력 : 모니터, 프린터, 스피커 등  

# 고급언어, 어셈블리, 기계어  
프로그램은 고급언어로 작성되고, 컴파일러에 의해 어셈블리어로 변환되고, 어셈블러에 의해 기계어로 변환된다.  

- 고급언어  
    - 일반적인 프로그래밍 언어(C, Java, Python 등)  
- 어셈블리어  
    - 기계 사고방식의 언어
    - 컴파일러에 의해 변환됨  
    - 추상화가 높은 언어일수록 같은 명령어에 대해 생성되는 어셈블리 명령이 더 많음  
    - C는 좀 더 로우레벨에 가까우므로 생성되는 어셈블리어가 다른 언어보다 적다. 어셈블리가 적다는것은 속도가 빠르다는 것을 의미한다.  
- 기계어 
    - 0,1(bit)로 이루어진 집합  
    - 컴퓨터만이 이해할 수 있음  

보통 고급언어를 High Level Language라고 하고, 어셈블리어를 Low Level Language라고 한다.  
Low Level Language로 작성할 경우 불필요한 instruction이 생성되지 않아 속도가 빠를순 있으나, 작성하는데 시간이 너무 오래 걸리고 어렵다.  
(printf 한줄을 쓰는데도 수라인의 어셈블리어를 써야한다)  
게다가 요즘은 고급언어로 작성해도 속도차이가 그리 크지 않다고 하니 고급언어로 개발하자..  

- OllyDBG, Immunity DBG, IDA Pro 같은 툴을 사용하면 프로그램의 어셈블리 코드를 볼 수 있다. 사용하는 CPU에 따라 생성되는 어셈블리가 조금씩 다르다.  
- Hex Editor를 사용하면 기계어를 볼 수 있다. 16진수로 출력된다.    

# 성능
시간과 리소스에 대응되어 컴퓨터 시스템이 수행하는 작업의 양  
사용자에 따라 성능측정 척도는 다양하다.  
개인사용자에겐 응답속도(Response time)가 척도가 될 것이고, 데이터센터 같은곳에서는 처리량(Throughput)이 척도가 될 것이다.  

- 성능과 실행시간과의 관계  
    ```
    성능 = 1/실행시간  
    성능A > 성능B == 1/실행시간A > 1/실행시간B == 실행시간A < 실행시간B  
    ```
- A가 B보다 n배 성능이 좋다(빠르다)
    ```
    성능A/성능B = n  
    성능A = n성능B  
    ```
    - 같은 프로그램이 컴퓨터A에서는 10초, 컴퓨터B에서 15초 걸린다면 A는 B보다 얼마나 빠른가?  
        ```
        실행시간이 주어졌으므로 실행시간으로 식을 실행시간으로 바꿔줘야함  

        실행시간B/실행시간A = n
        15/10 = 1.5

        즉, 1.5배 빠르다  
        ```

- 클럭(Clock)  
    - CPU 연산이 발생하는 시점  
    - 클럭 사이클 : 클럭의 시간 간격. 다음 연산으로 넘어가는데 걸리는 시간을 말한다.    
    - 클럭 속도 : CPU가 1초에 처리할 수 있는 연산의 개수를 말한다. 클럭 사이클을 역수로 바꾸면 된다.  

- CPU시간  
    - 궁극적인 CPU의 성능척도  
    - 프로세서가 순수하게 프로그램을 수행하기 위해 소비한 시간
    - 입출력 시간, 실행하기 위해 소비한 시간은 측정하지 않음  
    - `프로그램의 CPU 실행시간 == 프로그램이 필요로 하는 CPU 연산 횟수 / 클럭 속도`  
    - 프로그램이 필요로 하는 CPU 연산 횟수를 줄이거나 클럭 속도를 높이는게 CPU 실행시간을 줄이는 방법이다  

2GHz 클럭속도를 가진 컴퓨터 A에서 10초에 수행되는 프로그램에서 필요로 하는 CPU 연산 횟수  
> 10 = CPU 연산 / 2 * 10^9(G는 10^9)  
> CPU 연산 = 2 * 10 * 10^9  

위의 프로그램보다 CPU 연산이 1.2배 더 필요한 프로그램을 6초만에 돌리려면, 클럭속도가 몇이 되어야하는가?  
> 6 = (2 * 10 * 10^9) * 1.2 / 클럭속도  
> 클럭속도 = 4GHz  

- CPI
    - Clock cycle Per Instruction
    - 명령어 하나의 실행에 필요한 평균 클럭 사이클 수  
    - `프로그램이 필요로 하는 CPU 연산 횟수 == 명령어 수 * CPI`
    - `프로그램의 CPU 실행시간 == 명령어 수 * CPI / 클럭 속도`

# 전력  
- 컴퓨터가 동작하는데 소비되는 전기의 힘  
- 파워서플라이를 통해 공급받음  
- 클럭속도가 높아지면 전력도 커진다  
    - 트랜지스터가 열일하기 때문이다(0,1 스위칭)  
    - 전력이 커지면 그 전력은 저항에 의해 열로써 낭비된다  
    - 이런 이유 때문에 다른 전류를 들고와서 냉각을 시켜줘야 한다  
    
- CPU 클럭속도가 4GHz 벽을 맞이한 뒤로, 멀티코어를 사용하기 시작했다  
    - 멀티코어를 사용하면 전력을 줄일 수 있다  
        > 인텔 코어2 부터 멀티코어를 사용함으로써 전력이 줄어들었다
    - 멀티코어를 사용하려면 병렬 프로그래밍을 잘 해줘야한다  


---

1명보단 2명이 일하는게 더 빠르다  
컴퓨터이름 자체를 386, 486 이라고 불렀었다  
intel x86 cput들  

32bit = 1클럭당 처리할 수 있는 최대 크기  
32비트는 메모리가 4기가 이상늘어날 수 없다.  
1byte는 16진수 2개. 4bit가 나타낼 수 있는 경우의 수는 16개이고, 이게 16진수 1자리이기 때문.  
그러므로 32bit 환경에선 00 00 00 00 ~ FF FF FF FF 까지의 주소체계를 사용 할 수 있다.  
FF FF FF FF 를 10진수로 바꾸면 4GB 바이트를 비트로 나타내었을 떄와 크기가 같다. 그래서 32bit는 4GB 메모리밖에 사용하지 못하는 것이다.  

펜티엄 : 90년대  
슈퍼스칼라 아키텍쳐 : pipe 2개를 이용해서 한클럭당 여러개의 명령어가 수행되게 하는 구조  
팬티엄4가 발열사고로 생산이 중단되는 사고가 있었다  

코어2 : 팬티엄 이후로 칼을 갈고 만든 제품. 이후로 인텔이 CPU 시장을 잠식하게 됨. 최초의 멀티코어 프로세서.  

왜 멀티코어가 생겼을까?  
단일코어에 트랜지스터를 늘리는 방식의 성능향상에는 한계가 있다.  
프로세서 개수만으로는 성능향상에 한계점이 있다 == 암달의 법칙  
멀티코어의 성능을 제대로 끌어내려면 코어 여러개에 작업을 나눠주게 프로그래밍이 잘 되어있어야 한다. 그렇지 않으면 실행속도가 더 떨어질 수 있다.  

하이퍼스레딩 : 성능을 높이기 위해 인텔이 독자적으로 개발한 기술  
> 하나의 코어에 또 다른 가상의 코어를 만들어 CPU가 사실은 하나인데 2개로 인식하게 하는 방법  
> 대표적인것 : i3  

오버클럭 : 설계 당시의 속도보다 강제로 더 높게 설정하는 법. 전력을 더 많이 소모하게 되지만 더 높은 사양의 프로그램을 돌릴 수 있음.  
하지만 이로인해 발열이 커지고, 하드웨어에 무리가 갈 수 있다.  