---
title: 컴퓨터구조
date: 2018-07-13 20:22:21
tags:
---

# 컴퓨터란  
- 전자 회로를 이용하여 데이터를 처리하는 장치  
    > 전기는 작은 입자의 흐름이고, 이 작은 입자를 전자라고 함  
- 방대하고 복잡한 데이터 저장, 계산  
- 입출력, 제어, 기억, 연산 등의 기능을 가지고 있음  
- 네트워크 통신 가능
- 유래없는 발명품  

1. 1940년대 쯤 폰노이만 아키텍쳐 등장(현재까지도 범용적)  
    > <https://github.com/baecheese/ios_study/issues/7>  
2. 1970년 C, UNIX 등장  
3. 1980년 MS-DOS, 매킨토시 등장  
4. 1990년 Linux, Windows 등장  
5. 1990년 인터넷 포탈(야후, 구글) 등장  
6. 2000년 스마트폰, 빅데이터, AI  

# 컴퓨터 분야의 8가지 위대한 아이디어  
1. 무어의 법칙  
    - 18~24개월마다 집적회로에 집적되는 소자의 수가 2배가 된다는 법칙  
2. 추상화  
    - 자원의 수가 많아져서 설계시간이 길어지고, 생산성이 저하됨  
    - 하위 수준의 상세한 사항을 안보이게 상위 수준 모델을 단순화함으로써 설계시간을 줄임  
3. Common case fast  
    - 자주 발생하는 일은 빠르게  
    - Common case가 무엇인지 알고있다는 가정  
    - 캐싱  
4. 병렬성  
    - 큰 문제를 여러개의 작은 문제로 나누어서 해결  
    - 쓰레드
5. 파이프라이닝  
    - 병렬성의 특별한 형태  
    - 이전단계 출력이 다음단계 입력으로 이어지는 구조  
6. 예측  
7. 메모리 계층구조  
    - 최상위는 비싸고 제일 빠른 메모리  
    - 최하위는 느리고 값이 싼 메모리  
    - 레지스터 -> 램 -> 디스크  
8. 신용도 개선  
    - 가용성 향상  
    - 장애대처, 백업  

# 컴퓨터 구성요소  
1. 프로세서  
    - 인간의 두뇌와 같음  
    - 제어유닛(CU)은 메모리로부터 명령을 받아와 해독하여 제어신호로 변환  
    - ALU에서 제어신호를 연산하고(산술, 논리연산 가능) 결과를 다시 제어유닛에 돌려줌  
    - 연산의 결과를 주변장치에 전송함으로써 한개의 명령이 끝남  
    - 연산에 필요한 데이터를 레지스터에 저장하고, 연산 결과도 레지스터에 저장함  
    - GPU도 프로세스임 <https://light-tree.tistory.com/25>  
- 메모리  
    - 명령어 및 데이터 적재  
    - 정보를 저장해뒀다가 필요할 때 읽어들이는 저장소  
    - 레지스터의 용량이 너무 작아서 출시됨  
    - RAM, ROM, 캐시 등  
- 입/출력장치  
    - 데이터를 입력하거나 출력하기 위한 컴퓨터 외부장치  
    - 입력 : 키보드, 마우스, 스캐너 등  
    - 출력 : 모니터, 프린터, 스피커 등  

# 고급언어, 어셈블리, 기계어  
프로그램은 고급언어로 작성되고, 컴파일러에 의해 어셈블리어로 변환되고, 어셈블러에 의해 기계어로 변환된다.  

- 고급언어  
    - 일반적인 프로그래밍 언어(C, Java, Python 등)  
- 어셈블리어  
    - 기계 사고방식의 언어
    - 컴파일러에 의해 변환됨  
    - 추상화가 높은 언어일수록 같은 명령어에 대해 생성되는 어셈블리 명령이 더 많음  
    - C는 좀 더 로우레벨에 가까우므로 생성되는 어셈블리어가 다른 언어보다 적다. 어셈블리가 적다는것은 속도가 빠르다는 것을 의미한다.  
- 기계어 
    - 0,1(bit)로 이루어진 집합  
    - 컴퓨터만이 이해할 수 있음  

보통 고급언어를 High Level Language라고 하고, 어셈블리어를 Low Level Language라고 한다.  
Low Level Language로 작성할 경우 불필요한 instruction이 생성되지 않아 속도가 빠를순 있으나, 작성하는데 시간이 너무 오래 걸리고 어렵다.  
(printf 한줄을 쓰는데도 수라인의 어셈블리어를 써야한다)  
게다가 요즘은 고급언어로 작성해도 속도차이가 그리 크지 않다고 하니 고급언어로 개발하자..  

- OllyDBG, Immunity DBG, IDA Pro 같은 툴을 사용하면 프로그램의 어셈블리 코드를 볼 수 있다. 사용하는 CPU에 따라 생성되는 어셈블리가 조금씩 다르다.  
- Hex Editor를 사용하면 기계어를 볼 수 있다. 16진수로 출력된다.    

성능 : 시간과 리소스에 대응되어 컴퓨터 시스템이 수행하는 작업의 양  
성능은 상대적이다.  

성능A/성능B = B가 A보다 빠른 수치  
10/15 = B는 A보다 2/3배 빠르다.  

A가 얼마나 빠른가 구하고싶다면  
성능B/성능A를 해야함. 1.5배 빠르다.  

프로세서가 여러 프로그램을 실행해야 할 경우, 특정 프로그램의 속도를 줄이기보단 처리량을 최적화하는게 더 좋을수도 있다.  
CPU 시간 :
프로세서가 순수하게 프로그램을 수행하기 위해 소비한 시간
입출력 하는데 걸린 시간이나, 특정 프로그램을 실행하는데 소비한 시간을 측정하지 않는다

클럭사이클의 길이를 줄이거나, 클럭 속도를 높이는게 CPU 실행시간을 줄이는 방법이다  

프로그램 내 인스터럭션 마다 수행하는데 필요한 클럭 사이클수가 다르다.  
그러므로 명령어 수 X 평균 클럭사이클 수를 곱해주면 클럭 사이클 수를 구할 수 있다.  

클럭사이클 수가 주어져있지 않을 경우 명령어 수 * CPI로 대체 가능하다  

---

클럭속도가 크면 전력도 크다  
2코어 이후로는 파이프라인을 단순하게 구성하고, 코어수를 늘림. 클럭수가 줄어들었다?
하지만 냉각기술때문에 현재는 발전이 조금 정체되었다?

전력이 너무 높아지면 그 전력은 저항에 의해 열로써 낭비가 되는데,
이떄 다른 전류를 들고와서 냉각을 시켜줘야 하고, 
냉각 비용을 줄이는게 더 중요하다.

---

1명보단 2명이 일하는게 더 빠르다  
컴퓨터이름 자체를 386, 486 이라고 불렀었다  
intel x86 cput들  

32bit = 1클럭당 처리할 수 있는 최대 크기  
32비트는 메모리가 4기가 이상늘어날 수 없다.  
1byte는 16진수 2개. 4bit가 나타낼 수 있는 경우의 수는 16개이고, 이게 16진수 1자리이기 때문.  
그러므로 32bit 환경에선 00 00 00 00 ~ FF FF FF FF 까지의 주소체계를 사용 할 수 있다.  
FF FF FF FF 를 10진수로 바꾸면 4GB 바이트를 비트로 나타내었을 떄와 크기가 같다. 그래서 32bit는 4GB 메모리밖에 사용하지 못하는 것이다.  

펜티엄 : 90년대  
슈퍼스칼라 아키텍쳐 : pipe 2개를 이용해서 한클럭당 여러개의 명령어가 수행되게 하는 구조  
팬티엄4가 발열사고로 생산이 중단되는 사고가 있었다  

코어2 : 팬티엄 이후로 칼을 갈고 만든 제품. 이후로 인텔이 CPU 시장을 잠식하게 됨. 최초의 멀티코어 프로세서.  

왜 멀티코어가 생겼을까?  
단일코어에 트랜지스터를 늘리는 방식의 성능향상에는 한계가 있다.  
프로세서 개수만으로는 성능향상에 한계점이 있다 == 암달의 법칙  
멀티코어의 성능을 제대로 끌어내려면 코어 여러개에 작업을 나눠주게 프로그래밍이 잘 되어있어야 한다. 그렇지 않으면 실행속도가 더 떨어질 수 있다.  

하이퍼스레딩 : 성능을 높이기 위해 인텔이 독자적으로 개발한 기술  
> 하나의 코어에 또 다른 가상의 코어를 만들어 CPU가 사실은 하나인데 2개로 인식하게 하는 방법  
> 대표적인것 : i3  

오버클럭 : 설계 당시의 속도보다 강제로 더 높게 설정하는 법. 전력을 더 많이 소모하게 되지만 더 높은 사양의 프로그램을 돌릴 수 있음.  
하지만 이로인해 발열이 커지고, 하드웨어에 무리가 갈 수 있다.  