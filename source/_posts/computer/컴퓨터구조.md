---
title: 컴퓨터구조
date: 2018-07-13 20:22:21
tags:
---

# 컴퓨터란  
- 전자 회로를 이용하여 데이터를 처리하는 장치  
    > 전기는 작은 입자의 흐름이고, 이 작은 입자를 전자라고 함  
- 방대하고 복잡한 데이터 저장, 계산  
- 입출력, 제어, 기억, 연산 등의 기능을 가지고 있음  
- 네트워크 통신 가능
- 유래없는 발명품  

1. 1940년대 쯤 폰노이만 아키텍쳐 등장(현재까지도 범용적)  
    > <https://github.com/baecheese/ios_study/issues/7>  
2. 1970년 C, UNIX 등장  
3. 1980년 MS-DOS, 매킨토시 등장  
4. 1990년 Linux, Windows 등장  
5. 1990년 인터넷 포탈(야후, 구글) 등장  
6. 2000년 스마트폰, 빅데이터, AI  

# 컴퓨터 분야의 8가지 위대한 아이디어  
1. 무어의 법칙  
    - 18~24개월마다 집적회로에 집적되는 소자의 수가 2배가 된다는 법칙  
2. 추상화  
    - 자원의 수가 많아져서 설계시간이 길어지고, 생산성이 저하됨  
    - 하위 수준의 상세한 사항을 안보이게 상위 수준 모델을 단순화함으로써 설계시간을 줄임  
3. Common case fast  
    - 자주 발생하는 일은 빠르게  
    - Common case가 무엇인지 알고있다는 가정  
    - 캐싱  
4. 병렬성  
    - 큰 문제를 여러개의 작은 문제로 나누어서 해결  
    - 쓰레드
5. 파이프라이닝  
    - 병렬성의 특별한 형태  
    - 이전단계 출력이 다음단계 입력으로 이어지는 구조  
6. 예측  
7. 메모리 계층구조  
    - 최상위는 비싸고 제일 빠른 메모리  
    - 최하위는 느리고 값이 싼 메모리  
    - 레지스터 -> 램 -> 디스크  
8. 신용도 개선  
    - 가용성 향상  
    - 장애대처, 백업  

# 컴퓨터 구성요소  
1. 프로세서  
    - 인간의 두뇌와 같음  
    - 제어유닛(CU)은 메모리로부터 명령을 받아와 해독하여 제어신호로 변환  
    - ALU에서 제어신호를 연산하고(산술, 논리연산 가능) 결과를 다시 제어유닛에 돌려줌  
    - 연산의 결과를 주변장치에 전송함으로써 한개의 명령이 끝남  
    - 연산에 필요한 데이터를 레지스터에 저장하고, 연산 결과도 레지스터에 저장함  
    - GPU도 프로세스임 <https://light-tree.tistory.com/25>  
- 메모리  
    - 실질적 데이터 저장 공간  
- 입/출력  
    - 메모리로부터 데이터를 읽고 씀  


---
무어의 법칙 : 반도체 집적회로의 성능이 24개월마다 2배로 증가한다는 법칙
추상화
자주 발생하는 일은 빠르게
병렬 -> 성능개선
파이프라이닝 -> 성능개선

무엇이 common case인지? 어떻게 발전시킬 것인지?
캐싱 같은거

컴퓨터는 데이터에 접근할 때 위에서부터 아래로 접근한다
그러므로 레지스터, 램, 디스크로 하는게 그런 이유이다

신용도 : 시스템을 믿을 수 있는 정도
언제나 접근하고, 언제나 사용할 수 있어야 한다 == 가용성이 높아야 한다

---

기억장치 = 메모리

GPU는 수천개의 코어가 연결되어 병렬처리(?)

제어유닛은 메모리로부터 명령어를 읽어서 제어신호로 만든 후 
ALU에서 연산을 수행하고 제어유닛에 돌려줌
돌려받은 연산값을 주변기기에 전달함으로써 명령어 한개가 끝남

연산에 필요한 데이터, 결과를 임시로 저장하는 공간
- 범용 레지스터 : 임시 저장
- 특수목적 레지스터 : 용도가 있는것?

ALU : 산술연산 + 논리연산
연산에 필요한 데이터를 레지스터에서 읽은 다음 결과를 레지스터에 반환

메모리 : 레지스터가 너무 용량이 작아 나오게 된것
RAM : 휘발성
ROM : 비휘발성
캐쉬 : 

해상도 : GPU에서 출력한 데이터를 처리하고, 그 정도를 해상도라는 것으로 나타냄
화면에서 몇개의 점을 나타낼 수 있는가

---
4강 - 1
프로그램 : 고급언어 <> 기계어(컴파일러를 통해)
고급언어 -> 어셈블리어(기계가 이해할 수 있는 형태로)

어셈블리어 : 더이상 나눌 수 없는 상태까지 분리
어셈블러를 통해 기계어로 번역

기계어 : 비트들의 집합
추상화 레벨이 높은 언어일수록 같은 명령어에 대해(printf 등)
더 많은 어셈블리 명령어를 생성한다
그러므로 고급언어는 어셈블리어보다 절대 빠를 수 없다.  

C언어는 좀 더 로우레벨에 가깝기 때문에 생성되는 어셈블리어가 다른 언어보다 작다. 생성되는 어셈블리어가 작다는 것은 속도가 빠르다는 것을 의미한다.

어셈블리로 직접 작성하는 것은 효율성이 많이 떨어진다.
모든 인스트력선을 다 써야하므로..

개발에 있어서는 고급언어가 훨씬 효율적.
가령 printf 한줄을 쓰는데도 어셈블리어를 엄청 써야하는데 그건 너무 비효율적
요새는 cpu 성능이 좋아서 차이가 그렇게 많이 안남

---
4강 - 2

linux는 gdb(데비안 계열 기본 내장 프로그램)에서 어셈블링을 할 수 있다  
Hex Viewer : 기계여 보기 위함

어셈블리는 cpu가 arm 이냐, intel이냐에 따라 문법이 다르다.  
&가 붙거나, 타겟 소스 위치가 다르거나 정도의 차이가 존재함  

헥스 에디터로 exe파일을 열면 이진데이터(16진수)를 볼 수 있다.  
16진수 여러개를 묶은게 어셈블리 add 하나에 대응되고, 이런식이다.  
하지만 이런식으로 코딩을 하는것은 불가능하다. 그러므로 고급언어를 사용해야 한다.  

---

성능 : 시간과 리소스에 대응되어 컴퓨터 시스템이 수행하는 작업의 양  
성능은 상대적이다.  

성능A/성능B = B가 A보다 빠른 수치  
10/15 = B는 A보다 2/3배 빠르다.  

A가 얼마나 빠른가 구하고싶다면  
성능B/성능A를 해야함. 1.5배 빠르다.  

프로세서가 여러 프로그램을 실행해야 할 경우, 특정 프로그램의 속도를 줄이기보단 처리량을 최적화하는게 더 좋을수도 있다.  
CPU 시간 :
프로세서가 순수하게 프로그램을 수행하기 위해 소비한 시간
입출력 하는데 걸린 시간이나, 특정 프로그램을 실행하는데 소비한 시간을 측정하지 않는다

클럭사이클의 길이를 줄이거나, 클럭 속도를 높이는게 CPU 실행시간을 줄이는 방법이다  

프로그램 내 인스터럭션 마다 수행하는데 필요한 클럭 사이클수가 다르다.  
그러므로 명령어 수 X 평균 클럭사이클 수를 곱해주면 클럭 사이클 수를 구할 수 있다.  

클럭사이클 수가 주어져있지 않을 경우 명령어 수 * CPI로 대체 가능하다  

---

클럭속도가 크면 전력도 크다  
2코어 이후로는 파이프라인을 단순하게 구성하고, 코어수를 늘림. 클럭수가 줄어들었다?
하지만 냉각기술때문에 현재는 발전이 조금 정체되었다?

전력이 너무 높아지면 그 전력은 저항에 의해 열로써 낭비가 되는데,
이떄 다른 전류를 들고와서 냉각을 시켜줘야 하고, 
냉각 비용을 줄이는게 더 중요하다.