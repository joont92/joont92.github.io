---
title: 고급 매핑
date: 2018-12-13 23:11:12
tags:
    - '@MappedSupperClass'
    - '@IdClass'
    - '@EmbeddedId'
    - '@JoinTable'
    - '@SecondaryTable'
---

# 상속 관계 매핑(DTYPE)
RDB는 객체지향 언어처럼 상속이라는 개념이 없다.  
대신 `슈퍼타입 서브타입 관계`라는 모델링 기법이 있는데, 이게 상속 개념과 가장 유사하다.  
아래는 슈퍼타입 서브타입 관계의 전략들이다.  

## 각각의 테이블로 변환(조인 전략)
엔티티 각각(자식, 부모 전부)을 테이블로 만들고,  
자식 테이블이 부모의 기본키를 받아서 `기본키 + 외래키`로 사용하는 방법이다.  

![joined tale](https://cloud2.zoolz.com/MyComputers/Images/Image.aspx?q=bT00MDcyNDcma2V5PTI5Mzk1NjU3NzcmdHlwZT1sJno9MjAxOC8xMi8xNSAwMjo1Mw==)  

```sql
-- 삽입
INSERT INTO ITEM(id, name, price, DTYPE) VALUES(1, '앨범', 10000, 'A');
INSERT INTO ALBUM(id, author) VALUES(1, '소녀시대');

INSERT INTO ITEM(id, name, price, DTYPE) VALUES(1, '인셉션', 10000, 'M');
INSERT INTO MOVIE(id, director, actor) VALUES(1, '크리스토퍼 놀란', '디카프리오');

-- 조회
SELECT *
FROM ITEM i
INNER JOIN ALBUM a ON a.id = i.id
WHERE a.id = 1
AND i.DTYPE = 'A';
```

- 장점
    - 테이블이 정규화된다
    - 외래키 참조 무결성 제약 조건 사용 가능
    - 저장 공간을 효율적으로 사용함

- 단점
    - 조회할 때 항상 조인해서 들고와야함
    - 등록할 때 INSERT를 항상 2번 실행해야함

DTYPE을 지정한 것은 탐색의 범위를 줄위기 위함이다(아마도?)  
(부모 테이블 전체를 탐색하는 것은 낭비이기 때문이다)  
JPA 표준 명세에서는 이를 지정해주도록 하지만 하이버네이트는 굳이 지정해주지 않아도 잘 동작한다.  

그래도 가장 객체지향에 가깝게 생기긴 했다.  

```java
/**
 * 엔티티 정의
**/
@Entity
@Inheritance(strategy = InheritanceType.JOINED) // 1
@DiscriminatorColumn(name = "DTYPE") // 2
public abstract class Item{
    @Id
    @GeneratedValue
    private Long id;

    private String name;

    private int price;
}

@Entity
@DiscriminatorValue("A") // 3
public class Album extends Item{
    private String author;
}

@Entity
@DiscriminatorValue("M") // 3
@PrimaryKeyJoinColumn(nane = "MOVIE_ID")
public class Movie extends Item{
    private String director;

    private String actor;
}

/**
 * 등록, 조회
**/
public void save(){
    Album album = // ~~~~

    em.persist(album);
}

public void select(){
    Album album = em.find(Album.class, 1);
}
```

사용하는 부분은 별로 다를 것 없다.  

1. 상속 매핑을 사용할 것이고, `조인 전략`을 사용할 것이라는 의미이다.  
2. 자식 테이블을 구분할 컬럼이다. 실제 테이블의 컬럼으로 생성된다. 기본값이 DTYPE 이다.  
3. 구분 컬럼에 저장될 값이다.  
4. 기본적으로 자식 테이블은 부모 테이블의 ID 컬럼명을 그대로 사용하는데, 이를 바꿔주고 싶을 때 사용한다.  

## 통합 테이블로 변환(단일 테이블 전략)
전략 이름 그대로 하나의 테이블에 다 때려넣는 전략이다.  
그리고 구분 컬럼(DTYPE)으로 어떤 자식 데이터가 저장되었는지 구분한다.  

![single table](https://cloud2.zoolz.com/MyComputers/Images/Image.aspx?q=bT00MDcyNDcma2V5PTI5Mzk1NjU3NzImdHlwZT1sJno9MjAxOC8xMi8xNSAwMjo1Mw==)  

```sql
-- 삽입
INSERT INTO ITEM(id, name, price, artist, DTYPE) VALUES(1, '앨범', 10000, '소녀시대', 'A');

-- 조회
SELECT *
FROM ITEM a
WHERE a.id = 1
AND a.DTYPE = 'A'
```

하나의 테이블에 모든 데이터를 통합하므로 `구분 컬럼은 필수`로 사용해야한다.  
(얘도 없어도 상관없지 않나? 그냥 범위줄이기 용도 아닌가?  
조인 전략은 테이블이라는 물리적인 것으로 확실히 구분되지만 통합 단일 테이블 전략은 확실히 구분되는 포인트가 없기 때문에, 안정성을 위해서?)  

- 장점
    - 조인이 필요없다

- 단점
    - 자식 엔티티가 매핑한 컬럼은 모두 null을 허용해야 한다.  
    - 단일 테이블에 모든 것을 저장하므로 테이블이 커질 수 있다. 그러므로 오히려 성능이 느려질 수 있다.  

```java
@Entity
@Inheritance(strategy = InheritanceType.SINGLE_TABLE) // 1
@DiscriminatorColumn(name = "DTYPE")
public abstract class Item{
    @Id
    @GeneratedValue
    private Long id;

    private String name;

    private int price;
}

@Entity
@DiscriminatorValue("A")
public class Album extends Item{
}
@Entity
@DiscriminatorValue("M")
public class Movie extends Item{
}
```

1. `단일 테이블 전략`을 사용할 것이라는 의미이다.  

## 서브타입 테이블로 변환(구현 클래스마다 테이블 전략)
자식 엔티티마다 테이블을 만드는 전략이다.  
자식 테이블에 필요한 컬럼이 모두 있다. 구분 컬럼이 필요없다.  

![concrete table](https://cloud2.zoolz.com/MyComputers/Images/Image.aspx?q=bT00MDcyNDcma2V5PTI5Mzk1NjU3NzMmdHlwZT1sJno9MjAxOC8xMi8xNSAwMjo1Mw==)  

- 장점
    - not null 제약조건을 사용할 수 있다.  

- 단점
    - 여러 자식 테이블을 함께 조회할 때 성능이 느리다(UNION을 사용해야함)
    - 자식 테이블을 통합해서 쿼리하기 어렵다

데이터베이스 설계자와 객체지향 설계자 둘 다 추천하지 않는 방법이다.  
조인이나 단일 테이블 전략을 고려하는 것이 좋다.  

```java
@Entity
@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS) // 1
public abstract class Item{
    @Id
    @GeneratedValue
    private Long id;

    private String name;

    private int price;
}

@Entity
@DiscriminatorValue("A")
public class Album extends Item{
}
@Entity
@DiscriminatorValue("M")
public class Movie extends Item{
}
```

1. `구현 클래스마다 테이블 전략`을 사용하겠다는 의미이다. DTYPE이 필요없다.  

# 매핑 정보만 상속(@MappedSupperClass)
부모 클래스는 테이블과 매핑하지 않고 부모 클래스를 상속 받는 자식 클래스에게 `매핑 정보만 제공하고 싶을 경우` 사용한다.  
단순히 매핑 정보만 상속할 목적으로 사용한다.  

```java
@MappedSuperClass // 1
public abstract class BaseEntity{
    @Id
    @GeneratedValue
    private Long id;

    @Temporal(TemporalType.TIMESTAMP)
    private Date createdDate;

    @Temporal(TemporalType.TIMESTAMP)
    private Date lastModifiedDate;
}

@Entity
class Member extends BaseEntity{
    // ...
}

@Entity
@AttributeOverride(name = "id", column = @Column(name = "TEAM_ID")) // 2
class Team extends BaseEntity{
    // ...
}
```

`BaseEntity`는 테이블과 매핑되지 않고 단순히 자식 엔티티에게 매핑 정보만 제공하는 용도로 사용된다.  
(ORM에서 말하는 진정한 상속 매핑은 처음 설명했던 `상속 관계 매핑`을 말한다)  

1. 매핑 정보만 제공할 클래스라는 의미이다.  
2. 매핑정보를 재정의 하고 싶을 경우 사용한다. 여러개를 지정하고 싶을 경우 `@AttributeOverrides`를 사용한다.  
> 동일한 이름으로 필드를 정의하는 것은 명시적인 방법이 아니다(?)  
> <https://stackoverflow.com/questions/9414990/if-you-overwrite-a-field-in-a-subclass-of-a-class-the-subclass-has-two-fields-w>  
3. 위에 명시하진 않았지만 관계를 재정의 하고 싶을 경우 `@AssociationOverride`를 사용한다.  

# 복합키 매핑
JPA에서 식별자를 둘 이상 사용하려면 별도의 식별자 클래스를 만들어야 한다.  
그냥 자바 기본 타입 2개 쓰고 @Id 선언하면 안된다.  

JPA에서 별도의 식별자 클래스를 만드는 방법은 2가지가 있다.  
두 방식의 장단점이 있으니, 원하는 방식을 선택해서 하면 된다.  

## @IdClass
@IdClass를 이용한 복합키 선언은 아래와 같다.  

```java
@Entity
@IdClass(ParendId.class)
public class Parent{
    @Id
    @Column(name = "PARENT_ID1")
    private String id1;

    @Id
    @Column(name = "PARENT_ID2")
    private String id2;
}

@NoArgsConstructor
@AllArgsConstructor
public class ParentId implements Serializable{
    private String id1; // Parent.id1 에 대한 정보 제공
    private String id2; // Parent.id2 에 대한 정보 제공

    // equals, hashCode
}
```

@IdClass가 정보 제공용도(식별자 정보는 여기를 참고해라) 정도로 쓰이고 있다.  
@IdClass로 사용된 식별자 클래스는 아래 조건을 만족해야 한다.  

- **식별자 클래스의 속성명과 엔티티에서 사용하는 식별자의 속성명이 같아야 함**  
> Entity에 매핑 정보를 적고, IdClass에서 `해당 변수명에 맞춰 정보를 제공`해주고 있다.  
> 아래 `식별/비식별 관계에서 복합키 사용` 매핑하는 부분에서 더 상세히 볼 수 있다.
- Serializable 인터페이스 구현해야 함
- equals, hashCode 구현해야함
- 기본 생성자 필요
- 식별자 클래스는 public 이어야 함

실제 사용은 아래와 같다.  

```java
// save
public void save(){
    Parent parent = Parent.builder()
        .id1("id1")
        .id2("id2")
        .build();
    
    em.persist(parent);
}

// select
public void select()}{
    ParentId parentId = new ParentId("id1", "id2");
    Parent foundParent = em.find(Parent.class, parentId);
}
```

저장 코드에 식별자 클래스인 ParentId가 보이지 않는 이유는 em.persist를 호출하면 JPA가 내부에서 Parent.id1, Parent.id2 값을 이용해서 ParentId를 생성하고 영속성 컨텍스트의 키로 사용하기 때문이다.  
이 부분만 보면 확실히 RDB에 가까운 방법이긴 하다.  

하지만 조회쪽을 보면 또 그렇지도 않음.. 결국 ParentId를 생성해서 조회하고 있다.  

## @EmbededId
@IdClass보다 좀 더 객체지향적인 방법이다!  

```java
@Entity
@IdClass(ParendId.class)
public class Parent{
    @EmbeddedId
    private ParentId id;
}

@NoArgsConstructor
@AllArgsConstructor
@Embeddable
public class ParentId implements Serializable{
    @Column(name = "PARENT_ID1")
    private String id1;
    @Column(name = "PARENT_ID2")
    private String id2;

    // equals, hashCode
}
```

(사용하는 쪽에서 @EmbeddedId로 사용하므로 @Id를 사용할 필요없고, 복합키이므로 자동생성을 사용할 수 없다)  
@IdClass 처럼 정보 제공 용도로 사용하지 않고 직접 엔티티에서 사용해버렸다.  
매핑 정보도 ParentId 클래스에 들어감으로써 키를 명확히 하나의 클래스로 분리한 느낌이 난다.  
확실히 좀 더 객체지향적인 방법이다.(전 이게 좋음~~)  

@EmbeddedId를 사용한 식별자 클래스는 아래 조건을 만족해야 한다.  

- @Embeddable 어노테이션을 붙여주어야 함  
- Serializable 인터페이스 구현해야 함
- equals, hashCode 구현해야함
- 기본 생성자 필요
- 식별자 클래스는 public 이어야 함

실제 사용은 아래와 같다.  

```java
// save
public void save(){
    Parent parent = Parent.builder()
        .id(new ParentId("id1", "id2"))
        .build();
    
    em.persist(parent);
}

// select
public void select()}{
    ParentId parentId = new ParentId("id1", "id2");
    Parent foundParent = em.find(Parent.class, parentId);
}
```

## 복합키의 equals, hashCode
위의 복합키 조건을 보면 equals와 hashCode를 필수로 구현해줘야 한다고 하는데,  
이는 JPA는 영속성 컨텍스트에 엔티티를 보관할 때 엔티티의 식별자를 키로 사용하고,  
식별자를 구분하기 위해 equals와 hashCode를 사용해서 동등성 비교를 하기 때문이다.  

이게 단일 식별자일 경우에는 자바의 기본 타입을 사용하므로 별 문제없이 동등성이 보장되지만,  
복합 식별자일 경우에는 클래스를 사용하므로 equals와 hashCode를 구현해주지 않으면 동등성을 보장할 수 없다.  

```java
ParentId id1 = new ParentId("id1", "id2");
ParentId id2 = new Parentid("id1", "id2");

assertTrue(id1.equas(id2)); // fail
```

같은 id 값을 가졌지만, 동등하지 않은 것이 된다.  
java는 equals, hashCode를 오버라이드 하지 않으면 기본적으로 Object의 것을 사용하기 때문이다.  
기본적으로 Object의 equals는 동일성 비교(==)를 하기 때문에 위의 두 키는 동등하지 않은 것이 된다.  

JPA는 엔티티의 식별자를 가지고 영속성 컨텍스트를 관리하기 때문에  
식별자의 동등성이 지켜지지 않으면 예상과 다른 엔티티가 조회되거나 엔티티를 찾을 수 없는 등 심각한 문제가 발생할 수 있다.  
그러므로 equals와 hashCode는 필수로 구현해줘야 한다.  

# 식별/비식별 관계에서 복합키 사용

## 식별 관계와 비식별 관계

### 식별관계  
부모 테이블의 기본키를 내려받아서 자식 테이블의 기본키 + 외래키로 사용하는 관계이다.  

```sql
CREATE TABLE parent(
    parent_id integer,
    PRIMARY KEY(parent_id)
)

CREATE TABLE child(
    parent_id integer,
    child_id integer,
    PRIMARY KEY(parent_id, child_id),
    FOREIGN KEY(parent_id) REFERENCES parent(parent_id)
)
```

### 비식별 관계
부모 테이블의 기본키를 내려받아서 자식 테이블의 외래키로만 사용하는 관계이다.  
요즘은 비식별 관계를 주로 사용하고, 필요할 때만 식별 관계를 사용하는 추세이다.  

```sql
CREATE TABLE parent(
    parent_id integer,
    PRIMARY KEY(parent_id)
)

CREATE TABLE child(
    parent_id integer,
    child_id integer,
    PRIMARY KEY(child_id),
    FOREIGN KEY(parent_id) REFERENCES parent(parent_id)
)
```

1. 필수적 비식별 관계 : FK NOT NULL(INNER JOIN 사용됨)
1. 선택적 비식별 관계 : FK NULLALBE(OUTER JOIN 사용됨)


## 식별 관계 매핑
부모, 자식, 손자까지 계속 기본키를 전달하는 식별관계이다.  
식별관계는 부모의 키를 포함해 복합키를 구성해야 하므로 @IdClass나 @EmbeddedId를 사용해야 한다.  

```sql
CREATE TABLE parent(
    parent_id integer,
    PRIMARY KEY(parent_id)
)

CREATE TABLE child(
    parent_id integer,
    child_id integer,
    PRIMARY KEY(parent_id, child_id),
    FOREIGN KEY(parent_id) REFERENCES parent(parent_id)
)

CREATE TABLE grandchild(
    parent_id integer,
    child_id integer,
    grandchild_id integer,
    PRIMARY KEY(parent_id, child_id, grandchild_id),
    FOREIGN KEY(parent_id) REFERENCES parent(parent_id),
    FOREIGN KEY(child_id) REFERENCES child(child_id)
)
```

### @IdClass
```java
@Entity
public class Parent{
    @Id
    private String parentId;
}

@Entity
@IdClass(ChildId.class)
public class Child{
    // 매핑 정보 나열
    @Id
    @ManyToOne
    @JoinColumn(name = "parent_id")
    private Parent parent;

    @Id
    private String childId;
}

@EqualsAndHashCode
public class ChildId implements Serializable{
    private String parent; // Child.parent 에 대한 정보 제공
    private Strign childId; // Child.childId 에 대한 정보 제공
}

@Entity
@IdClass(GrandChildId.class)
public class GrandChild {
    @Id
    @ManyToOne
    @JoinColumns({
            @JoinColumn(name = "parent_id"),
            @JoinColumn(name = "child_id")
    })
    private Child child;

    @Id
    private String grandChildId;
}

@EqualsAndHashCode
public class GrandChildId implements Serializable {
    private ChildId child; // GrandChild.child 에 대한 정보 제공
    private String grandChildId; // GrandChild.grandChildId 에 대한 정보 제공
}
```

### @EmbeddedId
@MapsId를 사용하는 방법과 사용하지 않는 방법이 있다.  
**@MapsId는 @Id로 지정한 컬럼에 @OneToOne이나 @OneToMany 관계를 매핑시키는 역할을 한다.**  
<http://docs.jboss.org/hibernate/jpa/2.2/api/javax/persistence/MapsId.html>  
매핑의 대상이 되는 속성은 @OneToOne이나 @OneToMany의 기본키와 타입이 같아야한다  
(짧은 영어라 틀릴수도 있음)  

1. @MapsId를 사용하지 않은 방법이다.  
```java
@Entity
public class Parent {
    @Id
    private String parentId;
}

@Entity
public class Child {
    @EmbeddedId
    private ChildId childId;
}

@EqualsAndHashCode
public class ChildId implements Serializable {
    @ManyToOne
    @JoinColumn(name = "parent_id")
    private Parent parent;

    private String childId;
}

@Entity
public class GrandChild {
    @EmbeddedId
    private GrandChildId grandChildId;
}

@EqualsAndHashCode
public class GrandChildId implements Serializable {
    @ManyToOne
    @JoinColumns({
            @JoinColumn(name = "parent_id"),
            @JoinColumn(name = "child_id")
    })
    private Child child;

    private String grandChildId;
}
```

이게 맞는것 같은데..  

2. @MapsId를 사용한 방법이다  

```java
@Entity
public class Parent {
    @Id
    private String parentId;
}

@Entity
public class Child {
    @EmbeddedId
    private ChildId childId;

    @MapsId("parentId")
    @ManyToOne
    @JoinColumn(name = "parent_id")
    private Parent parent;
}

@EqualsAndHashCode
public class ChildId implements Serializable {
    private String parentId; // @MapsId("paretnId") 로 매핑

    private String childId;
}

@Entity
public class GrandChild {
    @EmbeddedId
    private GrandChildId grandChildId;

    @MapsId("childId")
    @ManyToOne
    @JoinColumns({
            @JoinColumn(name = "parent_id"),
            @JoinColumn(name = "child_id")
    })
    private Child child;
}

@EqualsAndHashCode
public class GrandChildId implements Serializable {
    private ChildId childId;

    private String grandChildId;
}
```

이렇게 구성했을 때는 @IdClass와 별로 다를게 없어 보인다..  

관계를 주입해주면 id가 자동으로 세팅되는 형태로 동작하는 듯 한데, 이러면 편리하긴 할 것 같다.  
첫번쨰 방식을 고수하면 사용에 불편함이 따를 거 같긴한데, 아직 테스트 해보지 못함.  

### 일대일 식별 관계(feat.@MapsId)  
일대일 식별 관계는 자식 테이블의 기본키 값으로 부모 테이블의 기본키 값을 사용하는 조금 특별한 관계이다.  
이 경우 연관관계의 주인이 될 외래키 칼럼이 없으므로 @MapsId를 사용하여 매핑해줘야 한다.  

```java
@Entity
public class Board{
    @Id
    private Long boardId;

    private String title;

    @OneToOne(mappedBy = "board")
    private BoardDetail boardDetail;
}

@Entity
public class BoardDetail{
    @Id
    private Long boardId;

    @Lob
    private String content;

    @MapsId("boardId")
    @OneToOne
    @JoinColumn(name = "board_id")
    private Board board;
}
```

## 비식별 관계 매핑
비식별 관계는 복합키를 사용하지 않기 때문에 아주 심플하다.  

```java
@Entity
public class Parent {
    @Id
    private String parentId;
}

@Entity
public class Child {
    @Id
    private String childId;

    @ManyToOne
    @JoinColumn(name = "parent_id")
    private Parent parent;
}

@Entity
public class GrandChild {
    @Id
    private String grandChildId;

    @ManyToOne
    @JoinColumn(name = "child_id")
    private Child child;
}
```

## 그래서 식별이냐 비식별이냐?  
데이터베이스 설계관점에서 보면, 아래와 같은 이유로 비식별 관계를 선호한다.  

- 식별 관계는 부모 테이블의 기본키를 자식 테이블로 전파하면서 자식 테이블의 기본키 컬럼이 점점 늘어나는 구조이다.  
depth가 깊어질수록 기본키 인덱스가 불필요하게 커지고, 조인할 때 SQL이 복잡해진다.  
- 식별 관계는 2개 이상의 컬럼을 묶어서 복합 기본키를 만들어야 하는 경우가 많다.  
복합 기본키는 컬럼이 하나인 단일 기본키보다 작성하는데 많은 노력이 필요하다.  
- 식별 관계의 경우 기본키로 비즈니스 로직이 있는 자연키 컬럼을 조합하는 경우가 많고,  
비식별 관계의 경우 기본키로 비즈니스와 전혀 관계없는 대리키를 주로 사용한다.  
변하지 않는 요구사항이란 세상에 존재하지 않는다. 자연키 컬럼 조합은 나중에 변경될 가능성이 있다.  
이런 상태에서 식별 관계로 구성할 경우 나중에 변경하기 매우 힘들어진다.  
> e.g. 주민등록번호  
- 언급했듯이 비식별 관계의 경우 대리키를 주로 사용하는데, JPA는 @GeneratedValue 처럼 대리키를 생성하기 위한 편리한 방법을 제공한다.  

그래서 정리하면!  
- 될수있으면 비식별 관계를 사용하고 
- 기본키는 Long 타입의 대리키를 사용히고  
- 필수적 비식별 관계를 사용하자(`optional = false`)

# 조인 테이블
데이터베이스의 테이블의 연관관계를 설정하는 방법은 총 2가지이다.  
- 조인 컬럼  
> 일반적인 외래키 컬럼을 사용하여 연관관계를 관리하는 것  
- 조인 테이블  
> 별도의 테이블을 사용하여 연관관계를 관리하는 것  

조인 테이블의 경우 테이블을 하나 추가해야 된다는 단점이 있다.(추가 조인 필요)  
그러므로 기본적으로 조인 컬럼을 사용하고, 필요할 때만 조인 테이블을 사용하도록 해야한다.  

> 조인 테이블 == 연결 테이블 == 링크 테이블  

현재까지는 다대다 관계에서만 조인 테이블을 사용해왔는데, 일대일, 일대다, 다대일 관계에서도 사용 가능하다.  
다대다 관계의 경우 조인 테이블이 필수지만, 나머지 관계는 아니다.  
메인이 되는 엔티티에 외래키 컬럼을 추가할 수 없을 경우 사용할 수 있는 방법같다.  

## 일대일 조인테이블  
```java
@Entity
public class Parent{
    @Id
    private String parentId;

    @OneToOne
    @JoinTable(name = "parent_child",
        joinColumns = @JoinColumn(name = "parent_id"),
        inverseJoinColumns = @JoinColumn(name = "child_id"))
    private Child child;
}

@Entity
public class Child{
    @Id
    private String childId;

    @OneToOne(mappedBy = "child") // optional
    private Parent parent;
}
```

생성되는 DDL은 아래와 같다.  

```sql
CREATE TABLE parent(
    parent_id integer,
    PRIMARY KEY(parent_id)
)

CREATE TABLE child(
    child_id integer,
    PRIMARY KEY(child_id)
)

CREATE TABLE parent_child(
    parent_id integer,
    child_id integer,
    PRIMARY KEY(parent_id),
    FOREIGN KEY(parent_id) REFERENCES parent(parent_id),
    FOREIGN KEY(child_id) REFERENCES child(child_id)
)
```

사실 조인테이블을 사용했을 때 일대일 관계에 제약조건을 완벽하게 걸수 있는 방법이 없다..  
그러므로 위와 같이 생성된다.  

## 일대다 조인테이블
```java
@Entity
public class Parent{
    @Id
    private String parentId;

    @OneToMany
    @JoinTable(name = "parent_child",
        joinColumns = @JoinColumn(name = "parent_id"),
        inverseJoinColumns = @JoinColumn(name = "child_id"))
    private List<Child> children = new ArrayList<>();
}

@Entity
public class Child{
    @Id
    private String childId;
}
```

일대다 조인컬럼때와 같이 단방향만을 지원한다.  

아래는 생성되는 DDL이다.  

```sql
CREATE TABLE parent(
    parent_id integer,
    PRIMARY KEY(parent_id)
)

CREATE TABLE child(
    child_id integer,
    PRIMARY KEY(child_id)
)

CREATE TABLE parent_child(
    parent_id integer,
    child_id integer,
    PRIMARY KEY(child_id),
    FOREIGN KEY(child_id) REFERENCES child(child_id),
    FOREIGN KEY(parent_id) REFERENCES parent(parent_id)
)
```

다 쪽에 primary key 제약조건이 걸림으로써 일대다 관계 형성이 가능하다.  

## 다대일 조인테이블  
일대다 조인테이블에서 방향만 바꾼 것이다.  

```java
@Entity
public class Parent{
    @Id
    private String parentId;

    @OneToMany(mappedBy = "parent")
    private List<Child> children = new ArrayList<>();
}

@Entity
public class Child{
    @Id
    private String childId;

    @ManyToOne(optional = false)
    @JoinTable(name = "parent_child",
        joinColumns = @JoinColumn(name = "parent_id"),
        inverseJoinColumns = @JoinColumn(name = "child_id"))
    private Parent parent;
}
```

## 다대다 조인테이블  
앞서 나왔으므로 작성하지 않겠다.  
parent_id, child_id 에 각각 FK가 생성되고, PK로 묶이지는 않는다.  

# 엔티티 하나에 여러 테이블 매핑
아까 위의 일대일 식별 관계에서 나왔었던 형태이다.  
> board와 board_detail을 나눠서 저장하고, 같은 PK를 쓰는 형태  

자주 사용하는 형태는 아니지만 가끔 나오기도 한다.  

```java
@Entity
@SecondaryTable(name = "board_detail", // 1
    pkJoinColumns = @PrimaryKeyJoinColumn(name = "board_detail_id")) // 2
public class Board{
    @Id
    private Long boardId;

    private String title;

    @Column(table = "board_detail") // 3
    private String content;
}
```

@SecondaryTable을 사용해 board_detail 테이블을 추가로 매핑했다.  

1. 추가로 매핑할 테이블의 이름이다.  
2. 추가로 매핑된 테이블의 기본키 컬럼명이다.  
3. 추가로 매핑된 테이블에 저장될 속성이다.  

```sql
CREATE TABLE board (
    board_id BIGINT NOT NULL,
    title VARCHAR(255),
    PRIMARY KEY (board_id)
)
    
CREATE TABLE board_detail (
    board_detail_id BIGINT NOT NULL,
    content VARCHAR(255),
    PRIMARY KEY (board_detail_id)
)
```

<!-- more -->