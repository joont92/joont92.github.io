---
title: 객체지향 쿼리 언어
date: 2019-01-01 21:24:46
tags:
---

JPA에서 현재까지 사용했던 `검색`은 아래와 같다.  
- 식별자로 조회 EntityManager.find()  
- 객체 그래프 탐색 e.g. a.getB().getC()

하지만 현실적으로 이 기능만으로 어플리케이션을 개발하기에는 무리이다.  
그렇다고 모든 엔티티를 메모리에 올려두고 어플리케이션 내에서 필터하는 것은 현실성이 없는 소리이다.  
즉, 데이터베이스에서 필터해서 조회해올 무언가가 필요하고, 그게 `객체지향 쿼리 언어(JPQL)`이다.  

조회 방식에는 JPQL말고 몇가지 더 있는데, 아래는 JPA에서 공식 지원하는 검색 방법이다.  
- JPQL
- Criteria
- Native SQL

그리고 아래는 JPA에서 공식 지원하지는 않지만 알아둘 가치가 있는 애들이다.  
- QueryDSL
- JDBC 직접 사용, SQL Mapper(e.g. MyBatis)

# JPQL
엔티티 객체를 조회하는 객체지향 쿼리 언어이다.  
문법은 SQL과 비슷한데, 실제론 SQL을 추상화 한것이기 때문에 특정 데이터베이스에 의존하지 않는 특징이 있다.  

SQL과 비슷하게 SELECT, UPDATE, DELETE 문을 사용할 수 있다.  
(참고로 엔티티 저장은 그냥 entityManager.persist를 사용하면 되므로 INSERT 문은 없다.)  
JPQL에서 UPDATE, DELETE 문은 벌크 연산이라고 해서 뒤에서 따로 설명할 것이므로, SELECT 문만 작성하겠다.  

## 기본 문법  
기본 형태는 아래와 같다.  

```sql
SELECT m FROM Member AS m WHERE m.username = 'Hello'
```

1. 대소문자 구문  
    - 엔티티와 속성은 대소문자를 구분한다. Member와 member는 다르고 username과 USERNAME은 다르다.  
    - SELECT, FROM 같은 JPQL 키워드는 대소문자를 구분하지 않는다.   
2. 엔티티 이름  
    - FROM 이후에 오는 대상은 테이블 이름이 아니라 엔티티 이름이다.  
    - 기본값인 클래스명을 엔티티명으로 사용하는 것을 추천한다.  
3. 별칭은 필수  
    - JPQL은 별칭을 필수로 사용해야 한다. AS 뒤에 `m`이 Member의 별칭이다.  
    - AS는 생략 가능하다.  

### TypedQuery, Query  
작성한 JPQL을 실행시키기 위해 만드는 `쿼리 객체`이다.  
JPQL이 반환할 타입을 명확하게 지정할 수 있으면 TypedQuery를 사용하고, 명확하게 지정할 수 없으면 Query를 사용하면 된다.  

```java
// 조회대상이 정확히 Member 엔티티이므로 TypedQuery 사용 가능
TypedQuery<Member> query = em.createQuery("SELECT m FROM Member m", Member.class);

// 조회대상이 String, Integer로 명확하지 않으므로 Query 사용
Query query = em.createQuery("SELECT m.username, m.age FROM Member m");
```

TypedQuery로 실행된 쿼리는 두번쨰 인자로 주어진 클래스를 반환하고,  
Query의 경우 예제처럼 조회 컬럼이 1개 이상일 경우 `Object[]`, 1개일 경우 `Object`를 반환한다.  

### 결과 조회  
쿼리 객체에서 아래의 메서드들을 사용해 JPQL을 실행한다.  
- query.getResultList()  
> 결과를 컬렉션으로 반환한다. 결과가 없으면 빈 컬렉션이 반환된다. 1건이면 1건만 들어간 컬렉션이 반환된다.  
- query.getSingleResult()  
> 결과가 정확히 1건 일때 사용한다.  
> 결과가 없으면 javax.persistence.NoResultException, 결과가 1건 이상이면 javax.persistence.NonUniqueResultException이 발생한다.  

## 파라미터 바인딩  
아래와 같은 `이름 기준 파라미터 바인딩`을 지원한다.  

```java
TypedQuery<Member> query = 
    em.createQuery("SELECT m FROM Member m WHERE m.username = :username", Member.class)
    .setParameter("username", "joont1"); // JPQL은 대부분 메서드 체인 방식으로 되어있어서 이렇게 연속해서 작성하는 것이 가능하다

List<Member> result = query.getResultLst();
```

username은 Member 클래스에 정의된 프로퍼티 이름이다. 앞에 `:`를 붙여서 바인딩한다.  
username 에 joont1 이 바인딩 될 것이다.  

참고로 아래와 같이 위치 기준 파라미터 바인딩도 지원하기는 한다.  

```java
TypedQuery<Member> query = 
    em.createQuery("SELECT m FROM Member m WHERE m.username = ?1", Member.class)
    .setParameter(1, "joont1");
```

이것보다는 전자가 더 명확하다.  

> **파라미터 바인딩 방식은 선택이 아닌 필수이다**  
> - JPQL에 직접 문자를 더하면 SQL Injection을 당할 수 있다  
> - JPA에서 파라미터만 다를 뿐 같은 쿼리로 인식하므로, JPQL을 SQL로 파싱한 결과를 재사용할 수 있다  
> - SQL 내에서도 같은 쿼리는 결과를 재사용한다  

## 프로젝션  
조회할 대상을 지정하는 것을 프로젝션이라고 한다.  
`SELECT [프로젝션 대상] FROM` 으로 대상을 지정한다.  
대상은 엔티티, 임베디드 타입, 스칼라 타입이 있다.  

### 엔티티 프로젝션  
```sql
SELECT m FROM Member m // member

SELECT m.team FROM Memher m // team
```

둘 다 엔티티를 프로젝션 대상으로 사용했다.  
참고로 이렇게 조회한 엔티티는 영속성 컨텍스트에서 관리된다.  
> JPQL로 조회할 때는 쿼리 캐시가 되어있지 않은 이상 영속성 컨텍스트를 뒤지지 않고 그냥 조회 -> 영속성 컨텍스트에 저장 하지 않을까?  
> JPQL을 실행하면서 영속성 컨텍스트에 있는 애들은 조회하지 않고 하는건 말이 안되는 행위인듯  

### 임베디드 타입 프로젝션  
엔티티를 통해서 조회한다.  

```java
Address address = 
    em.createQuery("SELECT m.address FROM Member m", Address.class)
    .getSingleResult();
```

임베디드 타입은 엔티티 타입이 아닌 값 타입이므로  
이렇게 조회한 임베디드 타입은 영속성 컨텍스트에서 관리되지 않는다.  

### 스칼라 타입 프로젝션  
```java
// 이름조회
TypedQuery<String> query = em.createQuery("SELECT m.username FROM Member m", String.class);
List<String> resultList = query.getResultList();

// 이름조회(중복제거)
TypedQuery<String> query = em.createQuery("SELECT DISTINCT m.username FROM Member m", String.class);
List<String> resultList = query.getResultList();

// 통계 쿼리
TypedQuery<Double> query = em.createQuery("SELECT AVG(o.orderAmount) FROM Order o", Double.class);
List<Double> resultList = query.getResultList();
```

조회되는 컬럼이 1건이라 TypedQuery를 사용하였다. 보다시피 통계 쿼리도 스칼라 타입으로 조회할 수 있다.  

### 여러 값 조회  
아래와 같이 여러값으로 조회했을 때는 TypedQuery를 사용할 수 없고, Query만 사용할 수 있다.  

```java
Query query = em.createQuery("SELECT m.username, m.age, m.team FROM Member m");
List<Object[]> resultList = query.getResultList();

for(Object[] row : resultList){
    String username = (String)row[0];
    Integer age = (Integer)row[1];
    Team team = (Team)row[2];
}
```

물론 아때도 조회한 엔티티는 영속성 컨텍스트에서 관리된다.  

### NEW 명령어  
NEW 명령어를 사용하면 Object[] 대신 바로 객체로 생성해서 받아볼 수 있다.  

```java
TypedQuery<UserDTO> query = 
    em.createQuery("SELECT NEW com.joont.dto.UserDTO(m.username, m.age, m.team) FROM Member m", UserDTO.class);

List<UserDTO> resultList = query.getResultList();
```

기존이라면 하나하나 번거롭게 변환했어야 했을 작업을 NEW 명령어를 사용해서 간단하게 처리했다.  
NEW 명령어를 사용하려면 아래 2가지를 주의해야 한다.  
- 패키지명을 포함한 클래스명을 입력해야 한다  
- 순서와 타입이 일치하는 생성자가 필요하다.  

<!-- more -->