---
title: 웹 어플리케이션과 영속성 관리
date: 2019-02-07 21:53:18
tags:
---

# 트랜잭션 범위의 영속성 컨텍스트  
## 스프링 컨테이너의 기본 전략  
스프링 컨테이너는 `트랜잭션 범위의 영속성 컨텍스트` 전략을 기본으로 사용한다.  
이 전략은 트랜잭션을 시작할 때 영속성 컨텍스트를 생성하고, 트랜잭션이 끝날 때 영속성 컨텍스트를 종료하는 방법이다.  

![트랜잭션 범위의 영속성 컨텍스트](/temp/)

스프링 트랜잭션 AOP는 `@Transactional` 어노테이션이 붙은 메서드가 호출될 때 트랜잭션을 시작한다.  
메서드가 성공적으로 수행되면 해당 트랜잭션을 커밋하고, 예외가 발생한다면 트랜잭션을 롤백한다.  
이 시점에 영속성 컨텍스트에 추가적인 작업을 호출한다.  
- 트랜잭션을 커밋하면(메서드가 성공적으로 수행되면) 영속성 컨텍스트를 플러시해서 변경내용을 반영한 후 데이터베이스 트랜잭션을 커밋한다.  
- 예외가 발생하면 플러시를 호출하지 않고 데이터베이스 트랜잭션을 롤백한다.  

```java
@Controller
class HelloController{
    @Autowired
    private HelloService helloService;

    @PostMapping("/{teamId}/members")
    public String addMember(@PathVariable Integer teamId, @RequestBody MemberDTO memberDTO){
        Member member = helloService.logic(teamId, memberDTO); // 준영속 상태
        // ...

        return "/member/add_result";
    }
}

@Service
class HelloService{
    @Autowired
    private MemberRepository memberRepository;

    @Transactional
    public void logic(Integer teamId, MemberDTO memberDTO){
        Member member = memberRepository.addMember(memberDTO.toEntity());
        Team team = teamRepository.fidnTeam(teamId);
        team.setMemberCnt(team.getMemberCnt()+1);

        return member;
    }
}

@Repository
class MemberRepository{
    @PersistenceContext
    EntityManager em;

    public Member addMember(Member member){
        return em.persist(member);
    }
}

@Repository
class TeamRepository{
    @PersistenceContext
    EntityManager em;

    public Team findTeam(Integer id){
        return em.find(Team.class, id);
    }
}
```

- `logic` 메서드가 실행될 때 트랜잭션이 시작된다.  
- `logic` 메서드가 종료되면 member, team에 대한 변경 내용이 데이터베이스에 플러시되고 트랜잭션이 커밋된다.  
- 예외가 발생하면 변경 내용이 데이터베이스에 플러시되지 않고, 시작한 트랜잭션은 롤백된다.  

트랜잭션과 영속성 컨텍스트의 생명주기가 같으므로, 트랜잭션이 끝남과 동시에 영속성 컨텍스트도 종료된다.  
즉, HelloController에서 logic의 결과로 받은 Member 엔티티는 준영속 상태이다.  

> 참고로 트랜잭션이 같으면 같은 영속성 컨텍스트를 사용한다.  
> 위의 상황에서 `MemberRepository`와 `TeamRepository`는 서로 다른 엔티티 매니저를 주입받았지만 같은 영속성 컨텍스트를 사용한다.  
> 이와 반대로 같은 엔티티 매니저를 사용해도 트랜잭션이 다르면 다른 영속성 컨텍스트를 사용한다(잘 안그려진다 상황이..)  

# 준영속 상태와 지연로딩  
위에서 언급했듯이 트랜잭션과 영속성 컨텍스트의 생명주기가 같기 때문에, 트랜잭션이 끝난 뒤의 엔티티는 준영속 상태가 된다.  
즉 위의 상황에서 `logic` 메서드가 끝남과 동시에 영속성 컨텍스트도 종료되었기 때문에 결과로 반환된 Member 엔티티는 준영속 상태가 되는 것이다.  
그리고 당연하게도, 준영속 상태인 엔티티에 지연로딩을 수행하게 되면 오류가 발생한다.  

```java
@Controller
class HelloController{
    @Autowired
    private HelloService helloService;

    @PostMapping("/{teamId}/members")
    public String addMember(
        @PathVariable Integer teamId, 
        @RequestBody MemberDTO memberDTO, 
        ModelMap modelMap){

        Member member = helloService.logic(teamId, memberDTO);
        // ...

        modelMap.add("member", member);
        modelMap.add("teamName", member.getTeam().getName()); // lazy loading! but an exception occured

        return "/member/add_result";
    }
}
```

위처럼 지연로딩을 하게 되면 하이버네이트 기준으로 `org.hibernate.LazyInitializationException`이 발생한다.  
이는 영속성 컨텍스트에 들어있지 않은 준영속 상태의 엔티티에 지연로딩을 시도했기 때문에 발생하는 것이다.  
트랜잭션이 끝나면서 영속성 컨텍스트도 같이 종료되었기 때문에 반환된 엔티티는 자연스럽게 준영속 상태가 되었고, 이런 현상이 발생한 것이다.  

하지만 생각해보면, 영속성 컨텍스트가 트랜잭션과 동시에 종료되고 프레젠테이션 계층까지 전파되지 않는것은 좋은 선택(?)이다.  
만약 영속성 컨텍스트를 프레젠테이션 계층까지 열어두었다면 프레젠테이션 계층에서도 변경 감지가 동작하게 되어 위험하고,  
각 계층이 가지는 역할자체도 모호해지기 때문이다.  

하지만 위에서 봤다시피, 지연로딩이 동작하지 않는다는 점은 꽤나 골치아픈 일이다.  
결국 위의 상황을 해결하고 싶으면 아래의 2가지 방법을 사용해야 한다.  

## 뷰에 필요한 엔티티를 미리 로딩해두는 방법
말 그대로 영속성 컨텍스트가 살아있을 때 뷰에 필요한 엔티티들을 미리 다 로딩하거나 초기화해서 반환하는 방법이다.  
아래의 3가지 방법이 있다.  

### 글로벌 페치 전략 수정  
fetchType을 EAGER로 바꾸는 방법이다.  

```java
class Member{
    @ManyToOne(fetch=FetchType.EAGER)
    @JoinColumn(name = "team_id")
    private Team team;
}
```

Member 조회 시 항상 Team을 같이 로딩해서 가지게 되므로, 준영속 상태가 되어도 지연로딩 문제가 발생하지 않는다.  
이미 로딩해서 가지고 있기 때문이다.  

하지만 이 방식은 아래와 같은 문제를 가진다.  
- **사용하지 않는 엔티티를 로딩한다**  
    뷰에서 Team이 필요하지 않은 경우도 있을것이다. 하지만 항상 Team을 같이 조회해야 한다.  
- **N+1 문제가 발생한다**  
    ```java
    String sql = "SELECT m FROM Member m";
    List<Member> members = em.createQuery(sql, Member.class).getResultList();
    ```
    실행되는 SQL은 아래와 같다.  
    ```sql
    SELECT * FROM Member;
    SELECT * FROM Team WHERE id = ?;
    SELECT * FROM Team WHERE id = ?;
    SELECT * FROM Team WHERE id = ?;
    SELECT * FROM Team WHERE id = ?;
    ....
    ```
    JPQL을 실행할 때는 글로벌 페치 전략을 참고하지 않고 오직 JPQL만 참고하여 충실히 SQL을 만들기 때문에 발생한 현상이다.  
    위와 같이 처음 조회한 수만큼 다시 SQL을 사용해서 조회하는 것을 N+1 문제라고 한다.  

### JPQL FetchJoin  
봤다시피 fetchType을 EAGER로 바꾸는건 너무 비효율적이다.  
fetchType을 LAZY로 설정하고 필요할 때만 같이 조회해오도록 하는것이 좋을 것이고, JPQL에서는 FetchJoin이라는 기능으로 이를 지원한다.  
사용법은 간단하다.  

```java
String sql = "SELECT m FROM Member m JOIN FETCH m.team";
List<Member> members = em.createQuery(sql, Member.class).getResultList();
```

간단히 조인 명령어 마지막에 `FETCH` 만 넣어주면 된다.  
이렇게 하면 해당 대상까지 조인으로 함꼐 조회해온 뒤 엔티티에 바인딩해준다.  

이 방식이 현실적인 대안이긴 하지만, 화면에 맞춘 리파지토리 메서드가 증가할 수 있다는 단점이 있다.  
즉, 아래와 같은 메서드들이 생길 수 있다는 것이다.  

- Member만 조회해오는 `repository.findMember` 메서드  
- Member와 연관된 Team 까지 조회해오는 `repository.findMemberWithTeam` 메서드  

이런식으로 계속 메서드가 추가되다보면 레파지토리와 뷰 간의 논리적인 의존관계가 발생하게 된다.  
이런 상황에서는 최적화를 조금 포기하고 논리적 의존관계를 최소화하는 방법을 선택하던지(findMember와 findmemberWithTeam 통합),  
최적화를 선택하고 논리적 의존관계를 가지고 가던지.. 선택해야 한다.  

사실상 성능에 미치는 영향이 미비하므로 뷰와 레파지토리의 의존관계가 급격하게 증가하는 것보다는 최적화를 포기하는것이 조금 나은 것 같다.  

### 강제로 초기화  


<!-- more -->