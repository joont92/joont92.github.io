---
title: '프록시와 연관관계 관리'
date: 2018-12-18 21:08:47
tags:
  - FetchType.EAGER
  - FetchType.LAZY
  - 지연 로딩  
  - Cascade
  - orphanRemoval
---

# 프록시  

# em.getReference()

# 즉시로딩, 지연로딩  

# 영속성 전이  

# 고아 객체  









처음 로딩될 때 proxy 객체들을 따로 저장해두는 것으로 보인다.(getReference에서 추적)  

```java
// 초기화
public void initialize(MetadataImplementor mappingMetadata, JpaMetaModelPopulationSetting jpaMetaModelPopulationSetting) {
  // ...
  for ( final PersistentClass model : mappingMetadata.getEntityBindings() ) {
    // ...
    // entity 객체 저장
    entityPersisterMap.put( model.getEntityName(), cp ); 

    // ....
    // proxy 객체 저장
    final String old = entityProxyInterfaceMap.put( cp.getConcreteProxyClass(), cp.getEntityName() );
    // ...
  }
}

// 사용
@Override
public EntityPersister locateEntityPersister(Class byClass) {
	EntityPersister entityPersister = entityPersisterMap.get( byClass.getName() );
	if ( entityPersister == null ) {
		String mappedEntityName = entityProxyInterfaceMap.get( byClass );
    // ...
  }
}
```

```java
Order foundOrder = em.find(Order.class, 2);
assertNotNull(foundOrder.getMember());
assertThat(foundOrder.getMember().getId(), is(1)); // lazy loading 하지 않음
```

# 프록시  
delegate pattern이라는건 딱히 없는듯 하고, proxy pattern 에서 delegate를 사용  
decorator pattern에서 프록시 패턴을 사용함  
proxy pattern은 다목적으로 사용됨.  
decorator로 사용할수도 있고, remote api를 호출할수도 있고 , 

# 영속성 전이  
CascadeType.PERSIST에서 꼭 자식이 부모를 setting 하지 않아도 됨  
부모의 컬렉션에 들어간 상태이기만 하면 됨  


# 이상한 점  
CascadeType.ALL 이 persist에만 동작하는 것이 아니다.  
add의 변경감지에도 동작하는데, 부모의 값이 들어가지 않은 상태로 동작한다. 대체 무슨 현상이지?  

CascadeType.PERSIST는 persist에만 동작하는 것이 아님.  
부모가 변경감지 될때도 PERSIST가 동작함!  
flush 할때 동작하는 것임  
그러면 링크테이블에서는 cascade를 적용할 수 없다. 어떻게 해야하는가?  



<!-- more -->
