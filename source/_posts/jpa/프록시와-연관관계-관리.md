---
title: '프록시와 연관관계 관리'
date: 2018-12-18 21:08:47
tags:
  - FetchType.EAGER
  - FetchType.LAZY
  - 지연 로딩  
  - Cascade
  - orphanRemoval
---

JPA에는 `지연 로딩`이라는 기능이 있다.  
아래와 같은 엔티티가 있다고 할 때,  

```java
@Entity
class Member{
    @Id
    private Long id;

    // ...

    @ManyToOne
    @JoinColumn(name = "team_id")
    private Team team;
}

@Entity
class Team{
    @Id
    private Long id;

    // ...
}
```

아래와 같이 Member를 조회하면 Team 테이블이 left join 되어 같이 조회되었었다.  

```java
Member member = em.find(Member.class, 1);
// do something
```

```sql
SELECT T.*
FROM MEMBER M
    INNER JOIN TEAM T ON M.TEAM_ID = T.ID
WHERE M.ID = 1;
```

만약 Member 테이블만 필요하다고 하면, 매번 위처럼 조회되는 것은 매우 비효율적이다.  
JPA는 이런 상황을 위해 `지연 로딩`이라는 기능(명세?)을 제공한다.  
말 그대로 지연해서 로딩하는 것으로써, Member의 Team이 실제로 사용되는 순간에 해당 엔티티를 데이터베이스에서 조회해올 수 있다.  

> JPA의 표준 명세는 지연로딩의 구현 방법을 JPA 구현체에 위임했다.  
> 하이버네이트는 지연로딩을 지원하기 위해 `프록시를 사용하는 방법`과 바이트코드를 수정하는 방법을 사용한다.  

# em.getReference()
EntityManager의 `getRefernece()` 메서드를 호출하면 엔티티를 바로 조회해오지 않고, 실제 사용하는 시점에 조회해올 수 있다.(find는 바로 조회해온다)  
이러한 지연 로딩을 지원하기 위해 프록시 객체를 사용하는데, 반환되는 프록시 객체의 모습은 아마 아래와 같을 것이다.  

```java
class MemberProxy extends Member{
    Member target = null;

    public String getName(){
        if(target == null){
            // DB 조회  
            // 실제 엔티티 생성 및 참조 보관  
            this.target = // ...
        }

        return this.target.getName();  
    }
}

// 사용
@Test
public void getReferneceTest(){
    Member member = Member.getReference(Member.class, 1);
    member.getName();
}
```

보다시피 프록시 객체는 상속을 사용하여 구현한다.  
`if(target == null)` 내부에서 영속성 컨텍스트에 의해  
데이터베이스를 조회해 실제 엔티티를 생성하는 것을 `프록시 객체의 초기화`라고 한다.  
흐름은 아래와 같다.(영속성 컨텍스트는 비어있다고 가정한다)  

1. getReference()를 호출하면 프록시 객체를 생성한 뒤 1차 캐시에 저장한다.  
2. 실제 데이터를 얻기 위해 getName()을 호출한다.  
2. 프록시 객체는 영속성 컨텍스트에 실제 엔티티 생성을 요청한다(초기화)  
3. 영속성 컨텍스트는 데이터베이스를 조회해서 실제 엔티티 객체를 생성하고, 해당 객체의 참조를 target 변수에 보관한다.  
4. 프록시 객체는 target 변수에 저장된 실제 엔티티 객체의 getName()을 호출해서 결과를 반환한다.  

> 영속성 컨텍스트에 저장한다, 영속성 컨텍스트를 통해 조회해온다 라는 말이 혼란을 가중시킴.  
> 영속성 컨텍스트가 너무 큰 개념이라..  

프록시 객체는 다음과 같은 특징을 가진다.  
- 프록시 객체의 초기화는 딱 한번만 실행된다. target 객체에 저장하고, 그를 사용하기 때문이다.  
- 원본 엔티티를 상속받은 객체이므로 타입 체크에 주의해야 한다.  
- 영속성 컨텍스트에 찾는 엔티티가 이미 있으면(식별자로 조회), em.getReference()로 조회하더라도 실제 엔티티를 반환한다.  
```java
Member member1 = em.getReference(Member.class, 1);
Member member2 = em.find(Member.class, 1);

System.out.println("member1 : " + member1.getClass().getName());
System.out.println("member2 : " + member2.getClass().getName());
```

> member1 : Member$HibernateProxy$8guhz2id
> memver2 : Member$HibernateProxy$8guhz2id  

처음 호출될 때 식별자를 이용해 1차 캐시에 저장하고,  
초기화 되면 해당 프록시 객체내의 target 변수에 값이 저장되게 되는것이다.  
이후에 em.find로 엔티티를 조회해와도 이미 프록시 객체가 저장되어 있기 떄문에 해당 객체가 반환된다.  
영속성 컨텍스트에 실제 객체가 있으면 getReference()가 호출되는 것과 동일한 원리.  

## 프록시와 식별자  
프록시 객체는 target 변수만 가지고 있는것이 아니라, 전달받은 식별자 값도 같이 저장한다.  
그러므로 아래와 같이 식별자 값만 조회할 경우 직접적인 데이터베이스 조회가 일어나지 않는다.  

```java
Member member = em.getRefernece(Member.class, 1);
member.getId(); // SQL 실행하지 않음  
```

이러한 특징을 이용하면 연관관게를 설정할 때 유용하게 사용할 수 있다.  

```java
Member member = new Member();
member.setName("joont");
member.setAge(27);

// team setting
Team team = em.getReference(Team.class, 1);
member.setTeam(team);

em.persist(member);
```

데이터베이스에서 연관관계를 설정할때 외래키로 해당 데이터베이스의 식별자밖에 사용하지 않는다.  
즉, member를 persist 할 때 team의 id만 필요할것이고, 실제로도 그렇게 처리될것이다.  
이럴 경우 team을 전체 조회해오는 find 보다는 getReference()를 사용해서 데이터베이스 접근 횟수를 줄일 수 있다.  

## 프록시 확인  
JPA에서 제공하는 `PersistenceUnitUtil.isLoaded(Object entity)` 메서드를 사용하면 프록시 객체의 초기화 여부를 확인할 수 있다.  
아직 초기화 되지 않은 엔티티의 경우 false를 반환한다.  
쓸일이 있을랑가...  

# 즉시로딩, 지연로딩  
JPA에서는 연관된 엔티티를 조회해올 때도 프록시 객체를 사용하여 지연로딩을 할 수 있다.  
지연로딩 여부는 연관관계를 맺는 어노테이션(@ManyToOne, @OneToMany...)의 속성(fetch)으로 제공하여 상황에 따라 개발자가 선택해서 사용할 수 있게 해준다.  

제공되는 속성은 즉시로딩, 지연로딩 두 가지이다.  

## 즉시로딩
`fetch` 속성을 `FetchType.EAGER`로 주면 된다.  

```java
@Entity
class Member{
    @Id
    private Long id;

    @ManyToOne(fetch = FetchType.EAGER) // 즉시로딩으로 설정
    @JoinColumn(name = "team_id")
    private Team team;
}
```

```java
Member member = em.find(Member.class, 1); // team 까지 같이 조회됨  
Team team = em.getTeam(); // 실제 엔티티
```

이렇게 설정해두면 Member 엔티티가 조회될 때 Team 엔티티가 항상 같이 조회된다.  
대부분의 JPA 구현체는 즉시로딩을 최적화하기 위해 가능하면 조인 쿼리를 사용한다.  

## 지연로딩  
`fetch` 속성을 `FetchType.LAZY`로 주면 된다.  

```java
@Entity
class Member{
    @Id
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY) // 지연로딩으로 설정
    @JoinColumn(name = "team_id")
    private Team team;
}
```

```java
Member member = em.find(Member.class, 1);  
Team team = member.getTeam(); // 프록시 객체
team.getName(); // 이때 조회됨!
```

`em.find(Member.class, 1)`을 호출하면 Member만 조회하고 team 멤버변수에는 프록시 객체를 넣어둔다.  
그리고 아래 실제 사용되는 부분에서 데이터가 조회된다.(동작 방식은 em.getReference()와 동일하다)  
사용 시점에 조회해오므로 쿼리는 당연히 따로따로 날라간다.  

> **컬렉션 래퍼**  
하이버네이트는 엔티티를 영속상태로 만들 때 엔티티에 컬렉션이 있으면  
해당 컬렉션을 추적하고 관리할 목적으로 원본 컬렉션을 하이버네이트가 제공하는 내장 컬렉션으로 변경한다.  
이를 컬렉션 래퍼라고 하고, `org.hibernate.collection.internal.PersistentBag` 클래스이다.  
에 클래스가 컬렉션 레벨에서 프록시 객체의 역할까지 같이 해주므로, 이 클래스를 통해 지연로딩을 달성할 수 있다.  
참고로 컬렉션의 실제 데이터를 조회할 때 데이터베이스를 조회해서 초기화한다.  

```java
member.getTeam(); // SQL 실행안함  
member.getTeam().get(0); // SQL 실행
```

## 그래서 뭘 설정해야 하는데?  
양방향 연관관계 설정과 똑같다. 사용되는 곳에 따라 어떤 전략을 선택하면 좋을지 체크해보고, 선택하면 된다.  
참고로 각 연관관계들은 default fetch 값이 있다.  

- @OneToOne : EAGER
- @ManyToOne : EAGER
- @OneToMany : LAZY
- @ManyToMany : LAZY

보다시피 default값은  
추가적으로 하나만 로딩해도 될때는 즉시로딩 되도록,  
추가적으로 많은 데이터가 로딩될 수 있을 경우에는 지연로딩 되도록 설정되어 있다.  
(컬렉션을 로딩하는 것은 비용도 많이들고, 한번에 너무 많은 데이터를 로딩할 수 있기 때문이다.)  

추천하는 방법은 전부 `FetchType.LAZY`를 사용하는 것이다.  
그리고 어플리케이션 개발이 어느정도 완료단계에 왔을 때, 실제 사용 상황을 보고 꼭 필요한 곳에만 즉시 로딩을 사용하도록 최적화하면 된다.  

참고로 SQL Mapper를 사용하면 이런 유연한 최적화가 어렵다.(ㅎㅎ)  

## 컬렉션에 FetchType.EAGER를 사용할 때 주의할 점  
1. **EAGER를 하나 이상 설정하는 것은 권장하지 않는다.**  
컬렉션은 기본적으로 일대다 관계에서 사용되므로, 조인되는 테이블이 많아질수록 출력되는 row가 급격하게 증가하기 때문이다.  
예를 들어 A 테이블과 N, M 테이블을 일대다 조인하면 N * M 개수의 행이 반환되고, 결과적으로 성능이 저하될 수 있다.  
또한 JPA는 이렇게 조회된 결과 N과 M을 메모리에서 필터링 해서 반환하므로, 2개 이상의 컬렉션을 즉시 로딩으로 설정하는 것은 권장되지 않는다.  

2. **컬렉션 즉시 로딩은 항상 `외부 조인`을 사용한다.**  
내부 조인을 사용하면 자식이 없는 엔티티가 조회되지 않는 결과가 발생한다.  
이를 제약조건으로 막을 수 있는 방법이 없으므로, 무조건 외부 조인을 사용한다.  

# 영속성 전이(CASCADE)
특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들고 싶을 때 영속성 전이를 사용한다.  
CASCADE라는 옵션으로 제공하고, 실제 데이터베이스의 CASCADE와 동일하다.  

JPA에서 엔티티를 저장할 때 연관된 모든 엔티티는 영속 상태여야 하므로, 아래와 같이 저장해야 한다.  

```java
Parent parent = new Parent();
em.persist(parent);

Child child1 = new Child();
child1.setParent(parent);
em.persist(child1);

Child child2 = new Child();
child2.setParent(parent);
em.persist(child2);
```

여기에 영속성 전이 속성 중 하나인 `CascadeType.PERSIST`를 적용하면 부모만 영속화 함으로써 자식까지 한번에 모두 영속화 할 수 있다.  

```java
@Entity
class Parent{
    @OntToMany(mappedBy = "parent", cascade = CascadeType.PERSIST)
    private List<Child> children = new ArrayList<>();
}
```

```java
Parent parent = new Parent();

Child child1 = new Child();
Child child2 = new Child();
parent.addChild(child1);
parent.addChild(child2);

em.persist(parent);
```

영속성 전이되서 실행됨..  

해야할 것  
CascadeType이 뭘 의미하는지 각각 보기  
CascadeType을 바꿔가며 적용해보기  

# 고아 객체  









처음 로딩될 때 proxy 객체들을 따로 저장해두는 것으로 보인다.(getReference에서 추적)  

```java
// 초기화
public void initialize(MetadataImplementor mappingMetadata, JpaMetaModelPopulationSetting jpaMetaModelPopulationSetting) {
  // ...
  for ( final PersistentClass model : mappingMetadata.getEntityBindings() ) {
    // ...
    // entity 객체 저장
    entityPersisterMap.put( model.getEntityName(), cp ); 

    // ....
    // proxy 객체 저장
    final String old = entityProxyInterfaceMap.put( cp.getConcreteProxyClass(), cp.getEntityName() );
    // ...
  }
}

// 사용
@Override
public EntityPersister locateEntityPersister(Class byClass) {
	EntityPersister entityPersister = entityPersisterMap.get( byClass.getName() );
	if ( entityPersister == null ) {
		String mappedEntityName = entityProxyInterfaceMap.get( byClass );
    // ...
  }
}
```

```java
Order foundOrder = em.find(Order.class, 2);
assertNotNull(foundOrder.getMember());
assertThat(foundOrder.getMember().getId(), is(1)); // lazy loading 하지 않음
```

# 프록시  
delegate pattern이라는건 딱히 없는듯 하고, proxy pattern 에서 delegate를 사용  
decorator pattern에서 프록시 패턴을 사용함  
proxy pattern은 다목적으로 사용됨.  
decorator로 사용할수도 있고, remote api를 호출할수도 있고 , 

# 영속성 전이  
CascadeType.PERSIST에서 꼭 자식이 부모를 setting 하지 않아도 됨  
부모의 컬렉션에 들어간 상태이기만 하면 됨  


# 이상한 점(내일 탐구 예정)
CascadeType.ALL 이 persist에만 동작하는 것이 아니다.  
add의 변경감지에도 동작하는데, 부모의 값이 들어가지 않은 상태로 동작한다. 대체 무슨 현상이지?  

CascadeType.PERSIST는 persist에만 동작하는 것이 아님.  
부모가 변경감지 될때도 PERSIST가 동작함!  
flush 할때 동작하는 것임  
그러면 링크테이블에서는 cascade를 적용할 수 없다. 어떻게 해야하는가?  



<!-- more -->
