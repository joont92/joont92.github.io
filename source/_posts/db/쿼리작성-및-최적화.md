---
title: 쿼리작성 및 최적화
date: 2017-12-13 23:07:04
tags:
---

### 시스템 설정
#### SQL 모드  
MySql 서버에는 sql_mode 라는 시스템 설정이 있다.  
이 설정을 통해 SQL의 작성, 결과 등에 영향을 주게 된다.  
ANSI, STRICT_TRANS_TABLES, TRANDITIONAL, ONLY_FULL_GROUP_BY 등등..  
``my.cnf`` 파일에 
```
sql_mode=STRICT_TRANS_TABLES,ANSI
```
의 형태로 작성해주면 된다. ,로 구분하여 여러개 지정할 수 있다.  

#### 영문 대소문자
MySql은 설치된 운영체제에 따라 테이블의 대소문자를 구분한다.ex) 윈도우 : 구분X, 리눅스 : 구분O  
DB나 테이블이 디스크의 디렉터리나 파일로 매핑되기 때문이다.  
가능하면 대문자만 또는 소문자만으로 통일하는 것이 좋다.  

#### 예약어
일반적으로 테이블이나 컬럼 생성 시 예약어를 이름으로 사용하면 에러가 발생한다.  
그러나 역따옴표(\`)나 쌍따옴표(\")로 감싸면 이를 피할 수 있다.  
예를 들면 테이블 생성 시 역따옴표(\`)로 둘러싸면 에러를 발생시키지 않는다.  
하지만 역따옴표로 둘러싸서 생성하는 것을 권장하지는 않는다.  

---

### 메뉴얼 읽는 법  
![image](https://user-images.githubusercontent.com/18513953/33943893-c5f3443a-e05d-11e7-8ebd-fbff301bbf42.png)   
> - 대문자는 키워드를 의미한다.  
> - 이텔릭체는 사용자가 작성하는 이름 또는 표현식을 의미한다.  
> - 대괄호(\[\])는 선택사항임을 의미한다.  
> - 파이프(\|)는 연결된 것 중 단 하나만 선택할 수 있음을 의미한다.
> - 중괄호(\{\})는 괄호 내 선택사항 중 반드시 하나를 선택해야 함을 의미한다.
> - ...는 앞에 명시된 키워드나 표현이 반복될 수 있음을 의미한다.

---

### MySQL 연산자, 내장함수  
#### 리터럴   
##### 문자열   
항상 홑따옴표(\')를 사용해서 표시한다.  
홑따옴표 자체를 사용하고 싶을 때는 홑따옴표를 두번 연속 입력하면 된다.  
쌍따옴표와 홑따옴표의 조합으로 위의 행위를 할 수 있지만 MySql만 지원되는 방식이다.

##### 숫자   
다른 시스템들과 동일하게 \'나 \" 없이 숫자 값을 입력하면 된다.  
> **※ 자동 형 변환**  
MySql에서는 문자와 숫자를 비교할 때 자동으로 숫자값으로 형 변환해준다. (숫자 > 문자)      
```
WHERE number_col = '10001';  
```
>와 같은 경우는 문제가 되지 않지만,  
```
WHERE string_col = 10001;
```
>의 경우에는 문제가 발생할 수 있다.  
위와 같은 경우 오른쪽 숫자가 우선순위가 더 높으므로  
왼쪽의 string_col이 숫자로 형 변환하는 상황이 발생하는데,  
이로 인해 string_col은 인덱스를 사용하지 못하고,  
만약 문자값이 포함된 데이터가 있다면 SQL 실행 오류로도 이어진다.

##### 날짜   
MySql에서 정해진 형태의 포멧으로 날짜를 입력하면(문자열로),  
MySQL에서 자동으로 DATE나 DATETIME으로 변환하여 준다.  
위의 숫자 리터럴과 동일하다. (날짜 > 문자)

##### 불리언  
BOOLEAN이란 타입이 있긴 하나 실상 TINYINT에 대한 동의어일 뿐이다.  
(테이블 컬럼 타입을 BOOLEAN으로 생성한 뒤 확인해보면 TINYINT 이다.)  
BOOLEAN의 TRUE는 1을 의미하고, FALSE는 0을 의미한다.  
0과 1만을 사용한다는 점을 주의해야 한다!!  

#### 연산자  
##### 동등 비교  
=, <=>   
기본적으로 NULL과의 연산은 결과값이 모두 NULL이다.  
```SQL
SELECT NULL=1 FROM DUAL;
```
\> NULL  

그래서 NULL의 경우 IS NULL등의 연산자로 비교해야 하는데, <=> 의 경우에는 NULL 또한 하나의 값으로 인식하여 계산한다.  
```SQL
SELECT NULL<=>NULL FROM DUAL;
```
\> 1

##### 부정 비교    
<>, !=  
둘중 어느것을 사용하든 상관없지만 통일하는 것이 좋다.  

##### NOT 연산자    
결과를 반대로 만든다. 부정의 결과를 정확히 예측할 수 없는 경우 사용하지 말자.  
ex) !'test'    

##### AND, OR 연산자   
&&, ||로 대체할 수 있으나 혼란을 야기하니 사용하지 말자.  

##### 나누기, 나머지 연산자   
```SQL
SELECT 29/9 FROM DUAL;
-- 3.222.. // 몫 + 나머지
SELECT 29 DIV 9 FROM DUAL;
-- 3 // 몫
SELECT 29 MOD 9 FROM DUAL;
-- 2 // 나머지
```

##### LIKE 연산자   
상수 문자열이 있는지 없는지 정도만을 판단한다.  
와일드 카드는 딱 2개만 사용가능하다.  
> **%** : 0개 또는 1개 이상 일치  
**_** : 정확히 1개 일치

와일드카드 문자가 검색어의 뒤쪽에 있다면 인덱스 레인지 스캔을 사용할 수 있다!  
와일드카드가 앞쪽에 올 경우 인덱스 풀 스캔 또는 테이블 풀 스캔을 하게 된다.  

와일드카드 문자를 검색에 사용하고 싶을 경우 ESCAPE 구문을 사용한다.  
```SQL
SELECT 'a%' LIKE 'a/%' ESCAPE '/' FROM DUAL;
```

##### BETWEEN 연산자   
=< 연산자와 => 연산자를 합친 기능을 수행한다.  
BETWEEN을 위의 연산자로 풀어도 성능상 차이가 없으니 크게 고려하지 않아도 된다.  

##### IN 연산자  
**동등비교를 여러번** 하는 연산자이다. 즉 일반적으로 빠르게 처리된다.  
연산자의 입력이 상수가 아니라 서브쿼리일 경우 상당히 느려질 수 있으니 주의해야 한다.  
NOT IN의 경우 부정형 비교여서 인덱스 풀 스캔을 사용한다.  

> **※ BETWEEN 연산자와 IN 연산자 차이점**  
BETWEEN의 경우 범위만큼 인덱스를 다 읽어야 하는 반면,  
IN의 경우 위에서 언급했듯이 동등 연산자를 여러번 수행하는 것과 같다.  
실행계획을 비교해보면 인덱스를 타고 있지만 rows에서 차이가 나는것을 확인할 수 있다.  

#### 내장함수
##### NULL 값 비교
- **IFNULL** : 값이 NULL인지 비교하고 NULL이면 다른 값으로 대체한다.  
첫번째 인자는 NULL인지 비교할 값, 두번째 인자는 NULL일시 대체값이다.  
첫번째 인자가 NULL이 아닐경우 그대로 출력된다.  
- **ISNULL** : 값이 NULL인지 아닌지 비교. NULL일 경우 TRUE(1), 아닐경우 FALSE(0)

##### 현재 시각 조회  
- **NOW** : 시간 조회. 하나의 SQL내면 모두 같은 값을 가진다.
- **SYSDATE** : 시간 조회. 하나의 SQL내에서도 호출 시점에 따라 결과값이 달라진다.
```SQL
SELECT NOW(), SLEEP(1), NOW() FROM DUAL;
-- '2017-12-19 22:39:52' | '0' | '2017-12-19 22:39:52'
SELECT SYSDATE(), SLEEP(1), SYSDATE() FROM DUAL;
-- '2017-12-19 22:40:27' | '0' | '2017-12-19 22:40:28'
```
보다시피 SYSDATE의 경우 SLEEP(1)로 인해 1초가 차이난다.  
SYSDATE의 경우 호출때마다 다른 값을 반환하므로 상수가 아니다.  
그래서 인덱스를 효율적으로 사용하지 못한다.  
이러한 문제점이 있으니 SYSDATE는 가급적 사용하지 않는것이 좋다.  
CURRENT_TIMESTAMP, CURRNET_DATE, CURRENT_TIME은 NOW와 동일한데다 출력을 다양하게 활용할 수 있으니 이것을 사용해도 좋을 것 같다.  

##### 날짜 <> 문자
| 지정 문자 | 내용 |
| :--- | :--- |
| %Y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |4자리 연도|
| %y |2자리 연도|
| %m |월|
| %d |일자|
| %H |24h 시간(00 ~ 23)|
| %h |12h 시간(01 ~ 12)|
| %i |분|
| %s |초|
- **DATE_FORMAT** : 날짜를 문자열로 변환한다.  
ex) DATE_FORMAT(NOW(), %Y-%m-%d)  
\> 2017-12-19
- **STR_TO_DATE** : 문자를 날짜로 변환한다.  
ex) STR_TO_DATE('1992^02^07^','%Y^%m^%d')  
\> 1992-02-07  
참고로 SQL 표준형태로 입력된 문자열은 STR_TO_DATE를 사용하지 않아도 자동으로 DATETIME으로 변환되어 처리된다.

##### 날짜 연산
- **DATE_ADD** : 첫번째 인자로 날짜, 두번째 인자로 더할 날짜를 주면 된다.  
두번째 인자는 INTERVAL n {KEYWORD} 의 형태로 줘야 한다.  
DATE_SUB 함수도 있으나 두번째 인자로 음수값을 줄 수 있기 때문에 DATE_ADD만으로도 충분하다.  
ex) DATE_ADD(NOW(), INTERVAL 3 DAY)  
※ KEYWORD : YEAR, MONTH, WEEK, DAY, HOUR ...  

##### 문자열 처리
- **LPAD, RPAD** : 좌측 혹은 우측에 특정한 문자를 지정한 바이트 만큼 채우는 함수이다.  
첫번째 인자로 대상 문자열, 두번째 인자로 채울 바이트(첫번째 문자 포함), 세번째 인자로 채울 문자를 넣는다.  
- **LTRIM, RTRIM, TRIM** : 연속된 공백문자를 제거하는 함수이다.  
LTRIM은 왼쪽, RTRIM은 오른쪽, TRIM은 양쪽의 공백을 제거한다.  

##### 문자열 결합
- **CONCAT** : 문자열을 결합해서 하나의 문자열로 합치는 함수로 인자 개수는 제한이 없다.  
ex) CONCAT('My name is ', 'JoonT. ', 'Nice to ', 'meet you.');
\> My name is JoonT. Nice to meet you.

##### 타입 변환
- **CAST** : 명시적 형 변환을 하는 함수이다.변환할 값과 변환할 타입을 지정해주면 된다. 둘은 AS 로 연결한다.  
ex) CASE('1234', AS INTEGER)  

##### IP 주소 변환
IP주소를 UNSIGNED INTEGER의 형태로 상호변환 가능하다.
- **INET_ATON** : IP 주소 -> UNSIGNED INTEGER
- **INET_NTOA** : UNSIGNED INTEGER -> IP 주소  
ex) 
```SQL
SELECT name, INET_NTOA(ip_addr) 
FROM TEST 
WHERE ip_addr BETWEEN 
INET_ATON('192.168.0.1') AND INET_ATON('192.168.0.100');
```
훨씬 효과적으로 저장 및 조회가 가능하다.  

#### 주석
```SQL
--- 한줄 주석(SQL 표준)

/*
여러줄 주석(SQL 표준)

여러줄
여러줄
여러분
*/ 

# 한줄주석(비표준)

```