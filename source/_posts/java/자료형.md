---
title: '[java] 자료형'
date: 2017-12-12 22:55:49
tags:
  - java 형 변환
  - primitive type
---

# 기본형(Primitive Type)
자료형 | 표현 데이터 | 크기 | 범위
- | - | - | -
boolean | 참/거짓 | 1byte | true, false
char | 문자 | 2byte | 모든 유니코드 문자    
byte | 정수 | 1byte | -128 ~ 127
short | 정수 | 2byte | -32768 ~ 32767
int | 정수 | 4byte | -2147483648 ~ 2147483647
long | 정수 | 8byte | -9223372036854775808 ~ 9223372036854775807
float | 실수 | 4byte | 1.4E-45 ~ 3.4028235E38
double | 실수 | 8byte | 4.9E-324 ~ 1.7976931348623157E308  

## 범위에 대한 기본 개념
1byte를 예로 들어보자  
1byte는 8bit 이므로, 0000 0000 ~ 1111 1111 까지 표현이 가능하다  
이 값은 0 ~ 255 까지의 값인데, java는 unsigned 형이 없으므로 범위에 음수를 포함하여야 한다  
하지만 보다시피 현재 상태로는 음수 값을 표현할 수 없다  

그래서 가장 왼쪽에 있는 비트를 부호로 사용하며, 이를 MSB 라고 한다  
MSB가 0이면 양수, 1이면 음수인 것이다  
그러므로 1byte 자료형이 표현할 수 있는 범위는 1111 1111 ~ 0111 1111 까지가 되는 것이다  

음수값을 표현할때는 2의 보수(1의 보수를 구한후 + 1)를 사용한다  
```
ex1) 0111 1111(127) : 1000 0001(-127)  
ex2) 0000 1111(15) : 1111 0001(-15)
```

여기까지만 보면 1byte의 범위는 -127 ~ 127 까지가 되어야할 것 같은데, 왜 -128까지 일까?  
> 아래는 추측이다  
> 하지만 첫번째 비트를 MSB로 사용했기 때문에, 우리는 0을 2가지 방법으로 표현할 수 있는 특징을 가지게 된다(0000 0000, 1000 0000)  
> 여기서 1000 0000 값을 버리지 않고 1000 0001(-127) 에서 1 빠진 값으로 -128을 사용하는 것으로 보인다

---

# 리터럴
정수값은 기본이 int 리터럴이다.  
실수값은 기본이 double 리터럴이다.  
```java
int i = 10; // int형
double d = 10.10; // double형
```
long, float을 사용하고 싶으면 추가적인 문자를 사용해야 한다.  
```java
long l = 3000000000L; // 30억은 int 범위를 넘어가므로 long 리터럴을 사용하지 않으면 표현할 수 없다.
float f = 10.10F;
```
short, byte는 리터럴이 없다. 그냥 정수값을 넣으면 자동으로 변환된다.  
```java
byte b = 10; // byte형이 됨
short s = 10; // short형이 됨
```

---

# 형변환
## 명시적 형 변환
캐스팅 연산자를 써서 명시적으로 형을 변환하는 방법이다.  
```java
double d = (double)10; // int를 double로 형 변환
float f = (float)10.10; // double을 float으로 형 변환
```

## 크기에 따른 자동 형 변환
`byte < short < int < long < float < double`  
왼쪽으로 오른쪽 순서로 타입의 크기이다.  
큰 자료형에 작은 자료형을 저장할 경우 자동으로 형 변환이 일어난다.  
```java
long l = 10; // long형이 됨
float f = 10L; // float이 더 크므로 long을 저장 가능하다
```

## 산술연산에 의한 자동 형 변환
연산을 하는 숫자들 중 가장 큰 자료형으로 나머지 숫자의 자료형이 결정된다.  
```java
int i1 = 10L + 10; // long형으로 변환되므로 컴파일 에러
int i2 = 3 + 3.5; // double형으로 변환되므로 컴파일 에러

double d1 = 3 / 2; // 둘다 int 형이므로 소수점 이하가 잘린 1이 저장된다.
double d2 = (double)3 / 2; // 3을 double로 강제 형 변환 하였으므로 연산의 결과는 double이 된다.
```

byte형이나 short형은 연산 시 모두 int형으로 변환된다.  
```java
short s1 = 1; // 여기선 자동 변환된다
short s2 = 2; // 여기선 자동 변환된다
short s3 = s1 + s2; // int로 변환되었기 때문에 컴파일 에러
short s4 = (short)s1 + s2; // short로 변환해야 함
```

char형은 문자형이지만 연산할 수 있다.  
```java
char c = 'a';
int i = 100;
System.out.println(c + i); // 문자 a는 아스키코드값(97)로 변환되어 197이 반환된다.
```

참조 : <https://hit-it-sum.tistory.com/1>

<!-- more -->
