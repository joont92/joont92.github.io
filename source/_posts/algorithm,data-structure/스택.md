---
title: 스택
date: 2018-12-12 19:31:24
tags:
---

size라는 변수가 필요하게 됨  
size 변수에 스택을 넣고, size가 증가됨  

# push
```
stack[size++] = value;
```

# pop
```
stack[--size] = 0;
```

# 괄호
닫는 괄호가 있을 때 짝이 맞는 여는 괄호는?
닫는 괄호보다 왼쪽에 있어야함
아직 짝이 맞지 않아야 함  
1번과 2번에 해당하는 애들 중에서 가장 오른쪽에 있는 괄호  

처음 방법은 시간복잡도가 N^2가 나오게 됨  
괄호 전체를 도는 N과, 닫는 괄호를 만났을 때 왼쪽의 괄호들을 다 비교해봐야 하므로 또 N의 시간이 걸리므로 N^2  

## 스택으로 변경
1. 왼쪽 -> 어떤 순서로 탐색할거냐?  
1. 2번에 해당하는 여는 괄호를 차례대로 스택에 넣어주면 된다  
1. 3번이 스택의 탑을 의미하게 된다  

여는 괄호를 만나면 스택에 넣어주고, 닫는 괄호를 만나면 스택에 여는 괄호가 있는지 체크하고 빼준다  

- 확장할 수 있는 생각
여는 괄호밖에 없다는건, 스택에 뭐가 들어있는지가 중요한게 아니라, 몇개가 있는지가 중요하다(cnt를 이용)  

# 쇠막대기
스택에 여는 괄호의 인덱스를 넣어준다  
닫는 괄호와 top의 차이가 1이면 레이저를 의미한다.  
레이저를 빼고 스택에 남은 개수가 잘려나갈 막대기의 개수가 된다.  
이 개수만큼 최종 막대기 개수에 더해주면 된다  
(남은 막대기는 스택에서 빼지 않는다)  

닫는 괄호와 top의 차이가 1이 아니면 쇠막대기를 의미한다.  
쇠막대기의 경우에도 최종 막대기 개수에 1을 더해줘야 한다.  
(어떤 막대기를 2번 자르면 3조각이 되기 때문이다)  

이 문제는 값(인덱스)가 중요하기 때문에 진짜 스택을 사용해야 한다.  

# 에디터
각각의 명령에 대해서 어떤 한 명령을 수행하는데 걸리는 시간이 O(N)이다  
== O(1) + O(1) + O(N) + O(N)이라서?  

그래서 총 걸리는 시간은 O(N^2)이다(모든 문자열에 돌아야하므로?)  

커서를 기점으로 양쪽에 스택을 두는 식으로 구성할 수 있다!  
> 모든 명령을 O(1)로 구성할 수 있다  

스택으로 구성하면 모든 명령을 O(1)로 구성할 수 있기 떄문에, 결과적으로 문제를 O(N)으로 구성할 수 있다  

왼쪽스택을 오른쪽으로 모두 보내고, 오른쪽 스택을 위에서부터 읽으면 순차적으로 출력이 가능하다  

# 스택의 특징?
가장 가까운것을 O(1)만에 찾을 수 있다(pop만 하면 되니까?)  
가장 가까운 것을 컨트롤 함으로써 뭔가를 수행할 수 있다고 생각하면, 스택으로 풀 수 있다?  
커서를 기준으로 제일 가까운것만 의미가 있다는 점을 이용해서 스택으로 풀수 있었다?  


<!-- more -->