---
title: 애그리거트
date: 2019-05-20 21:03:44
tags:
    - DDD start!
---

# 애그리거트란?
도메인 모델이 복잡해졌을 때, 개별 객체 수준에서 모델을 바라보면 전반적인 구조나 큰 수준에서 도메인간의 관계를 이해하기 어려워진다  
주요 도메인 개념간의 관계를 파악하기 어렵다는 것은 코드를 변경하고 확장하는 것이 어려워진다는 것을 의미한다  
상위 수준에서 모델이 어떻게 엮여있는지 알아야 전체 모델을 망가뜨리지 않으면서 추가 요구사항을 모델에 반영할 수 있는데,  
세부적인 모델만 이해한 상태로는 코드를 수정하기가 두렵기 때문에 코드 변경을 최대한 회피하는 쪽으로 요구사항을 협의하게 된다  
즉, 이러한 문제점을 없애려면 상위 수준에서 모델을 조망할 수 있는 방법이 필요하고, 그것이 바로 **애그리거트** 이다  

![애그리거트 예시](/temp/애그리거트-예시.jpeg)  

- 애그리거트는 관련된 모델을 하나로 모은 것이기 때문에 한 애그리거트에 속한 객체는 유사하거나 동일한 라이프사이클을 갖는다  
- 애그리거트는 경계를 갖는다
    - 한 애그리거트에 속한 객체는 다른 애그리거트에 속하지 않는다
    - 각 애그리거트는 자기 자신만을 관리할 뿐 다른 애그리거트를 관리하지 않는다
    - 경계를 설정할 때 기본이 되는 것은 도메인 규칙과 요구사항이다  
        - 도메인 규칙에 따라 함께 생성되는 구성요소는 한 애그리거트에 속할 가능성이 높다
    - `A가 B를 갖는다`는 대부분 한 애그리거트이지만, 무조건 한 애그리거트인것은 아니다
        - 상품과 리뷰가 좋은 예시이다
- 대부분의 애그리거트는 한 개의 엔티티 객체만 갖는 경우가 많으며 두 개 이상의 엔티티로 구성되는 애그리거트는 드물게 존재한다

# 애그리거트 루트
애그리거트는 여러 객체로 구성되기 때문에 한 객체만 상태가 정상이어서는 안된다  
도메인 규칙을 지키려면 애그리거트에 속한 모든 객체가 정상 상태를 가져야한다  

애그리거트에 속한 모든 객체가 일관된 상태를 유지하려면 애그리거트 전체를 관리할 주체가 피요한데, 이 책임을 지는 것이 바로 **애그리거트의 루트 엔티티**이다  
애그리거트에 속한 모든 엔티티는 루트 엔티티에 직접 또는 간접적으로 속한다  

- 애그리거트 루트의 핵심 역할은 애그리거트의 일관성이 깨지지 않도록 하는 것이다
- 애그리거트 루트는 애그리거트가 제공해야 할 도메인 기능을 구현한다
    - 애그리거트 루트가 제공하는 메서드는 도메인 규칙에 따라 애그리거트에 속한 객체의 일관성이 깨지지 않도록 구현해야 한다
- 애그리거트 루트가 아닌 다른 객체가 애그리거트에 속한 객체를 직접 변경하면 안된다
    - 이러면 애그리거트 루트가 강제하는 규칙을 적용할 수 없어 모델의 일관성을 깨는 원인이 된다
    ```java
    ShippingInfo si = order.getShippingInfo();
    si.setAddress(newAddress);
    ```
    > 이는 도메인 규칙을 무시하고 DB 테이블에서 직접 데이터를 수정하는 것과 같다  
    > 그렇다고 이를 막는 로직을 서비스 레이어에서 구현하게 되면, 해당 로직이 여러 서비스 레이어에서 중복될 가능성이 높아진다  
- 습관적으로 작성하는 setter 메서드를 피해야한다
    - 도메인 로직을 도메인 객체가 아닌 응용이나 표현 영역으로 분산되게 만드는 원인이 된다
    - 이렇게 되면 **도메인 로직이 한곳에 응집되어 있지 않으므로** 코드를 유지보수할때도 시간이 훨씬 많이 들게된다
    - setter만 넣지 않아도 이런 상황을 대부분 방지할 수 있다
- 밸류 객체는 불변 타입으로 구현한다

## 애그리거트 루트의 기능 구현



<!-- more -->