# 1회차
(a)tdd  
spark.java를 통해 콘솔 -> web UI로 올려보는 과정  
> 최대한 도메인 변경없이 올려보는 경험을 하는것이 좋다  

온라인 코드 리뷰  
- 24시간내에 피드백을 주는 것을 목표로 함  

- 단순 반복하는 연습은 실력을 향상 시켜주지 않는다  
    - 이빨닦는 것을 생각해보라  
- 의식적인 연습을 해야한다  
    - 얼마나 의식적으로 연습했느냐에 따라 실력차이가 엄청나게 날 수 있다  
- 익숙한 곳(컴포트존)에서만 연습을 하면 실력이 늘지 않는다  

클린코드를 할 때 처음에는 정량적인 기준으로 하는것이 좋다  
- else 안쓰기 등등  

클래스명 + Test를 붙이는게 클래스 테스트의 기본적인 convention

junit class test를 할때 테스트 메서드들의 순서는 랜덤이다  
> 테스트끼리 서로 의존이 없어야함을 의미  

pr을 잘못보냈을 때는 edit 으로 변경할 수 있음  
merge된 상태에서는 불가능함  

pr을 보낼때는 fork 한 곳에서 똑같은 브랜치로 보내지 않는다  
해당 브랜치는 계속해서 변경될 수 있기 때문이다  

step1에 문자열 계산기 다시 구현해서 pr  

# 2회차
String carNameList = scanner.nextLine(); 
// 해당하는 데이터 타입이나 자료구조가 아닐수 있기 때문에 이름에 자료구조는 최대한 사용하지 않는것이 좋다  

클래스는 클래스 정보를 제공하는 애이기 떄문에, enum은 밑에 두는게 더 좋다고 함(개인적)  

- 메서드가 테스트하기 힘들다면 테스트하기 쉬운부분과 어려운 부분을 분리해야한다  

- 테스트에서 클래스를 상속하고, 테스트가 어려운 메서드를 오버라이드해서 테스트를 수행할수도 있다  

```java
List<Car> cars;
List<String> winner;

// 또는 

List<Car> cars;
int topDistance;
```

- cars를 통해서 아래 변수의 값들을 구해올 수 있기때문에 위의 두 인스턴스 정보는 중복이라고 볼수있다.  
게다가 위의 경우에는 두 데이터의 sync를 계속해서 맞춰줘야하는 불편함이 있다  

- get 메서드를 사용해서 밖에서 계속해서 로직을 수행하고 있다면, 없이 써볼수 있는 방법을 최대한 생각해보는 것이 좋다  
(set 메서드는 무조건 안쓸 수 있다)  
이러한 것들이 1차적인 목표가 되고, 그 다음이 객체를 역할에 맞게 분리하는 것이다  

테스트가 무조건 많다고 좋은 것은 아니다. 유지보수 할 양이 늘어나기 때문이다.  
경계값에 대해서만 테스트하는것이 좋다  

- 테스트 클래스의 인스턴스 변수는 모든 테스트에서 사용하는 값들에 대해서만 선언하는 것이 좋다  
그 외에는 메서드의 로컬 변수를 사용하는 것이 좋다  

테스트 픽스쳐를 만드는 방식이 너무 과도하면 이를 바꿔볼 수 있다  
```java
car1.move();
car2.move();
car2.move();
car3.move();
```
이런 코드는 우승자를 알아보기가 힘들다. 읽는것이 힘들어진다.  
그리고 중요한건 위처럼 작성하면 짜증나서 테스트를 작성 안 할 가능성이 생기게 됨  
이에 대한 방안으로 position을 받는 생성자를 추가할 수 있는데, 물론 생성자가 역할에 충실한지는 체크해볼 필요있다  

exception 테스트는 하나의 부분만 테스트해야 한다  
여러개의 exception을 묶어놓고 expected 해봐야 아래 코드들은 실행되지 않는다  

단위테스트 할 떄 집중해야 하는 부분은 Domain 모델 부분이다  
- 객체지향 설계는 도메인에 가장 많은 시간을 투자해야한다  

main method == controller?  

테스트를 위한 생성자를 만드는것을 다른 관점으로 본다?  
프로덕션 코드에서도 생길 수 있다고?  

단위테스트 만드는것조차 익숙하지 않으면 TDD는 더 어렵다  

- 원시값 포장 == Value Object(DDD에서 사용함)  
```java
class Position{
    private int position;

    public Position(int position){
        this.position = position;
    }

    public Position move(){
        return new Position(position + 1);
    }
}
```

- 일급 콜렉션  
컬렉션을 래핑한 객체  
컬렉션을 조작하는 것도 해당 객체에 선언된 메서드를 통해서 하게된다  

- TDD = TFD(Test First Development) + refactoring  
설게를 짧은 시간동안 자주 하자  
작은 부분을 구현하고 설계(TDD?)를 통해서 개선하고, 또 작은 부분을 구현하고 설계를 통해 개선한다.  
애자일에서 말하는 점진적 개발이라고 할 수 있다  
핵심은 설계를 자주하는 리팩토링이다  

모든 부분을 TDD 방식으로 하면 어렵다. 테스트하기 어려운 부분들이 있기 때문이다.  
- 처음에는 그 욕심을 버리고, 도메인 모델에 집중해서 TDD 하는것만 집중하는 것이 좋다  

설계한 부분에서 테스트 가능한 부분을 찾아내는 것이 중요하다  
도메인을 작성하고 테스트가 힘든 부분을 분리한다(?)  

테스트가 통과하면 리팩토링 단계를 거치는것이 좋다  

전체를 다 하려고 하지말고, 특정 부분만 분리해서 테스트를 해보는게 좋을 수 있다  

- 테스트를 하다가 테스트가 힘들어지면, 어떻게 하면 테스트하기 편할까 생각해보고, 그에 맞춰 코드를 개선해나가는 식으로 생각해볼 수 있다  

- TDD의 처음 스텝은 `어떤 인풋이 들어갔을 때 어떤 아웃풋이 나온다` 이다.  
처음에는 이를 기반으로 테스트를 만들어보는 것이 좋다  

테스트를 기반으로 구조를 계속 리팩토링 하는 작업 또한 설계작업이다  
테스트 코드를 믿고 다양한 시도를 해봐야 설계 연습을 할 수 있다  
다른데서 테스트가 된 애들은 테스트하지 않아도 된다?  

- 클래스를 설계하면서 테스트가 힘든 부분을 클래스로 분리하면서 테스트를 추가하는 식으로 하는것이 좋다  

- ? Car에 position을 추가해도 되는것은, DTO의 역할까지 가지고 있기 때문이다  
이건 테스트를 수행하다가 발견한 특징인데, 만약 이렇지 않다면?  

- 뷰에 도메인 엔티티를 직접 전달하지 않는 이유는 뷰에서 해당 도메인을 조작해버릴 수 있기 떄문이다  
여기에 DTO를 사용할수도 있고, 도메인 객체의 접근 제어자를 사용할수도 있다(적극 활용하라?)  

static 메서드를 적극 활용하다 보면 테스트가 더 쉬워질수도 있다  
테스트 가능한 부분을 계속 쪼개는 연습을 해야한다  
이걸 TDD로 연습해야한다?  

리팩토링을 극단적으로 연습해보는것이 좋다고 한다. 뭐든 극단적으로 학습해보는 것이 좋다.  
메서드를 작은 단위로 쪼개는 연습을 많이 해보면 코드를 읽기 쉬워지고(추상화 된 메서드명만 보고 판단 가능)  
함수형 프로그래밍의 힌트도 얻을 수 있다?  

- 작은 메서드 분리하기 -> 작은 클래스 추출하기 를 자주하다보면 객체지향 설계에서 힌트를 많이 얻을 수 있다. 연습도 많이 된다.  
메서드를 계속 쪼개다보면, 클래스로 쪼개야 할 애들이 나타나게 되고.. 이런식의 연습을 계속하다 보면 많은것을 깨우칠 수 있다고 한다  

기능변경에 많은 테스트가 변경되면, 객체끼리 너무 의존하고 있는것은 아닌지, 너무 많은 범위를 허용하고 있는건 아닌지 의심해보자  

# 3회차

프로그래밍 : 기계가 실행할 정도로 요구사항을 명시하는 작업  

////



alt + command + c ?  







Money!
money한테 물어봐서 로또를 몇장 살 수 있는가 물어본다?  
돈을 int로 받을수도 있고, string으로 받을수도 있다  
이것을 굳이, 너무 객체의 pure함을 유지하기 위해 분리할 필요는 없다(과하다?)  
> 나는 항상 뭔가 다 분리해서 최대한 pure함을 유지해보려고 했다  
> 하지만 이렇게 하면 너무 어렵고, 힘들고, 복잡해진다  



테스트 라스트  
하나의 객체에 대해 요구사항을 만족하는 테스트들을 먼저 만들고,  

-   

TDD를 할때는 input, output을 생각하면서 만들어야 하는데,  
input을 명확하게 잡아내는 것을 대부분 처음 어려워한다  


메서드 인자를 3개를 넘기지 마라  

당첨번호와 보너스 번호는 항상 같이 다닌다  
그러므로 이를 하나로 묶어서 객체로 만들면 해당 객체는 라이프사이클을 같이하게 된다  

리팩토링을 시간날때마다 계속 해야하고, 그러면 기존 다른 코드에 영향을 미치지 않고 리팩토링하는 과정이 필요하다.  
그러므로 이럴떄는 과도기적인, 중간단계가 필요하다.(메서드 중복해서 사용 등)  
> ex)  
> 우리가 리팩토링 하는 메서드를 사용하는 곳은 10군데이다  
> 이를 리팩토링하는 과정 자체도 매우 큰데, 이 과정중에 버그픽스나 다른 기능을 개발해야 한다면 어떻게 해야할까?  
> 선택지가 2개이다. stash 같은곳에 넣거나, 전부 롤백하거나.  
> 그러지말고 메서드를 중복해서 하나 더 만들고, 점진적으로 해당 메서드를 사용하게 한다  
> 그리고 모두 그 메서드를 사용하게 된다면, 기존의 레거시 메서드를 삭제한다  
> 즉, 점진적으로 리팩토링을 하는 것이다  
> 우리는 이런 연습을 계속 해야한다  


메세지를 계속 보내는 식으로 작성하다보면 해당 메서드들이 재사용되는 경험을 하게 된다  

생성자를 통해 객체를 만들고 setter 같은 것으로 초기화할수 없게 만드는 것이 좋다  
생성자는 알아보기 힘드니 builder가 더 좋다 사실  

리팩토링을 하면서 디미터의 법칙을 지키려고 내부 로직이 굉장히 많이 바뀌었으나, 테스트가 작성되지 않았다. 괜찮은가?  

Lotto와 WinnigNumber 둘 다 Integer list 혹은 LottoNumber list를 가졌다면 길이가 6이라는 조건을 양쪽에서 검사해야 한다  
그러므로 6개의 정수를 Lotto라는 객체로 감싼다. 신뢰할 수 있는 객체가 된다.  
신뢰할 수 있는 객체들을 계속 wrapping 해서 객체를 만들어가는 것이 좋다  

winningLotto가 bonus number를 포함하면 안된다도 검증해야함  




을 통해 VO의 성능을 올릴 수 있다  

객체를 계속 생성하는 것이, 메서드를 분리하는것, 메서드가 재사용되는 것이 성능 로스를 일으킬 것이라고 걱정할 필요없다  
아주 미비하기 떄문이다  

매번 새로운걸 만드는 것보단, 같은 것을 다른 관점으로, 방식으로 구현하다보면 많은 인사이트들을 얻을 수 있다.  

어떻게 하면 테스트할수 있을까? 어떻게 하면 TDD로 할 수 있을까?  
를 계속 생각하다보면 기존의 내 선입견이 깨지면서 더 나은, 다른 설계가 나오게 된다  
테스트를 하기위해 계속 메서드를 쪼개거나.. 하기 떄문이다  
TDD없이 그냥 설계하면 안나오던것이 TDD를 하다보면 나오게 된다!!  

# 4회차

적절히 객체로 잘 분리해서 사용하면 유효성 체크도 분리할 수 있게 된다  

자료구조를 잘 만들면 사다리타기 구현이 상당히 쉬워진다?  
사다리 타기를 위한 자료구조를 만들어라  
우리들만을 위한 자료구조 == 클래스  

나만의 좋은 자료구조(클래스)를 잘 만들기 위한 좋은 방법이 TDD이다.  
좋은 클래스 설계는 머릿속으로 설계해서는 잘 안떠오르기 때문에, TDD를 통해 구현하는 것이 좋다  



mutable 클래스를 사용하면 인스턴스가 재사용되므로 성능상으로 좋다  
immutable 클래스를 만들면 인스턴스가 많이 생성되서 성능 걱정을 할 수 있지만, 실제로는 그렇게 성능에 영향을 미치지 않는다(특히 요즘같은 시대에는 더더욱)  
immutable 객체를 만들어서 값이 어디서든 변경되지 않게 보장하는, 안전한 프로그래밍을 하는것이 훨씬 낫다  

여러 클래스들을 wrapping하는 객체의 경우 immutable이 될수도 있고, 안될수도 있다.  
immutable로 사용하기 위해 객체를 final로 선언하는 연습을 많이 해야한다  

DI는 외부에서 주입하는 방식  
사다리 게임을 할때도 DI를 경험할 수 있다  

AutoLottoGenerator를 조합으로 사용한 DefaultLottoGenerator(자동 + 수동)를 만들 수 있다  

웹 개발을 할떄에는 수정사항이 있을때 수동테스트를 해야하는 단점이 있다  

스프링의 AcceptanceTest 클래스를 사용하면 로컬에서 사용하지 않는 포트로 서버를 띄우면서 테스트를 수행한다  

302 + location 헤더를 받으면 location 헤더쪽으로 리다이렉션 한다  

template는 로그아웃상태, basicAuthTemplate는 로그인상태  
@LoginUser annotation을 사용하면 SpringSecurity의 HandlerMethodArgumentResolver 를 통해 검증한다  

Accaptance Test는 E2E 테스트라고 부르기도 한다  
Unit Test < Integration Test < Acceptance Test(기능을 위주로)  
Repository는 테스트하지 않아도 된다  

# 5회차  
책 : 몰입의 즐거움  

서비스 레이어는 상태를 가지지 않는 부분이라 로직을 가지면 안된다. 전부 도메인 모델로 옮겨야한다.  
서비스 레이어에서 로직을 구현한다는 것은 계속해서 getter를 써서 가져와서 무언가를 수행하게 되고, 이러면 중복이 계속 생기게 되어있다  
객체지향적으로 프로그램이 한다는 것은 비즈니스 로직의 중복을 제거하는 것이다  

서비스 레이어에서 
데이터를 계속 get 하면서 절차적인 코딩을 하게 되고, 서비스 레이어가 뚱뚱해진다 == 테스트하기 힘들어진다  
서비스에 비즈니스 로직을 구현하다보면 디펜던시가 많이 생겨서 테스트하기 힘들어지고(서비스는 기본적으로 다른 레이어에 의존이 커서 테스트하기 힘들다), 그러면 테스트를 안하게 된다(데이터베이스가 필요하고 등등등)  
서비스 로직을 테스트하는 것은 도메인 로직을 테스트하는 것보다 최소 5배는 더 어렵다  
로직이 도메인 안으로 이동하는 순간 기존의 콘솔 프로그램 만들때 처럼 단위테스트들을 수행할 수 있다  

mockito를 사용하면서 만족감을 느끼는 이유는 서비스에 로직이 많기 때문이다  
mockito 없이도 테스트 가능한 상태를 만들어야 한다  
> 가장 좋은 방법은 로직을 도메인 모델에서 구현해야한다  
> 서비스에서 get을 하는 순간 의심해봐야 한다(이건 아닌거 같은데? 라고)  

서비스에서 로직을 구현하지 않고 도메인에서 로직을 구현하고자해야 한다!!  
리파지토리와 서비스와의 커플링을 아예 끊어버리고 도메인에 로직을 구현함으로써 

서비스는  
- 레지파토리에서 데이터베이스 조회하기  
- 도메인 객체에 메시지 보내기  
- 도메인에서 받은 메시지를 다른 도메인이나 서비스에 전달하고  
- 트랜잭션 바인딩 하는 정도의 역할  






엔티티가 추가될 떄 마다 컨트롤러, 서비스가 각각 다 생성될 필요는 없다  
Question, Answer는 밀접한 관계인데, 그냥 같은 서비스로 하면 안되는지?  
QnAService, QaAController로 만들면 된다  
어쩌피 중요한 로직들은 전부 도메인에서 테스트 될 것이기 때문이다  
> 위에서 언급한 서비스의 역할에 다시 집중! 엔티티에 맞춰 서비스, 컨트롤러가 만들어질 필요는 없고, 불필요하다!  

정형화된 방식의 프로그래밍 방식은 없다(엔티티 종속적인 레이어드 아키텍쳐 등..)  
객체들이 많아지다보면 서로 의존하는 부분도 많이 생기게 되고, 이러면 복잡도가 증가한다  
그러므로 얘네들을 묶는 바운더리가 필요하다  
qna package에 qnaService, repository, 도메인 등을 묶어놓을 수 있다  
이렇게 패키지로 나눴을떄는 패키지와 패키지간에 bidirection이 안생기게 하도록 주의해야한다  
> answer package에서 user package의 영역을 사용헀다면 user package에서 answer package 영역을 사용하지 않도록 해야한다  
> DDD의 aggregate  

이러한 모든 것들을 의식하면서 연습하는 것이 좋다(whenever)  

--- 

update시에 Question 객체를 전부 전달하는 것도 별로고, update 메서드에서 그것을 받아 getter로 꺼내 로직을 수행하는 것도 별로다  
이럴 경우 QeustionBody 라는 객체를 생성해보는 것이 좋다  
> 이렇게 하면 테스트할때 상태값을 다 가져와서 assert 하는 불편함도 줄일 수 있다  
    ```java
    // not good
    assertThat(updatedQuestion.getTitle()).isEqualTo(question.getTitle());
    assertThat(updatedQuestion.getContents()).isEqualTo(question.getContents());
    ```

엔티티도 다 나눠야 한다  
> title과 contents를 묶어서 QuestionBody를 만들고 관련 역할을 전부 옮기고 위임  
> List<Answer>를 일급 컬렉션으로 만들어서 관련 역할을 전부 옮기고 위임  
> 이러면 Question이 가벼워진다  
> 객체지향 프로그램을 하면 할수록 위임 코드가 많아지는 것이 당연하다  

엔티티는 database mapper가 아니다  
엔티티도 기존의 로또나 사다리 만들듯이 모델링 해야한다  
ORM을 쓰는 최대 장점은 이런 것이다  
스프링이건, ORM이건 객체지향의 극장점을 끌어올리기 위해 나온 기술이다!  

도메인 객체를 뚱뚱하게 하지 말고 객체를 계속 분리해서 위임하는 식으로 리팩토링을 계속 해야한다  
> 핵심적이고 끊임없이 리팩토링이 필요한 곳은 컨트롤러, 서비스 등등이 아니라 **도메인 객체**이다  
> 알다시피 도메인 로직은 단위테스트를 작성하기 수월하고, 단위 테스트가 많다면 전투적으로 리팩토링 할 수 있다  

이러한 설계는 성능에 영향을 거의 미치지 않는다  
만약 성능을 개선해야 한다면 다른쪽을 튜닝해야 한다(캐싱 등등)  

테스트 픽스쳐  
픽스쳐를 만들기 편하게 해주는 메서드들을 만들기  
이러한 메서드들을 static으로 선언해서 다른 테스트들에서 재사용해도 된다  
> UserTest 에서 fixture를 만들어주는 newUser 같은 메서드를 만들고 QuestionTest에서 같이 사용해도 된다  

AcceptanceTest는 Repository를 사용하지 않는 것이 좋다  
template 을 통해 데이터를 전송하고 전달받은 api 만으로 검증해야 한다  

JPA에서 update가 없는 것이 좀 더 객체지향적인 프로그래밍을 하는데 맞는 것이다  
실제로 생각해보면, 객체의 값을 update 했으면 그대로 변경된 것이기 때문이다  

---

유닛테스트보다 AcceptanceTest가 적게 작성하는 것이 맞다  
Acceptance Test는 테스트 케이스만큼 작성하는 것이 낭비다. 이는 Unit 테스트로 하면 된다  
클라이언트 입장에서 받을 response만 생각해보면 모든 경우에 수에 대해 Acceptance Test가 필요하지는 않다  
> 케이스가 4가지면 AcceptanceTest는 2가지, 유닛테스트가 4개인 경우가 대부분 맞다  

QnA 피드백에 위의 과정을 설명해놓은 글이 있다  
(Acceptance Test를 바라보는 관점을 바꿔야한다)  

DTO는 외부에 드러나는 객체이고, 이는 변화할 가능성이 매우 높으므로 DTO로 분리하는 것이 좋다  
DTO에 대한 거부감이 드는 이유는 도메인을 객체지향적으로 설계하지 않았기 때문이다  

코틀린을 사용하기 위한 점진적 변경 방식  
> DTO로 변환하는 부분만 코틀린으로 작성해보거나..  

OSIV를 사용하면 영속성 컨텍스트를 유지하는 영역이 트랜잭션 이상으로(request까지) 넓어지고,  
이는 커넥션을 맺는 시간이 길어짐을 의미한다(request 까지 커넥션을 유지하게 됨. 데이터베이스에서 데이터를 가져와야 하기 때문이다)  
이는 성능상 이슈를 발생시킬 수 있으므로(커넥션 풀 개수 부족), OSIV를 끄고 service에서 DTO로 변환해서 내려주는 방식을 택해야한다  

DI로 구현했을떄 테스트 작성 시 어려운 부분이 나올 수 있다  
Line에 BooleanGenerator를 전달하는 것보단 Boolean들을 전달하는 것이 테스트하기 편하다  

객체를 작성할 때 객체가 필요로 하는 범위를 정하는 것이 중요하다  

우리만의 자료구조(잘 믂어서 설계된 객체)를 잘 도출해서 사용하면 프로그램이 탄탄해지고 단순해진다  

점 2개를 묶은 Point 객체(left, current)  
left가 true이면 왼쪽으로 이동, current가 true이면 오른쪽으로 이동  

first = Boolean.FALSE, 전달받은 boolean
last = 전달받은 boolean, Boolean.FALSE
next = current, 전달받은 boolean  

# 6회차
일단 나부터 변화해야 한다  
내가 할수있는 부분은 TDD와 리팩토링을 시도해본다  
한번에 너무 많은 것이 아니라 작은것 하나만 시작해서, 익숙해질때까지 집중해본다  
회고 -> practice 선택 -> 한가지에 집중 -> 작은 성공 -> 반복  

작은 성공을 경험하기 위해선 시간이 많이 걸린다  
조급함을 버려야 한다  

변화를 만들다가 실패해도 괜찮다. 가장 크게 성장한 것은 내 자신이기 때문이다  
변화를 시도하는것 만으로도 자신감과 용기를 가질 수 있고, 이는 근육처럼 성장해나간다  

테스트 가능한 부분과 테스트하기 어려운 부분을 분리하는 역량을 길러야한다  
레거시 코드에 테스트 추가해서 리팩토링 하는것은 난이도가 거의 최상급이다  

1000개의 테스트중 10개 실패하는 테스트 vs 200개의 테스트가 100프로 성공하는 테스트  
여기서는 후자가 더 낫다. 실패하는 테스트는 계속해서 쌓이기 때문이다  

컴포트존을 꺠려는 노력, 의식적인 연습을 계속해야 한다  
성장을 위해서는 고통이 당연히 수반되어야 한다  