---
title: 쓰레드 기본
date: 2019-07-21 21:40:57
tags:
---

기본적으로 서버 프로그램의 경우 많은 동시에 많은 사용자의 요청을 처리해야 하므로 멀티 쓰레드로 동작한다  
우리가 매번 사용하는 톰캣 또한 사용자의 요청을 모두 쓰레드가 처리하는, 멀티 쓰레드 구조이다  
그래므로 쓰레드에 대한 지식은 필수이다  
라고 말했지만 나는 겉핥기밖에 모르는 것 같아서 다시 기초부터 공부하고 있고, 이를 정리하고자 한다  

쓰레드에 대한 기본 지식은 구글에 검색하면 아주 아주 잘 설명된 글들이 많으니 그것을 참조하면 되고, 여기서는 자바에서 쓰레드를 사용하는 법에 대해 정리하겠다  

# 쓰레드 구현
자바에서 쓰레드를 구현하는 방법은 `Thread` 클래스를 상속받는 방법과 `Runnable` 인터페이스를 구현하는 방법이 있다  
자바에서는 상속이 비싼 행위이기 때문에 보통은 `Runnable` 인터페이스를 구현하여 쓰레드를 구현한다  

```java
class MyThread1 extends Thread {
  @Override
  public void run() {
    /* 쓰레드에서 실행할 내용 */
  }
}

class MyThread2 implements Runnable {
  @Override
  public void run() {
    /* 쓰레드에서 실행할 내용 */
  }
}

class Main {
  public static void main(String[] args) {
    MyThread1 myThread1 = new MyThread1(); // Thread 상속 시 
    Thread myThread2 = new Thread(new MyThread2()); // Runnable 구현시 

    // 쓰레드 실행
    myThread1.start();
    myThread2.start();
  }
}
```

Thread 클래스를 상속받은 경우 바로 인스턴스를 생성하면 되고, Runnable 인터페이스를 구현한 경우 Thread 클래스의 인자로 넘겨주면 된다  
그리고 `start()` 메서드를 호출해서 쓰레드를 실행시키고 있음을 볼 수 있다  
> 참고로 한번 사용한(`start()`가 이미 호출된) 쓰레드는 재사용 할 수 없다  
> 두 번 이상 호출 시 `IllegalThreadStateException`이 발생한다  

앞서 우리가 구현했던 run 메서드는 단순히 수행할 태스크만을 작성하는 부분이고, 실제로 쓰레드를 실행시키려면 위와 같이 start 메서드를 통해서 실행해야 한다  
start 메서드 호출 시 쓰레드가 작업을 실행하는데 필요한 호출 스택을 생성하고 run 메서드를 실행하게 된다  

!(thread call stack)[https://joont92.github.io/temp/thread-call-stack.jpg]  

위는 메인 메서드에서 2개의 쓰레드를 실행시켰을 때의 모습이다  
보다시피 각 쓰레드들은 모두 별개의 작업이고, 스케줄링의 대상이 된다  
스케줄러가 정한 실행순서에 따라 각 쓰레드들을 돌면서 연산을 수행하게 될 것이고, 수행이 끝난 쓰레드들은 호출스택이 비워지면서 먼저 종료가 될 것이다  
> CPU는 기본적으로 쓰레드를 기반으로 스케줄링을 한다  
>> 확인 필요(+ JVM 쓰레드 스케줄러)
즉, 메인 메서드가 수행을 마쳤다 하더라도 쓰레드가 남아있다면 프로그램은 종료되지 않음을 뜻한다  
> 실행중인 사용자 쓰레드가 하나도 없을 경우 프로그램은 종료된다  

그리고 언급했다시피 **각각의 쓰레드들은 각각 별개의 작업흐름이기 때문에 한 쓰레드에서 예외가 발생해도 다른 쓰레드의 실행에는 영향을 미치지 않게 된다**  

# 싱글 쓰레드와 멀티 쓰레드
방금 아주 간단하게 멀티 쓰레드를 구성해봤는데,  
사실 단순히 CPU만 사용해서 계산하는 작업을 수행할 경우 위와 같이 멀티쓰레드로 작업을 수행하는것이 더 비효율적이다  
쓰레드간 context switching 비용이 발생하기 때문이다  

하지만 쓰레드 내에서 연산 이외의 작업을 수행할 경우(CPU 이외의 자원을 사용할 경우), 멀티 쓰레드 프로세스가 훨씬 효율적이다  
예를 들면 파일이나 네트워크 I/O 작업등이 있게 되는데, 특정 쓰레드가 이러한 작업을 수행하고 있을 경우 CPU는 이를 기다리지 않고 다른 쓰레드의 작업을 수행하면 되기 때문이다  
만약 싱글 쓰레드였다면 I/O 작업이 끝날 때 까지 CPU가 대기해야 했을 것이다  

# 쓰레드 우선순위
쓰레드는 우선순위(priority)라는 속성(멤버변수)을 가지고 있고, 이 우선순위에 따라 스케줄러가 할당하는 시간이 달라진다  
쓰레드의 우선순위가 같다면 CPU는 각 쓰레드에게 거의 같은 양의 시간을 할당하지만, 우선순위가 다르다면 CPU는 우선순위가 높은 쓰레드에게 더 많은 작업시간을 할당한다  
즉 쓰레드가 수행하는 작업의 중요도에 따라 쓰레드의 우선순위를 다르게 지정하여 특정 쓰레드가 더 많은 작업시간을 갖도록 처리할 수 있다  
(예를 들면 채팅을 처리하는 쓰레드는 쓰레드는 파일을 전송하는 쓰레드보다 우선순위가 높아야한다)  

쓰레드가 가질 수 있는 우선순위의 범위는 1~10까지 이며, 숫자가 높을수록 우선순위가 높다  
참고로 이 우선순위 값은 절대적인 것이 아니라 상대적인 값이고, 값이 1정도 차이나는 경우에는 별 차이가 없지만, 2 이상 차이가 나면 실행시간에 많은 차이가 발생하게 된다  

쓰레드의 우선순위는 따로 지정해주지 않으면 쓰레드를 생성한 쓰레드로부터 상속을 받게 된다(main 쓰레드는 우선순위가 5이다)  

# 데몬 쓰레드
쓰레드는 사용자 쓰레드와 데몬 쓰레드 2종류가 있다  
지금까지 언급했던 것은 전부 사용자 쓰레드이고, 데몬 쓰레드의 경우 일반 쓰레드의 작업을 돕는 보조적인 역할을 수행하는 쓰레드를 말한다  
보조 역할을 하는 쓰레드이므로 일반 쓰레드가 모두 종료되면 데몬 쓰레드 또한 강제적으로 종료된다(더이상 필요없기 때문에)  
데몬 쓰레드의 예로는 가비지 컬렉터, 자동저장, 화면 자동갱신 등이 있다  

쓰레드를 데몬 쓰레드로 생성시키고 싶다면 아래와 같이 `setDaemon()` 메서드만 실행시켜주면 된다  
```java
Thread thread = new Thread(new RunnableImpl());
thread.setDaemon(true); // start 전에 해줘야함

thread.start();
```
> 이 외에도 데몬 쓰레드가 생성한 쓰레드도 자동으로 데몬 쓰레드가 된다

데몬 쓰레드는 기본적으로 무한루프와 조건문을 이용해서 작성된다  
(예시에서 봤듯이 가비지 컬렉터, 자동저장 등은 계속해서 상태를 체크해야하는 작업이다)  
```java
class AutoSaveDaemonThread implements Runnable {
  @Override
  public void run() {
    while(true) {
      try {
        Thread.sleep(3 * 1000);
      } catch(InterruptedException e) {
        // do nothing
      }

      if(autoSave) {
        autoSave();
      }
    }
  }
}
```

JVM은 기본적으로 가비지 컬렉션, 이벤트처리, 그래픽처리와 같이 프로그램이 실행되는데 필요한 보조작업을 수행하는 데몬 쓰레드들을 자동적으로 실행시킨다  

# 쓰레드 실행제어(Welcome To Hell!)
