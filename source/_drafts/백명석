돌아가는 코드는 아무나 짤 수 있다.
사람이 이해할 수 있는 코드는 잘 교육되고 훈련된 소프트웨어 엔지니어만 만들 수 있다.
- 마틴 파울러

앞 부분에서 시간이 많이 드는 것 같지만, 뒷부분의 시간을 줄여준다
내가 만들고자 하는걸 대략적으로도 그려놓고 하는 사람은 처음에 시간이 걸릴지 몰라도 더 잘할 수 있다

리팩토링과 리스트럭쳐링은 다르다

테스트가 없으면 공격적으로 고칠 수 없다

4. 코드의 구조

--------------------

SW는 한번 작성되면 최소 10번 이상 읽히므로, 읽기 편하도록 작성해야 한다.
우리의 주 업무는 매번 새로운 코드를 작성하기보단 읽는 일을 많이 한다

- 절차지향
데이터와 데이터를 조작하는 코드들로 구성되어 있다
모든 프로시저가 데이터를 공유한다

- 객체지향
데이터와 코드가 encapsulated 되어있고, 데이터와 그 데이터를 조작하는 코드의 변경은 외부에 영향을 안미친다
내부의 변화가 외부에 영향을 주면 안된다
응집도가 높고, 결합도가 낮은 프로그램을 만드려면 객체지향밖에 없다
객체지향은 어렵고, 절차지향은 쉽기 때문이다.
객체지향적으로 생각하는것은 현실적으로 매우 어렵다는 말이 나오고 있다..
내 코드를 나 아닌 다른 사람이 유지보수 할껀데, 그 사람은 총이 있고, 미친 사람이다. 라고 생각해라고 ㅋㅋ

구성원 모두가 OOP를 인지한다면 OOP가 당연히 좋다. 아니면 애석하게도...
이벤트성으로 사용되는건 절차지향적으로 해도 된다
계속해서 사용되어야할 코드는 OOP적으로 하는게 좋다

회사에서 만드는 코드는 단순한 것이 없다. 변경되지 않는것은 없다.
그러므로 OOP를 무조건 해야한다.

3. 
WriteArticleService는 되지만 ArticleService는 잘못된 네이밍이다.
객체를 볼 떄 데이터로 보기 때문이다. 기능으로 봐야한다.
클래스 이름은 `무엇, 역할`이 보여야하지 `어떻게`가 보이면 안된다.
> RequestParser는 되지만 JsonRequestParser는 안된다

역할 = 
사용하는 기능으로 그룹핑되는(글쓰기, 비로그인 등)
그 역할을 만족시키기 위해서 시스템에서 제공되는 연관있는 기능들?
역할이 더 큰개념. 역할 하나에 책임이 여러개 있을 수 있다.
객체는 역할을 가진다?

클래스를 기능, 역할로 나눈다
1) 객체를 선별한다. 어떠어떠한 상태를 가지는.. (클래스 다이어그램)
2) 객체간 메세지를 주고받는지 그려본다. (커뮤니케이션 다이어그램)
3) 위 두개를 반복한다

하나에 다 가져다 놓으면 유닛테스트하기 매우 힘들다
분리하는것이 좋고, 분리된 것을 인터페이스로 연결하면 더욱 쉬워진다
비즈니스 로직을 가지는 곳과, 도메인 로직을 가지는 곳을 나눠야한다(라이브러리 처럼)

----

private로 하고 getter setter 줄꺼면 public이랑 다를게 없다
private으로 하고 기능만 제공해야 한다

객체의 속성을 가지고 외부에서 판단하는 것이 아니라, 객체에게 직접 물어봐야한다

command는 내부 상태를 변경하고 반환하는것이 없음
query는 내부상태를 변경하지 않고 상태를 반환함

인터페이스를 써야하는 이유?
- 인터페이스의 구현체가 1개 뿐인일은 절대 없다
- 테스트가 쉽다
- 부가적인 기능을 넣기가 쉽다(데코레이터)
- 

상속을 통한 재사용은 재사용이 아니다
재사용은 인터페이스 재사용을 말하는 것이다
인터페이스를 사용하는 코드가 재사용된다
인터페이스를 사용하는 로직은 굉장히 고수준의 로직이고, 구현체는 저수준의 로직이다.
저수준의 로직이 변경되어도 ..

FtpLogCollector가 DBLogCollector로 변경되어도 인터페이스를 사용하는 부분은 변경될것이 없다
즉, 사용하는것이 변경되어도 인터페이스가 재사용된다. 라는 것이다!

상속은 재사용이 아니라 의존성이 높아지는것이다. 상속은 가장 강한 의존성이다. 

상세에 빠지다 보면 원래 로직을 까먹게 된다

재사용되어야 하는 인터페이스는 팩토리로 받으면 된다
팩토리는 더러워도 되지만 비즈니스 로직은 더러우면 안된다. 재사용되어야 하므로.
스프링을 사용하면 constructor 등을 선언하고, IOC 컨테이너가 외부에서 의존관계에 해당하는 애들을 주입해준다
그리고 이렇게 구성해놓으면 테스트가 편해진다. 외부에서 테스트 의존을 넣어줘도 되고..

DI가 없이 팩토리 클래스로 의존객체를 가져왔다면 테스트가 매우 힘들어진다. 내부의 팩토리 메서드를 제공하기가 매우 힘들기 때문이다.
스프링의 IOC 컨테이너가 DI로 이를 주입해줌으로써, 위의 불편함을 공짜로 해소가능하게 된다.

스프링의 가장 좋은점은 트랜잭션, AOP가 아니라 DI이다.
스프링이 제공하는 기능을 따라 개발하다보면 DI를 따르게 되어있다
그렇게 하면 하나의 큰 클래스에 모든 로직을 떄려넣지 않게되고, 기능단위로 나누고, 추상화하고(인터페이스로)
이를 JUnit으로 쉽게 테스트하고.. 뭐 그렇게 되는 것이다.
우리가 원하는 객체지향 설계를 아주 쉽게 하게 해준다. DI가 그들의 의존성을 투명하게 관리해주기 때문에.

남한테 보여주기 챙피한걸 보여주면 극복할 수 있고, 남겨두면 그대로 챙피한 것이 된다