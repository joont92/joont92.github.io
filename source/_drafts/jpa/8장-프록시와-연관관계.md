---
title: 8장-프록시와 연관관계
date: 2018-09-06 18:49:53
tags:
---

JPA에서는 프록시 객체를 사용하여 사용하는 시점에 테이블에서 데이터를 조회하는 지연 로딩(Lazy)을 지원한다.

즉시 로딩 : 엔티티 조회시 연관엔티티도 함께 조회
@ManyToOne(fetch = FetchType.EAGER)

지연 로딩 : 실제 연관 엔티티를 사용할 때 조회
@ManyToOne(fetch = FetchType.LAZY)
> member.getTeam().getName(); // getter 시점에 조회

※ issue : lazy 로딩한 객체를 사용하지 않으면 콘솔창에 찍히지 않는다.
member.getTeam(); // log not print
syso(member.getTeam()); // log print
> 이건 진짜 호출시점도 아니라 사용시점에 lazy 로딩을 하는거네 ㄷㄷ

- Default Fetch Value
OneToOne: EAGER
ManyToOne: EAGER
OneToMany: LAZY
ManyToMany: LAZY

JPA는 Entity간 관계설정에 따라 왠만하면 JOIN을 사용해서 처리하려고 한다.
정해진 프로세스(무조건 JOIN, 여러번 조회) 가 있는것은 아니다.

연관관계끼리 JOIN 할때 OUTER JOIN을 사용하는데, 이는 외래키에 NULL 값이 허용되기 때문이다.
@JoinColumn(nullable=false) 와 같이 지정하면 OUTER 대신 INNER JOIN을 사용한다.(nullable=true 가 기본값이다)
> nullable false는 잘 안먹히는것 같음
관계부분에 optional=false를 주면 inner join을 행함. optional=false : optional해선 안됨. 필수값이라는 뜻
ex) @ManyToOne(optional=false);

- lazy 로딩
FetchType.LAZY인 테이블은 조회하지 않고 프록시 객체를 넣어두고
getXXX() 호출 시 테이블에서 데이터를 조회한다. (1개의 select 쿼리)

EAGER로 했다고 무조건 join 하는것은 아님.
테스트 결과 list에서는 따로 쿼리를 날렸고, 단일 쿼리에서 join헀음

- CASCADE (영속성 전이)
@OneToMany 과 같은 관계에 선언한다.
e.g. @OneToMany(cascade = CascadeType.ALL)

- type 종류
CascadeType.PERSIST – 엔티티를 생성하고, 연관 엔티티를 추가하였을 때 persist() 를 수행하면 연관 엔티티도 함께 persist()가 수행된다.  만약 연관 엔티티가 DB에 등록된 키값을 가지고 있다면 detached entity passed to persist Exception이 발생한다.
CascadeType.MERGE – 트랜잭션이 종료되고 detach 상태에서 연관 엔티티를 추가하거나 변경된 이후에 부모 엔티티가 merge()를 수행하게 되면 변경사항이 적용된다.(연관 엔티티의 추가 및 수정 모두 반영됨)
CascadeType.REMOVE – 삭제 시 연관된 엔티티도 같이 삭제됨
CascadeType.DETACH – 부모 엔티티가 detach()를 수행하게 되면, 연관된 엔티티도 detach() 상태가 되어 변경사항이 반영되지 않는다.
CascadeType.ALL – 모든 Cascade 적용

PersistentObjectException: detached entity passed to persist
> JPA 사용시 자동으로 생성되는 값을 가진 필드에 직접 값을 할당해 저장하고자 할 때 발생되는 에러

※ ManyToMany의 경우 영속성전이를 선언하지 않아도
관계 대상 테이블의 변화에 따라 교차테이블은 항상 등록, 수정, 삭제 된다.

CascadeType.PERSIST가 선언되었을때 새로 등록된 자식 엔티티는 자식 테이블에 인서트하고,
기등록된 자식 엔티티가 있을 경우 교차테이블에 해당 엔티티와 부모 엔티티를 매핑하려는  상황

Parent parent = // 새로 생성하거나, 기존의 것을 얻어오거나

List<Child> cl = new ArrayList<Child>();
for(String name : childNameList){
    Child child;

    // 기등록된 Child가 있는지 체크
    child = childRepository.findByName(childName);

    // 없을 경우 생성
    if(child == null){
        child = new Child();
        child.setName(name);
    }

    cl.add(child);
}

parent.setChildren(cl); // re setting

parentRepository.save(parent);

> cl 에는 기존의 Child와 새로운 Child가 섞여있음
위와 같이 관계를 재셋팅해줄 경우,
교차테이블에 있던 기존 데이터(부모와 매핑되는 교차 데이터들)를 전부 삭제하고, 전달받은 데이터를 일괄 insert 하는 방식으로 진행된다!
전달받은 cl 내부의 Child 값이 새로운 엔티티일 경우 Child 테이블에 INSERT
기존에 있던 엔티티일 경우 기존 엔티티와 연결해주는 행만 교차테이블에 작성된다

/**
 * 전달받은 TAG 체크
 * @param postCateCode
 * @param originalTag
 * @return List(정제된 태그 목록)
 */
private List<Tag> tagCheck(CodeVal postCateCode, List<Tag> originalTag){

    // tagVal 빈 값 제거(tag1,tag2,,, ,,tag3 방지)
    List<String> tagVals = new ArrayList<String>();
    for(Tag tag : originalTag){
        if(!StringHelper.isEmpty(tag.getTagVal())){
            tagVals.add(tag.getTagVal());
        }
    }

    // 중복 제거(tag1,tag1,tag1 ... 과 같이 동일한 태그를 여러번 입력했을 때)
    tagVals = new ArrayList<String>(new HashSet<String>(tagVals));

    // 기등록,미등록 태그 체크
    List<Tag> tags = new ArrayList<Tag>();
    for(String tagVal : tagVals){
        Tag tag;

        // 태그 기등록 체크
        tag = tagRepository.findByPostCateCode_CodeNoAndTagVal(postCateCode.getCodeNo(), tagVal);

        // 미등록 태그일 경우 태그 엔티티 생성
        if(tag==null){
            tag = new Tag();
            tag.setPostCateCode(postCateCode);
            tag.setTagVal(tagVal);
        }

        // 새로운 태그는 Tag 테이블 insert & post_tag 관계 연결
        // 기존에 있던 태그는 post_tag 관계만 연결됨
        tags.add(tag);
    }

    return tags;
}

<!-- more -->