---
title: 6장-다양한 연관관계 매핑
date: 2018-09-06 18:49:25
tags:
---

- 연관관계 매핑 시 고려할 점
다중성(1:1, 1:N 등)
단방향, 양방향
연관관계의 주인

양방향 연관관계에서 항상 서로를 참조하게 하려면 연관관계 편의 메소드를 작성하는것이 좋다.
User Entity :
setTeam(Team team){
     this.team = team;
     if(!team.getUsers().contains(this)){     // 전달받은 팀에 내가 포함되어 있는가?
          team.getUsers().add(this);
     }
}
Team Entity :
addUser(User user){
     this.users.add(user);
     if(user.getTeam() != this){
          user.setTeam(this);
     }
}
> 양방향에서 한쪽에 연관관계를 추가할 때 다른 한쪽도 추가해주는 코드들이다.
앞에 조건으로 체크해서 넣으므로써 무한루프를 방지한다.

앞서 5장에서 언급했듯이 단방향, 양방향은 상황에 따라 지정하는 것이다.
그러므로 일대다 단방향 같은 연관관계도 생성이 되는 것이다.

- 일대다 단방향
팀 테이블에서는 사용자 테이블을 참조하지만,
사용자 테이블에서는 팀 테이블을 참조하지 않을 경우 일대다 단방향 관계가 된다.

class Team{
     @Id @GeneratedValue
     @Column(name="TEAM_ID")
     private Long Id;

     @Column(name="TEAM_NAME")
     pviate String name;

     @OneToMany
     @JoinColumn(name="TEAM_ID") // USER TABLE의 외래키를 TEAM 테이블이 관리함
     private List<User> users = new ArrayList<User>();

     ...
}

class User{
     @Id @GeneratedValue
     @Column(name="ID")
     private Long Id;

     @Column(name="name")
     private String name;

     ...
}
> USER 테이블의 외래키를 TEAM 테이블이 관리하는 특이한 현상이 발생한다.
(일대다 단방향 관계에서 @JoinColumn을 생략하면 기본으로 @JoinTable 전략을 사용하기 때문에 항상 명시해줘야 한다.)

일대다 단방향 방식은 외래키를 자신이 직접 관리하지 않기 때문에, 실행 시 추가적인 UPDATE 구문이 발생하는 단점이 있다.
(자신이 직접 외래키를 관리하는 경우 INSERT 구문 하나만 사용하면 된다.)

USER 엔티티는 TEAM 엔티티 자체를 모르기 때문에 INSERT 시 TEAM_ID 자체가 NULL로 들어간다.
그리고 TEAM을 추가할 때 USER 테이블에 TEAM_ID를 업데이트 하는 구문이 추가로 발생하게 된다.

이런 단점 때문에 일대다 단방향 관계보다는 다대일 양방향 매핑을 사용하는 것이 좋다.

- 일대다 양방향
이는 존재하지 않는 매핑이다
RDB의 특성상 양방향 매핑에서 @OneToMany는 연관관계의 주인이 될 수 없다. 항상 @ManyToOne이 연관관계의 주인이 된다.
그래서 @ManyToOne에는 mappedBy 속성 또한 없다.

- 일대일
주 테이블, 대상 테이블 둘 중 어느 곳이나 외래키 값을 가질 수 있다.
예시 테이블 : USER, LOCKER(사물함)

1) 주 테이블에 외래키
USER 테이블에서 LOCKER_ID를 가지는 방식

@Entity
@Table(name = "USER")
public class User {
    @Id
    @Column(name = "ID")
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;

    @Column(name = "USER_NAME")
    private String userName;

    @OneToOne
    @JoinColumn(name="LOCKER_ID", referencedColumnName="ID")
    private Locker locker;

    public void setLocker(Locker locker) {
        this.locker = locker;
        if(locker.getUser()==null){ // 무한 루프 check
            locker.setUser(this);
        }
    }
}

@Entity
@Table(name="LOCKER")
public class Locker {
    @Id @GeneratedValue
    @Column(name="ID")
    private Long id;

    @Column(name="SIZE")
    private Integer size;

    @OneToOne(mappedBy="locker")
    private User user;

    public void setUser(User user) {
        this.user = user;
        if(user.getLocker()==null){  // 무한 루프 check
            user.setLocker(this);
        }
    }
}
> 단방향, 양방향 설정 가능

2) 대상 테이블에 외래키
LOCKER 테이블에서 USER_ID를 가지는 방식
1)의 방식에서 반대로 설정하면 됨

※ 대상 테이블에 외래키 형태의 경우 프록시의 한계 때문에 Lazy 로딩이 되지 않는다.
대상 테이블의 외래키 형태의 경우 단방향 연관관계로 해줘야 한다.
(연관관계의 주인 -> 주인이 아닌 쪽으로 단방향 연관관계)

주인이 아닌 쪽에서 주인을 OneToOne으로 매핑할 경우,  매번 주인 테이블을 조회하게 된다.



- 다대다
다대다 관계는 중간에 연결 테이블을 두고 다대일 관계로 풀어내는 방식을 사용한다
다대다의 예를 들면, 회원과 상품이 있다.
회원은 여러 상품을 구매할 수 있고, 상품은 여러 회원에 의해 구매될 수 있다.
이럴 경우 중간에 교차테이블을 줘서 다대일 관계로 풀어내게 된다. ex) MEMBER_PRODUCT 테이블

근데 자바에서는 RDB와 달리 오브젝트 2개로 다대다 관계를 형성할 수 있다(컬렉션 이용)


ManyToMany 관계는 @ManyToMany 와 @JoinTable 어노테이션을 사용하여 설정할 수 있다.

@JoinTable(name="MEMBER_PRODUCT", // 교차 테이블 이름
joinColumns=@JoinColumn(name="MEMBER_ID"), // 주인 방향 교차 컬럼
inverseJoinColumns=@JoinColumn(name="PRODUCT_ID")) // 반대 방향 교차 컬럼
private List<Product> productList;

양방향으로 하려면 양쪽 중 원하는 곳에 mappedBy를 적어 연관관계의 주인을 지정하면 된다. (주인은 무슨 기준으로 정하지?)
반대쪽에도 @ManyToMany 어노테이션을 써줘야 한다.

<!-- more -->