---
title: 4장-엔티티 매핑
date: 2018-09-06 18:49:02
tags:
---

2JPA 사용에서 가장 중요한 것은 테이블과 엔티티를 정확히 매핑하는 것이다.
대표적으로 4가지의 매핑이 있다

객체와 테이블 매핑 : @Entity, @Table
기본키 매핑 : @Id
필드와 컬럼 매핑 : @Column
연관관계 매핑 : @ManyToOne, @JoinColumn

- @Entity
JPA가 관리하는 엔티티가 됨. 이름은 클래스명을 그대로 사용하고, name 속성으로 지정할수도 있다.
(다른 패키지내에 다른 이름이 존재할 경우 적절히 지정해서 충돌하지 않도록 해야한다)
※ 필수사항
public 이나 protected 접근지시자의 기본 생성자는 필수로 있어야함(JPA가 엔티티 객체를 생성할 때 기본 생성자를 사용하기 때문)
final 클래스, enum, interface, inner 클래스에는 사용 불가능
필드에 final을 사용하면 안된다.

- @Table
엔티티와 매핑할 테이블을 지정한다(name 속성). 지정하지 않으면 클래스명을 기본으로 사용한다.

- 엔티티 컬럼과 DB 필드 매핑 레퍼런스 : 4.7 (145p) 참조
1) 컬럼 매핑
@Column(name="col_id") // _ 표기법
private String colId; // Camel 표기법
의 형태로 매핑
@Column으로 매핑하지 않은 경우 필드의 이름과 타입으로 컬럼 생성
String은 따로 크기 지정하지 않을 경우 varchar(255)

- @Column의 옵션 종류
name : 테이블 컬럼 이름
insertable, updatable : 엔티티 저장/수정 시 해당 필드가 영향을 받을건지의 여부. default = true
nullable(DDL) : not null 여부. default : true
unique(DDL) : 해당 컬럼에 unique 제약조건을 걸 때 사용
columnDefinition(DDL) : 컬럼 정보를 직접 줌
length(DDL) : 문자 길이. String type에만 사용됨
> (DDL) 부분은 hibernate.hbm2ddl.auto를 통해 테이블이 생성될때만 유효한 옵션이다.
이미 테이블이 생성된 경우는 영향을 주지 않는다.
그래도 저렇게 해놓으면 나중에 보기 편하다 ㅋㅋ

※ primitive type과 nullable
int data -> data integer not null // primitive에는 null이 들어갈 수 없다
Integer data -> data Integer
@Column int data -> data integer // @Column은 nullable의 default가 true이다.

ex) 
@Column(name="name", nullable=false, length=20)
> NAME varchar(100) not null

2) @Enumerated
자바 enum을 이용하여 값을 저장할 수 있다.

@Enumerated(EnumType.STRING) // 저장되는 값에 enum의 이름을 그대로 사용
@Enumerated(EnumType.ORDINAL) // 저장되는 값에 enum의 ordinal을 사용

ex) 
@Enumerated(EnumType.STRING)
private Fruit fruit;
> setFruit(EnumType.APPLE); 시 데이터베이스에는 APPLE 이라는 값이 저장됨

@Enumerated(EnumType.ORDINAL)
private Fruit fruit;
> setFruit(EnumType.APPLE); 시 데이터베이스에는 0이 저장됨

3) @Temporal
날짜형은 @Temporal 어노테이션 사용
@Temporal(TemporalType.TIMESTAMP); // timestamp형으로 생성
@Temporal(TemporalType.DATE); // date형으로 생성
@Temporal(TemporalType.TIME); // time형으로 생성

ex)
@Temporal(TempralType.DATE)
Date regDate;

자바의 Date 타입에는 년월일 시분초가 다 들어 있지만, 데이터베이스의 자료형은 Date, Time, TimeStamp로 나뉜다.

4) @Lob
데이터베이스의 BLOB, CLOB가 매핑한다.
사용되는 필드의 데이터 타입이 String이면 CLOB으로 매핑하고, 나머지는 CLOB으로 매핑한다.

@Lob
String content;
> oracle : content CLOB
> mysql : content LONGTEXT

5) @Transient
데이터베이스에 매핑하지 않는 컬럼에 사용한다.



- 데이터베이스 스키마 자동 생성
pesistence.xml에
<property name="hibernate.hbm2ddl.auto" value="create"/>
라고 작성하면, 애플리케이션 실행 시점에 @Entity를 읽어서 테이블을 자동으로 생성한다.(database dialect에 맞춰서)
> JPA 학습에 좋다. 엔티티가 어떻게 생성되는지 볼 수 있음

- 기본키 매핑
@Id 사용 (자바 기본형, Wrapper형, String형 등)

기본키 선택 방법은 자연키와 대리키가 있다.
자연키는 의미가 있는 키를 뜻한다. (주민등록번호, email, 전화번호 등)
대리키는 따로 의미가 없는 임의로 만들어진 키를 의미한다.
자연키보다는 대리키의 사용을 좀 더 권장한다. 자연키는 어떻게든 문제가 발생할 요소가 많다.
그에 비해 대리키는 외부 풍파에 잘 흔들리지 않는다.

기본키는 절대 변해선 안된다.
이러한 원칙으로 인해 저장된 엔티티의 기본키 값을 변경하려고 하면 예외가 발생한다.
이를 대비에 setId(String id) 같은 컬럼을 private으로 선언하는것도 방법이다.

기본키 값 할당은 직접할당과 자동생성 전략이 있다.
직접할당은 말 그대로 persist 하기전에 @Id의 값을 set 하고 persist 하는 것이고,

자동생성 전략은 IDENTITY, SEQUENCE, TABLE 전략이 있다.
식별자 자동 할당은 @GeneratedValue 어노테이션을 사용한다. 
> 숫자형 변수를 사용해야 한다. Integer, Long 등
※ 자동생성 전략을 사용하려면 persistence.xml에
<property name="hibernate.id.new_generator_mappings" value="true"/>를 꼭 추가해야 한다. (기본값이 false이다)

1) IDENTITY 전략
기본 키 생성을 데이터베이스에게 위임하는 것이다. MySQL에서 주로 사용한다.
@GeneratedValue(strategy=GenerationType.IDENTITY)
persist시 JPA가 데이터베이스를 추가로 조회하여 식별자에 값을 자동으로 할당한다.

엔티티가 영속상태가 되려면 식별자가 반드시 필요하다(key, value mapping)
참고로 이 방식은 데이터베이스에서 식별자 값을 얻어오므로, persist 시 무조건 insert 쿼리를 날려야 한다.
(쿼리를 날려서 식별자 값을 얻은 후, 영속성 컨텍스트에 식별자 값으로 저장한다)
그러므로 쓰기 지연 방식은 동작하지 않는다.

2) SEQUENCE 전략
...

3) TABLE 전략
...

4) AUTO 전략 ★
GenerationType.AUTO로 지정하면 데이터베이서 dialect에 따라 IDNETITY, SEQUENCE, TABLE 중 하나를 선택해준다.
@GeneratedValue의 기본속성은 AUTO이므로 속성을 넣지 않으면 이것이 선택된다.

<!-- more -->