---
title: 5장-연관관계 매핑 기초
date: 2018-09-06 18:49:15
tags:
---

방향
: 단방향, 양방향. 단방향은 객체관계만 존재하고, 테이블 관계는 항상 양방향이다
다중성
: 1:1, 1:N, N:1, N:M
연관관계의 주인
: 객체를 양방향 연관관계로 만들면 연관관계의 주인이 있다


회원(Member)과 팀(Team)이 있다.
둘은 N:1의 관계를 가진다.

- 객체는 기본적으로 단방향 연관관계를 가진다.
이후에 사용하는 @ManyToOne과 @OneToMany 등은 연관관계를 맺어주는 어노테이션이고, 각자의 상황에 따라 선택하여 사용한다

두 테이블의 한쪽에만 기재해줘서 단방향 연관관계를 형성할 수 있고,
서로에게 각각의 참조를 줘서 양방향 연관관계를 가지게도 할 수 있다.
Member{
     Integer Id,
     String Name,
     Team team
}

Team{
     Integer Id,
     String Name,
     Member member
}
> 그러나 이는 양방향 관계라기보단 서로 다른 단방향 관계라고 보는것이 맞다.

Member member1 = new Member(~~);
Team team = new Team();

member1.setTeam(team);
member1.getTeam();
> 접근 방법


- 테이블은 조인이라는 특성때문에 항상 양방향 연관관계를 가진다.
CREATE TABLE MEMBER(
     MEMBER_ID VARCHAR(255) PRIMARY KEY,
     TEAM_ID VARCHAR(255) REFERENCES BY TEAM(TEAM_ID),
     USER NAME VARCHAR(255)
)

CREATE TABLE TEAM(
     TEAM_ID VARCHAR(255) PRIMARY KEY,
     NAME VARCHAR(255)
)
> 객체와 달리 참조를 가지지 않고, 외래키라는 값을 가진다.
이 값은 JOIN에 사용되고, 서로 양방향 연관관계 탐색이 가능하다.
둘의 패러다임이 확실히 다르다. 객체는 참조를 이용하여 객체를 탐색하고, 테이블은 JOIN을 이용한다

JPA는 두 패러다임을 합쳐주는 역할을 한다.


- 위 두 테이블을 JPA로 옮기면
@Entity
@Table(name="MEMBER")
public class Member{
     @Id
     @Column(name = "MEMBER_ID")
     private String id;
     
     @Column(name = "USER_NAME")
     private String userName;

     // 연관관계 매핑
     @ManyToOne // N:1
     @JoinColumn(name="TEAM_ID")
     private Team team;

     // setter, getter
     public void setTeam(Team team){
          this.team = team;
     }
     ....
}

@Entity
@Table(name="TEAM")
public class Team{
     @Id
     @Column(name="TEAM_ID")
     private String id;

     @Column(name="NAME")
     private String name;

     // setter, getter
}

- 관계 어노테이션
1) @JoinColumn
name : 매핑할 (my)외래키 이름. 기본값 : 테이블명_참조 테이블의 기본키 컬럼명
referencedColumnName : 외래키가 참조하는 대상(your) 테이블의 컬럼명. 기본값 : 참조 테이블의 기본키 컬럼명

위 상황에서 @JoinColumn을 생략할 경우
MEMBER테이블에서 team_TEAM_ID를 가지고 TEAM 테이블의 기본키인 TEAM_ID에 관계를 맺는다
> 생략하려면 필드명명을 잘해줘야함. 위와 같은 상황에서 생략하면 오류남..
게다가 꼭 대상 테이블의 기본키가 아닌 다른 Unique Key에 Join을 할수도 있으니 유념(referencedColumnName)

2) ManyToOne
<optional, fetch, cascade, targetEntity>
N:1 관계에서 사용
optional : false로 설정하면 연관된 엔티티가 항상 있어야 함. FK Not NULL과 동일한 의미. default = true
fetch : 글로벌 패치 전략. EAGER, LAZY > 8장
cascade : 영속성 전이 기능 > 8장

ex)
Team team1 = new Team("team1","팀1");
em.persist(team1);

Member member1 = new Member("member1","멤버1");
member1.setTeam(team1);
Member member2 = new Member("member1","멤버1");
member2.setTeam(team1);

em.persist(member1);
em.persist(member2);

team1이 영속성 컨텍스트에 저장되고,
저장된 team1의 값이 member1과 member2에 바인딩 되고
flush 후 테이블에 저장한다.

이렇듯 엔티티에 연관관계를 지정해놓으면 JPA가 자동으로 처리해준다.
업데이트 또한 마찬가지다. 영속성 컨텍스트에 들어갔을때 setter만 호출해주면 된다.
사용자는 기본 컬럼을 사용했을때와 별다른 사용의 차이가 없다.

※ 연관관계 삭제
team1을 삭제하려고 할때 member1, member2의 team 값을 먼저 null로 해줘야한다 (외래키 제약조건)
> member1.setTeam(null);
   member2.setTeam(null);
   team1.remove();

3) OneToMany
<fetch, cascade, mappedBy, targetEntity, orphanRemoval>
일대다 관계는 여러건과 연관관계를 맺을 수 있으므로 컬렉션을 사용해야 한다
public class Team{
     @Id
     @Column(name="TEAM_ID")
     private String id;

     @Column(name="NAME")
     private String name;

     @OneToMany(mappedBy = "team")
     private List<Member> memberList;
     // setter, getter
}

조회 : team.getMemberList(); // 자신을 부모로 갖고있는 Member 테이블의 데이터들이 조회된다.. +_+ (양방향 연관관계를 맺었을 경우. 아래에서 설명)

@OneToMany
mappedBy : 양방향 매핑일 때 사용. 반대쪽에서 자신을 저장한 필드 이름을 값으로 주면 된다.(Member Class에는 Team team; 으로 되어있으므로)
                  걔네들이 정해놓은 내 이름 ㅋㅋ

mappedBy가 필요한 이유는, 객체에는 양방향 연관관계라는 것이 없기 때문이다.(테이블은 양방향 연관관계가 가능하다)
단방향 연관관계 2개를 애플리케이션 로직으로 잘~묶어서 양방향인것처럼 보이게 해놓은 것이다.

- 연관관계의 주인
객체에서 양방향 연관관계를 형성할 경우, 객체는 둘인데 외래키는 하나가 되어 둘 사이에 차이가 발생한다.
이럴때 외래키를 관리할 연관관계 주인을 둘 중에 하나 정해줘야 한다
외래키 주인만이 연관관계에 매핑되는 외래키를 관리(등록,수정,삭제) 할 수 있다.
(주인이 아닌 테이블은 mappedBy를 사용해서 외래키를 관리할 주인을 지정해줘야 한다)

근데 중요한건, 맥락상 이해와는 좀 다르게 연관관계의 주인은 FK를 가진쪽이 되어야 한다.
N쪽 테이블의 경우 FK를 자신의 필드로 직접 소유하고 있기 떄문에 자기자신을 관리하면 되지만,
PK를 가진쪽은 자신이 자식 테이블의 필드를 자기가 직접 소유하고 있는 것이 아니기 때문에 다른 테이블의 외래키를 관리해야 한다.

여기서 말하는 연관관계의 관리란 이런것이다.
member1.setTeam(team);
member1.setTeam(null);
...
외래키를 직접 지정해주고 있다
하지만 주인이 아닌 team의 경우 외래키를 직접 지정해주지 않아도 자동으로 입력된다.

> 즉 여기서 말하는 연관관계의 주인이란 외래키값을 등록하거나 수정하는 행위를 하는 주체(부모테이블)를 말하는 것이 아니라,
두 테이블이 연관관계를 맺게 되게끔 외래키를 관리해주는 테이블을 말한다.
그러므로 외래키를 가진 자식테이블인 Member가 연관관계의 주인이 되는 것이다.
Team에서 setMemberList로 Member들을 지정해주지 않아도 Member에서 setTeam을 하게되면 자동으로 연관관계가 결정되지 않는가 ㅋㅋ(의문 아님)

관계 관리이다. 값 관리가 아니다. (내가 헷갈렸어서 강조해둠 ㅋㅋ)

- 연관관계 주인에 값을 저장하지 않은 경우(자주 하는 실수)
Member member1 = new Member();
Member member2 = new Member();

em.persist(member1);
em.persist(member2);

Team team = new Team();
team.getMemberList().add(member1);
team.getMemberList().add(member2);
em.persist(team);
> Team의 컬렉션에 member1, member2를 담고 team을 저장했다
그러나 member 테이블을 조회해보면 team_id의 값이 null로 비어있음을 볼 수 있다 (어찌 보면 당연하다)
연관관계의 설정은 연관관계의 주인(외래키를 가진 쪽)만이 지정할 수있다.

team.getMemberList().add(member1); 는 의미가 없고 무시된다.
연관관계의 주인만이 외래키를 지정하는
member1.setTeam(team);
member2.setTeam(team);
가 의미가 있는 행위이다.

근데 사실 위처럼 연관관계의 주인에만 값을 주입하는것은 어찌되면 또 문제가 되기도 한다..

member1.setTeam(team);
member2.setTeam(team);
을 통해 외래키의 주인이 연관관계를 설정하고

team.getMemberList() 했을 때
member1, member2가 나오는 것은 JPA라는 ORM Framework가 개입했기 때문에 가능한 일이다.

이게 만약 순수한 자바 오브젝트라면 어떻겠는가?

team.getMemberList() 했을 때 member1, member2가 나올까? 당연히 아니다. 빈 리스트가 나온다.

하지만 우리는 ORM Framework를 사용하니까 이런건 고려할 대상이 아니지 않나? 라고 생각할 수 있지만
ORM은 테이블<>객체 매핑 프레임워크이다.
그리고 우리는 그에 상응하게 객체까지 고려하여 JPA를 사용해야 한다.. (왜?)

연관관계의 주인에서만 객체간 관계를 맺어줘야 하고, 주인이 아닌쪽에서는 관계를 맺으면 관계가 성립하지 않는 불편함도 있기 떄문에..
항상 두 행위가 하나인 것 처럼 사용하는 것이 안전하다.

- User.java
public void setTeam(Team team) {
    this.team = team;
    team.getUsers().add(this);
}

- Team.java
List<User> users = new ArrayList<User>();
public void addUser(User user){
    this.users.add(user);
    user.setTeam(this);
}
> 이처럼 해주면 어느 한쪽의 메서드를 호출하더라도 자동으로 양방향 관계를 설정하게 된다
연관관계의 주인이 아닌 쪽에서 관계를 설정하면 추가적인 update가 발생함을 유념하자

- 연관관계에 있는 버그
user1.setTeam(team1);
user1.setTeam(team2);

team1.getUsers(); // user1이 출력
team2.getUsers(); // user1이 출력

team2로 관계를 변경해줬는데도 team1의 getUsers()에서 user1이 출력된다.

위는 영속성이 끊기지 않은 상태에서 발생한 상황이다.
애초에 team.users는 관계의 주인이 아니기 때문에 영속성이 끊기면서 flush가 발생해도 관계변경에 아무런 영향도 미치지 않는다.
하지만 영속성이 끊기지 않은 상태에서는 getUsers 하면 user1이 출력되니.. 그래서 일종의 버그이다

public setTeam(Team team){
     // 기존팀 관계 제거
     if(this.team != null){
          this.team.getUsers().remove(this);
     }

     this.team = team;
     team.getMembers().add(this);
}
> 이와 같이 관계 변경시 기존 관계를 제거하는 코드를 넣어준다.

단방향 연관관계와 양방향 연관관계는 상황에 따라 적절히 선택하도록 한다
예를 들면 주문, 상품 테이블의 경우가 있다
둘은 N:1의 관계를 갖는다.
주문 테이블의 경우 상품 테이블에 대한 정보를 항상 필수적으로 들고 다니므로
@ManyToOne을 통해 관계를 맺어준다.
하지만 상품테이블에서 주문 테이블의 정보를 조회하는 일은 별로 없다..
이럴 경우 그냥 주문 -> 상품으로의 단방향 연관관계만 맺어줘도 충분하다.

> 연관관계의 주인이 아닌 OneToMany의 연결은 조회를 위한 JPQL이나 객체 그래프 탐색 시 사용되는 것이다.
그러므로 위와 같이 사용빈도에 따라 선언 여부가 결정된다.

<!-- more -->