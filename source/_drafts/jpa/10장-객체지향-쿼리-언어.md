---
title: 10장-객체지향 쿼리 언어
date: 2018-09-06 18:53:01
tags:
---

JPA 공식 지원 : JPQL, Criteria Query - JPQL을 편하게 작성하도록 도와줌, Native SQL - SQL을 직접 사용
비공식 : QueryDSL - JPQL을 편하게 작성하도록 도와줌, JDBC 직접사용, Mapper 클래스 사용

- JPQL
객체를 대상으로 하는 객체지향 쿼리
객체를 대상으로 하므로 특정 SQL에 의존하지 않음(JPA가 JPQL을 분석해서 dialect를 토대로 SQL을 만들기 때문)
1) select문 사용법
SELECT m FROM Member m WHERE m.userName='test'
> Member는 엔티티명, userName 또한 엔티티에 선언된 필드명이다. 이는 대소문자를 구분한다(SQL 기본 문법은 대소문자 구분하지 않음)
엔티티명은 @Entity(name="XX")로 지정할 수 있다. 지정하지 않으면 클래스명을 엔티티명으로 사용한다.
별칭은 필수로 지정해야 한다. 위의 JPQL에서는 m 이다.

2) TypeQuery, Query
반환타입을 명확하게 지정할 수 있으면 TypedQuery를 사용하고, 명확하게 지정할 수 없으면 Query를 사용한다.

TypedQuery<Member> query = em.createQuery("SELECT m FROM Member", Member.class);
List<Member> memberList = query.getResultList();
> 조회 대상이 Member 엔티티로, 명확하다.

Query query = em.createQuery("SELECT u.id, u.userName FROM User u");

List resultList = query.getResultList();

System.out.println(resultList);

for(Object o : resultList){
    Object[] oo = (Object[])o;

    System.out.println(oo[0]);
    System.out.println(oo[1]);
}
> u.id=Long, u.userName=String 이라 조회대상이 애매함. 이럴 경우 Query를 사용함
조회하는 행의 개수만큼 Object 배열로 전달됨
행의 개수가 하나이면 Object가 전달된다. 나는 하나일 경우에는 TypedQuery를 쓰는게 맞다고 생각된다 ..

getResultList() : 결과를 예제로 반환. 결과가 없으면 빈 컬렉션
getSingleResult() : 결과가 정확히 하나일 때 사용. throws NoResultException, NonUniqueResultException
> 호출 시점에 쿼리를 실행한다

3) 파라미터 바인딩
TypedQuery<User> query = em.createQuery("SELECT u FROM User u WHERER u.id=:id", User.class);
List<User> list = query.setParamater("id",Long.valueOf(1)).getResultList();  // 메서드 체인 방식으로 되어 있어서 이와 같이 호출 가능
> 파라미터의 값은 엔티티의 타입과 동일한 타입이 전달되어야 한다

이름 기준말고 위치 기준으로도 지정 가능하다..
em.createQuery("SELECT u FROM User u WHERER u.id=?1", User.class).setParameter(1, id);
> 명확하지 않으니 이름기준을 사용하도록 하자

4) 프로젝션
조회할 대상 지정. 엔티티, 임베디드, 스칼라 타입이 있다.

4-1) 엔티티
SELECT m FROM Member m
SELECT m.team FROM Member m
> 조회한 엔티티는 영속성 컨텍스트에서 관리된다. (당연함. find 메서드를 썼을때 영속성 컨텍스트에서 관리되던 것과 동일 맥락)

4-2) 임베디드
엔티티와 비슷하게 사용된다. 하지만 임베디드 타입은 엔티티의 시작점이 될 수 없다.
em.createQuery("SELECT u.address FROM User u", Address.class).getResultList();
sql > select city, street, zipcode from user;

> 임베디드 타입은 엔티티 타입이 아닌 값 타입이므로 영속성 컨텍스트에서 관리되지 않는다.

4-3) 스칼라
숫자, 문자, 날짜와 같은 기본 데이터 타입을 말함.
List<String> list = em.createQuery("SELECT u.userName FROM User u", String.class).getResultList();

4-4) 여러값 조회
List<Object[]> resultList = em.createQuery("SELECT u.id, u.team, u.locker FROM USER u").getResultList();

for(Object[] o : resultList){
    String id = (String)o[0];
    Team team = (Team)o[1];
    Locker locker = (Locker)o[2];
}
> TypedQuery에서 언급했던 내용이다. 반환형인 Object[]를 제네릭으로 선언하면 위와 같이 코드가 더 간결해진다.

1-? ) 집합과 정렬

COUNT
결과 수를 구함. return Long
MAX, MIN
최대, 최소값을 구함. 문자,숫자,날짜 등에 사용됨
AVG
평균값을 구함. 파라미터는 숫자 타입만 가능함. return Double
SUM
합을 구함. 파라미터는 숫자타입만 사용.반환타입 : 정수합 - Long, 소수합 - Double, BigInteger합 - BigInteger, BigDemical합 - BigDemical

NULL 값은 무시하므로 통계에 잡히지 않는다
값이 없는데 SUM, AVG, MAX, MIN 을 사용하면 결과가 NULL이다. COUNT는 0이다.
DISTINCT를 집합 함수 안에 사용해서 중복값 제거 후 집합을 구할 수 있다. COUNT(DISTINCT m.age)
DISTINCT를 COUNT에서 사용할 때 임베디드 타입은 지원하지 않는다(?)

1-? ) GROUP BY, HAVING
SELECT t.name, COUNT(m.age), SUM(m.age), AVG(m.age), MAX(m.age), MIN(m.age)
FROM Member m LEFT JOIN m.team t
GROUP BY t.name
HAVING AVG(m.age) >= 10
> 기본 SQL 문법과 거의 동일함

1-? ) ORDER BY
SELECT
u.userName, count(u.userName) as cnt
FROM User u
GROUP BY u.userName
ORDER BY cnt
> 별칭 사용가능하고, 별칭을 ORDER BY 절에 사용가능하다(기존 SQL과 동일)

1-? ) JOIN
객체의 연관 필드를 통해 JOIN 해야함
SELECT m, t
FROM Member m
INNER JOIN m.team
> ON 절은 필요없다. 선언한 관계에 따라 자동으로 ON 절이 생성되어 JOIN 된다.
애초에 JPQL이 ON 조건을 지원하지 않음. but 2.1 부터 ON 조건 추가

@Query(value = "SELECT p, COUNT(pvh) as CNT FROM PostContent p "
+ "LEFT JOIN p.postViewHists pvh "
+ "WITH pvh.id.viewDh > :viewDh "   // HQL
> HQL로 JOIN 조건 추가하는 법. AND로 들어감

1-? ) 서브쿼리
서브쿼리는 WHERE, HAVING 절에만 사용 가능함
[NOT] EXISTS (sub query)
[ALL | ANY | SOME] (sub query)
[NOT] IN (sub query)


- QueryDSL
@Override
public Page<PostContent> search(Map<String, Object> paramMap, Pageable page) {
    String main = (String)paramMap.get("main");
    String category = (String)paramMap.get("category");
    String editor = (String)paramMap.get("editor");
    String tag_ = (String)paramMap.get("tag");
    String title = (String)paramMap.get("title");

    QPostContent postContent = QPostContent.postContent;
//        QPostRec postRec = QPostRec.postRec;
    QTag tag = QTag.tag;

    JPQLQuery<PostContent> query = from(postContent);
    BooleanBuilder condition = new BooleanBuilder();

    if(!StringHelper.isEmpty(main)){
        query.innerJoin(postContent.postRecs);
    }

    // 카테고리
    if(!StringHelper.isEmpty(category)){
        condition.and(postContent.postCateCode.codeNo.eq(Integer.valueOf(category)));
    }

    // 에디터
    if(!StringHelper.isEmpty(editor)){
        condition.and(postContent.manager.company.companyNo.eq(Integer.valueOf(editor)));
    }

    if(!StringHelper.isEmpty(tag_)){
        query.innerJoin(postContent.tags,tag);

        condition.and(tag.tagVal.contains(tag_));
    }

    if(!StringHelper.isEmpty(title)){
        condition.and(postContent.title.contains(title));
    }

    query.where(condition);

    QueryResults<PostContent> result = query.fetchResults();

    return new PageImpl<PostContent>(result.getResults(),page,result.getTotal());
}

query.innerjoin(postContent.postRecs); // postRecs라는 alias로 join 되므로 조건추가에 제약이있다.

QPostRec postRec = QPostRec.postRec; // 기본 alias 사용
QPostRec postRec = new QPostRec("alias명");
query.innerjoin(postContent.postRecs, postRec);
// QEntity를 전달해줌으로써 alias 지정이 가능함. 조건추가가 가능해진다.


- 벌크 연산
한건씩 DML 하는것이 아니라 여러건에 한방에 DML을 날리는 것을 벌크연산이라고 한다.
하이버네이트는 이 또한 지원한다.
JPQL로 벌크성이 있는 쿼리를 작성해서 날리면 된다. hibernate에서는 executeUpdate() 메서드를 사용한다.

※ 벌크연산은 영속성 컨텍스트를 무시하고 바로 데이터베이스에 직접 쿼리한다.
이럴경우 아래와 같은 문제점이 발생할 수 있다.

"엔티티 조회 -> 벌크성 연산 수행 -> 엔티티 조회"
Board board = boardRepository.findOne(boardNo);
syso(board.getViewCnt); // ex) 10
* bulk update // ex) cnt += 10;
syso(board.getViewCnt); // 10
> 벌크연산이 영속성 컨텍스트를 무시했다.

3번째 엔티티조회에서 벌크성 연산이 적용되지 않은 엔티티를 보게 된다.
이는 위에서 언급했듯이 벌크연산 자체가 영속성 컨텍스트를 무시하기 때문이다.

해결법
가장 실용적인 방법은 벌크연산을 선행 후 조회하는 것이다.
이 외에도 em.refresh() 메서드를 통해 영속성 컨텍스트를 초기화 하는 방법이 있다.
해당 메서드는 가지고있던 영속성 컨텍스트들을 재조회 한다.

<!-- more -->