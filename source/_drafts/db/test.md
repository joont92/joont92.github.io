# SQL 모드
DB의 초기설정을 지정할 수 있는 sql_mode 라는 것이 있다.  
기억나는건..  
||로 문자열 연결 가능 like 오라클  
GROUP BY 컬럼과 조회 컬럼이 맞지 않아도 되는 현상을 제한하기.  
문자열은 무조건 ''로 감싸게 하기. 원래는 ""로도 감쌀 수 있다.  
my.cnf에 sql_mode=STRICT_ALL_,ANSI.. 의 형태로 지정 가능하다.  

# 영문 대소문자
영문 대소문자 구분 여부는 사용하는 운영체제를 따른다.  
테이블도 하나의 파일로 저장되기 때문이다.  
리눅스의 경우 구분하므로, 테이블 생성 시 대소문자 여부를 잘 정해서 생성해야 한다.  
대문자나 소문자 중 하나로 선택해서 사용하는 것이 좋다.  

# 예약어
오브젝트(테이블, 프로시저 등) 생성 시에 키워드를 이름으로 사용할 수 없는데,  역따옴표(\`)를 사용해서 감싸면 가능하다.  
하지만 가급적 하지 않는 것을 추천한다..  

# 메뉴얼 읽는법
{} 는 무조건 하나를 선택해야 하는 것  
[] 는 생략 가능  
..는 반복 가능  

# 리터럴
## 문자열
''로 감싸짐. char, varchar  
## 숫자
'' 없이 그냥 입력하면 숫자임  
문자 < 숫자 이므로 두개를 연산하면 문자가 숫자로 형변환됨  
ch_col1 = 10; 과 같이 비교할 경우 컬럼이 숫자로 변환되어 오류 발생 혹은 인덱스를 못 타는 현상이 발생할 수 있으니, 조심해야 한다.  
## 날짜 
Date, DateTime 등의 형태로 저장됨  
SYSDATE()는 실행한 시점마다 다르게 계산되고, NOW()는 쿼리를 실행한 시점의 시간을 반환한다.  
즉, SELECT SYSDATE(), SLEEP(1), SYSDATE() FROM dual;  
의 경우 각 SYSDATE()의 시간이 다름을 의미함.  
좋지 않으니까 가급적 NOW()를 쓰는것이 좋다.  
NOW()의 상세 버전인.. CURRENT_TIMESTAMP, CURRENT_DATE, CURRENT_DATETIME.. 차이가 뭐더라?  
## 불리언
TRUE, FALSE 값을 가지는 컬럼인데 실제로는 불리언이 아니라 TNYINT로 저장된다.  
TRUE는 1, FALSE는 0이다. TRUE는 1이상이 아니라 1임을 주의해야 한다.  

# 연산자
## 동등 비교
=, IN  
## 부정 비교
<>, !=
## NOT 연산자
!  
기존 연산의 결과를 반대로 돌린다.  
애매하게는 쓰지 말자 ex) !test  
## AND, OR 연산자  
&&, || 로 대체할 수 있는데 가급적 AND, OR로 쓰는 것을 권장한다.  
## 나누기, 나머지 연산자  
SELECT 10/3 FROM dual; -- 3.333333  
SELECT 10 DIV 3 FROM dual; -- 3  
SELECT 10 MOD 3 FROM dual; -- 1  
## LIKE 연산자
일치하는 부분을 검색하는데 사용되는 연산자이다.  
%는 여러개 일치, _는 한개 일치를 뜻한다.  
## BETWEEN 연산자
col1 BETWEEN A AND B 는 A값 이상 B값 이하를 뜻한다.  
col1 >= A AND col1 <= B 로 해도 별 차이 없다.  
## IN 연산자
동등비교를 여러개 한다고 보면 된다.  
col1 IN(A,B,C) -- col1 값이 A이거나 B이거나 C인 경우  

# 내장함수
## NULL 값 비교
IFNULL(A,B) : A가 NULL일 경우 B, NULL이 아닐 경우 A  
ISNULL(A) : A가 NULL인지 아닌지 반환. NULL일 경우 1, 아닐 경우 0  
## 현재 시각 조회  
위에서 설명함  
## 날짜 <> 문자
이것도 위에서;;
## 날짜 연산
문자열과 날짜를 비교할 경우 자동 형 변환됨. 날짜 > 문자  
굳이 STR_TO_DATE 같은 함수를 쓰지 않아도 됨.  
DATE_FORMAT(날짜, 포멧)은 문자열을 지정한 날짜 포멧으로 변경시켜 주는 것  
%y : 연도
%m : 월
%d : 일
%H, %h : 시간(24시간, 12시간)  
%i : 분  
%s : 초  
STR_TO_DATE를 쓰는 경우도 있는데.. 문자열이 MySQL이 인식할 수 없는 형태의 정규 포멧이 아닐 경우다.  
STR_TO_DATE('2018^8^24', '%y^%m^%d');  
DATE_ADD(날짜, INTERVER 기간)
3 DAY, 3 YEAR, 3 WEEK 등등
## 문자열 처리
LPAD, RPAD  왼쪽이나 오른쪽에 지정한 문자를 개수 만큼 채움  
LPAD('문자열', 10, '*') : *******문자열
LTRIM, RTRIM, TRIM : 공백제거. 왼쪽, 오른쪽, 양쪽
## 문자열 결합
CONCAT(기존문자열, 추가할 문자열...)  
추가할 문자열은 가변인자로 계속 연결 가능.  
sql_mode를 바꿔주면 오라클 처럼 || 로 연결할 수 있기도 하지..  
## 값의 비교와 대체
CASE WHEN..THEN..END  
switch문과 비슷하다.  
CASE str 
    WHEN 'A' THEN 'A matched'  
    WHEN 'B' THEN 'B matched'  
    ELSE 'Nothing matched'  
END  
각각의 부분에 대해 동등(=) 연산을 한다.  

아래처럼 따로 조건을 줄 수도 있다.  
CASE
    WHEN str >= 65 AND str <= 90 THEN 'Upper Case'  
    WHEN str >= 97 AND str <= 122 THEN 'Lower Case'  
END 

THEN 부분에 쿼리를 실행해서 조건별 쿼리 실행도 가능하다.  
CASE sex  
    WHEN 'M' THEN (SELECT salary from salaries WHERE ~~ LIMIT 1)  
    WHEN 'F' THEN 0  
END  
남자일때는 쿼리를 실행하고, 여자일떄는 쿼리를 실행하지 않는다.  
이로 인해 불필요한 쿼리가 실행되는 것을 막을 수 있다.  
## 타입 변환
CAST(변수 AS 변환할타입)  
> CAST(str AS INTEGER)  
CONVERT(변수, 타입)  
CAST와 다른 점은 collation도 변경해줄 수 있다는 점이다.  
## 이진값 <> 16진수
HEX : 이진값 -> 16진수  
UNHEX : 16진수 -> 이진값..  
어디서 썼더라?  
## MD5, SHA
비대칭형 암호화 알고리즘에 사용된다.  
SHA는 SHA1 알고리즘, MD5는 메세지 다이제스트 알고리즘을 사용한다.  
회원 암호화 하는 과정에서 자주 사용된다.  
## 디버깅용 함수
SLEEP(초) : 실행되면 그 구간만큼 멈춘다. 디버깅 용도로 사용한다.  
BENCHMARK(쿼리문, 실행횟수) : 쿼리문이 실행되는데 몇초 걸리는가 테스트 해볼 수 있다.  
실행횟수로 여러번 반복해볼 수도 있는데.. 솔직히 별로 안쓸듯.  
왜냐면 쿼리문은 하나의 컬럼, 레코드인 스칼라값을 반환해야 하고,  
실행횟수도 실제로 10번 실행하는 것과 BENCHMARK로 10번 실행하는것이 다르기 떄문.  
실제 쿼리를 10번 실행하는 서비스 환경에서는 10번의 네트워크 자원, 서버 자원등이 다 요청되지만 BENCHMARK의 경우 단 1번만 요청되기 떄문.  
## IP 주소 변환
IP주소란 32바이트로 이루어진 숫자를 말한다.  
15바이트의 문자열로 저장하게 되면.. 비교검색을 하기가 되게 애매해진다.  
10진수의 문자열이 .으로 나뉘어져있기 떄문이다.  
어떻게 저장해야 할지 정해야 하는데, 이떄 사용하기 좋은것이 IP주소 변환용 함수인  
INET_ATON, INET_NTOA 이다.  
INET_ATON('IP주소') 를 하게 되면 number형 변수로 바꿔주고
INET_NTOA(숫자)를 하게 되면 다시 IP주소 형태로 바꿔준다.  
저장은 정수, 출력은 IP주소로 할 수 있는 유용한 함수이다.  
## MySQL 전용 암호화
MySQL내의 user를 생성할때 썼던 PASSWORD 함수를 말한다.  
많은 사람들이 이 함수의 이름만 보고 실제 회원의 비밀번호를 이것으로 암호화하곤 했다.  
하지만 이는 절대 암호화 함수가 아니다. MySQL 내부에서 그냥 사용하는 것이고, 내부 암호화 알고리즘도 명시된것이 없다. 바뀔수도 있다는 것이다.  
실제로도 바뀌었다. MySQL 4.1 이전과 이후로 PASSWORD 함수를 입력하면 변경되는 값이 다름을 볼 수 있다.  
이로인해 DB 버전 업데이트를 했을 경우 사용자가 로그인하지 못하는 심각한 일이 발생할 수 있다.  
이럴 경우 기존의 PASSWORD함수를 OLD_PASSWORD로 바꿔서 임시로 막을 수 있다.  
변경된 PASSWORD 함수에서는 암호화시에 *를 앞에 붙인다. 이로인해 어플리케이션에서 구분할수도 있다. 하지만..  
기본적으로 이 함수를 절대 패스워드 암호화 하는데 쓰지 않도록 해야한다.  
## VALUES
INSERT INTO ON DUPLICATE KEY UPDATE  
인서트를 하다가 중복된 키가 있으면 업데이트 하는 문법이다.  
INSERT INTO test_table(cnt) 
    SELECT COUNT(*) FROM test_sub_table
ON DUPLICATE KEY
    V
## COUNT
출력된 레코드의 개수를 세거나, GROUP BY 함수와 같이 사용해 그룹화 된 요소들의 개수를 출력하는데 사용한다.  
COUNT(*) 라고 행 전체를 다 읽어오거나.. 그런 의미가 아니라,  
그냥 레코드 1개 자체를 의미한다.  
즉 COUNT(*), COUNT('A'), COUNT(1)은 아무 차이가 없다.  
하지만 COUNT(컬럼명) 으로 했을 경우 NULL인 값은 제외되므로 이부분은 조심해서 사용해야 한다.  

## 주석
```sql
# 비공식 주석
-- 싱글라인 주석
/* */ 멀티라인 주석
/*! */ 힌트
```