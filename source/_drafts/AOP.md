---
title: 'AOP'
tags:
---

> 트랜잭션 데코레이터 패턴  
위임과 부과기능 코드의 문제점  
다이나믹 프록시(리플렉션), 팩토리 빈  
프록시 팩토리 빈(어드바이스, 어드바이저, 포인트컷 등장)  
빈 후처리기를 통한 프록시 등록  
포인트컷 표현식(aspectJ)  
간단한 AOP 소개  
트랜잭션  


# 스프링 AOP
ProxyFactoryBean을 쓰더라도 설정의 중복은 막을 수 없었다!(target만 변경되는 설정이 중복됨)  
> 스프링은 대부분 변하지 않는 핵심적인 부분을 제외하고 유연하게 확장할 수 있도록 확장 포인트를 제공한다.  

이중에 스프링 컨테이너가 제공하는 확장 포인트 중 하나인 빈 후처리기를 통해 프록시 생성을 자동화할 수 있다.  
빈 후처리기를 빈으로 등록해놓기만 하면 스프링은 빈이 생성될 때 마다 후처리기에 가서 후처리 작업을 진행한다.  
스프링이 제공하는 `DefaultAdvisorAutoProxyCreator`를 빈으로 등록해놓으면 후처리 작업에서 프록시를 생성하는 것이 가능하다.  

```xml
<bean class="org.springframework...DefaultAdvisorAutoProxyCreator" />
```

이런식으로 후처리기를 빈으로 등록만 해놓으면 된다. 순서는 아래와 같다.   

1. 등록된 모든 어드바이저(`Advisor` 인터페이스 구현체) 빈을 찾는다.  
2. 어드바이저들의 포인트컷을 생성되는 모든 빈에 대해 적용해보며 대상을 선정한다.  
3. 선정 대상은 프록시 오브젝트를 생성하여 원래의 빈과 바꿔치기 한다.

이렇게 되면 지금의 빈과 의존관계에 있던 다른 빈 들은 이 프록시 오브젝트를 DI 받게 되며,  
원래의 빈은 프록시를 통해서만 접근 가능하게 된다.  
이제 자동으로 프록시가 생성될 것이니, `ProxyFactoryBean` 빈 설정들은 모두 삭제해도 상관없다.  

PointCut은 메서드 선별뿐만 아니라 오브젝트 선별까지 가능하다.  

## 포인트컷 표현식
`AspectJExpressionPointcuut` 클래스를 사용하면 된다.  

```
execution([접근제한자] 리턴타입 [클래스타입(패키지포함).]메서드이름(타입 | "..", ...) [throws 예외])
```

메서드의 풀 시그니처를 문자열로 비교한다고 보면 된다.  
`getMethod`를 통해 메서드 풀 시그니쳐를 뽑아보면 아래와 같다.  

```
public int springbook.learningtest.spring.pointcut.Target.minus(int,int) throws java.lang.RuntimeException
```

496페이지에서 포인트컷 적용 예제들을 살펴볼 수 있다.  
그리고 클래스타입은 이름 패턴이 아니라 타입 패턴이다. 자신이 상속하거나 구현한 클래스나 인터페이스의 이름이 패턴에 맞다면 포인트컷 대상으로 선정될 수 있다.  

# AOP란?
앞서 우리가 열심히 넣었던 트랜잭션 처리와 같은 작업들은 일반적인 방식으로 모듈화 하는 것이 매우 힘들다.  
기능을 부가할 대상과 긴밀하게 연결되어 있어야 하므로 다른 핵심기능과 같은 레벨에서 독립적으로 존재하는 것이 불가능하다.  
그래서 많은 개발자들이 열심히 연구한 결과가 이떄까지 보아왔던 데코레이터, 프록시, 후처리기 등등 인 것이다.  
개발자들의 이러한 노력 덕분에 현재는 이러한 부가기능을 독립적인 모듈로 분리하는 것이 가능해졌다.  

전문가들은 이러한 부가기능 모듈들을 일반적인 객체지향 패러다임과는 다르다고 보고, 이를 오브젝트가 아닌 애스팩트라는 이름으로 부르기 시작했다.  
애스펙트 = 어드바이스 + 포인트컷  
그리고 이러한 애스펙트를 모듈로 만드는 일련의 작업들을 애스펙트 지향 프로그램(AOP)라고 부른다.  

## 프록시 vs 바이트코드
AOP는 위와 같이 프록시를 이용한 방법 외에도 다른 방법이 있다.  
AspectJ라는 대표적인 기술인데, 컴파일된 클래스 파일 자체를 조작하거나 JVM에 로딩되는 시점을 가로채서 바이트코드를 조작하는 복잡한 방법을 사용한다.  
이는 프록시 방식보다 훨씬 복잡한 AOP가 가능하다 (오브젝트 생성, 필드 값 조회 조작 등. 기존 프록시는 메서드 호출로 한정됨)  
적용방법은 JVM 옵션 추가, 컴파일러 변경 등 다소 복잡다. 하지만 대체적으로 스프링 AOP(프록시)만으로도 충분한 기능들을 해낸다  

## AOP 용어
타깃 : 부가기능 적용 대상  
어드바이스 : 부가기능을 담은 모듈  
조인 포인트 : 어드바이스가 적용될 수 있는 위치. 스프링 AOP에서는 메서드 실행 단계뿐이다.  
포인트컷 : 조인포인트를 선별하는 작업 또는 그 기능을 정의한 모듈  
프록시 : 크라이언트와 타깃 사이에 투명하게 존재하며 부가기능을 제공하는 오브젝트  
어드바이저 : 포인트컷 + 어드바이스. AOP의 가장 기본 모듈.  
애스펙트 : AOP 기본 모듈. 어드바이저는 아주 단순한 애스펙트라고 부를 수 있다.  

## AOP 네임스페이스
스프링 AOP를 적용하려면 최소 4가지 빈을 등록해야 한다.  
> 자등 프록시 생성기, 어드바이스, 포인트컷, 어드바이저  

AOP 네임스페이스를 이용하면 간편하게 등록가능하고, 가독성과 간결성을 얻을 수 있다.  

```xml
<!-- 자동 프록시 생성기(후처리기) 등록 -->
<aop:config>
    <!-- 포인트컷과 어드바이저 생성 -->
    <aop:advisor advice-ref="transactionAdvice"
        pointcut="execution(* *..*ServiceImpl.update*(..))" />
</aop:config>
```

# 트랜잭션 속성
트랜잭션 경계설정을 할 때 사용했던 `DefaultTransactionDefinition` 클래스가 구현하고 있는 `TransactionDefinition`은  
트랜잭션 동작방식에 영향을 줄 수 있는 네가지 속성을 정의하고 있다.  
- 트랜잭션 전파 : 이미 실행중인 트랜잭션이 있을 때 어떻게 해야 할지(PROPAGATION_REQUIRED, PROPAGATION_REQUIRES_NEW, PROPAGATION_NOT_SUPPORTED)  
- 격리수준 : 다른 트랜잭션에 영향을 주지 않게 하는 정도  
- 제한시간 : 초단위 설정 가능. 트랜잭션이 처음 시작할때만 적용된다.  
- 읽기 전용 : 트랜잭션 내에서 데이터 조작 시도를 막아준다. 트랜잭션이 처음 시작할때만 적용된다.  

트랜잭션은 첫번째 트랜잭션의 속성을 따라(?) 간다.  
제한시간이나 읽기전용의 경우 첫번째 트랜잭션으로 시작된 것이 아니면 무용지물이다.  
근데 이에 반해 만약 첫번째로 시작된 경우 그 뒤에 실행하는 모든 트랜잭션 메서드들도 읽기전용에 시간제한을 가지게 됨을 유의하자!  

## TransactionInterceptor
스프링에서 제공하는 트랜잭션 경계설정 어드바이스.  
PlatformTransactionManager와 Properties 타입 속성을 가지고 있다.  
Properties 타입 속성은 트랜잭션 속성을 지정할 수 있는 부분이다.  
메서드 이름 패턴을 이용해 각각 지정 가능하다.  

```xml
<bean id="transactionAdvice" class="org..TransactionInterceptor">
    <property name="transactionManager" ref="transcationManger" />
    <property name="transactionAttributes">
        <prop key="get*">PROPAGATION_REQUIRED, readOnly, timeout_30</prop>
        <prop key="upgrade*">PROPAGATION_REQUIRES_NEW, ISOLATION_SERIALIZABLE</prop>
        <prop key="*">PROPAGATION_REQUIRED</prop>
    </property>
</bean>
```

보다시피 메서드 패턴에 의해 문자열로 트랜잭션 속성을 지정한다.  
지정할 수 있는 속성은 아래와 같다.  

```
PROPAGATION_NAME, ISOLATION_NAME, readOnly, timeout_NNNN, -Exception1, +Exception2
```

`PROPAGATION_NAME`만 빼고 전부 생략 가능하다.  
`-Exception1`은 체크예외중에 롤백할 예외를 지정하는것이고, `+Exception2`는 런타임예외중에 롤백 안할 예외를 지정하는 것이다.  

## 네임스페이스
트랜잭션도 aop 처럼 네임스페이스를 제공한다.  

```xml
<tx:advice id="transactionAdvice" transaction-manager="transactionManager">
    <tx:attributes>
        <tx:method name="get*" propagation="REQUIRED" read-only="true" timeout="30" />
        <tx:method name="update*" propagation="REQUIRES_NEW" isolation="SERIALIZABLE" />
        <tx:method name="*" propagation="REQUIRED" />
    </tx:attributes>
</tx:advice>
```

## 포인트컷과 트랜잭션 속성 적용 전략
1. 일반적으로 트랜잭션을 적용할 타깃 클래스의 메서드는 모두 트랜잭션 적용 후보가 되는 것이 바람직하다.  
앞서 속성에 등록했듯이 add나 get의 경우에도 트랜잭션을 지정해주는 것이 좋다.  
add의 경우 다른 트랜잭션에 함께 들어갈 가능성이 높고, get의 경우 read-only 속성을 줌으로써 성능향상을 기대할 수 있기 때문이다.  

2. 너무 많은 트랜잭션 속성은 관리하기 힘들어질 뿐이다.  
기준이 되는 몇가지 속성을 정의하고 그에 따라 적절한 명명 규칙을 만들어 지키도록 하는게 좋다.  
공통 속성을 따르기 어려운 특별한 트랜잭션 속성이 필요한 경우 타깃 오브젝트에 대해 별도의 어드바이스와 포인트컷을 사용하는 것이 좋다.  

3. 프록시 방식 AOP는 같은 타깃 내의 메서드를 호출할 때는 적용되지 않는다.  
프록시 방식 AOP의 적용 과정을 생각해보면 왜 그런지 알 수 있다.  
클라이언트가 직접 트랜잭션 경계부분을 호출해야 어드바이스가 적용된 프록시 오브젝트가 호출된다. 타깃에서 직접 호출할 경우 프록시 오브젝트가 호출되지 않으므로 트랜잭션이 적용되지 않고, 잘못된 동작이 일어날 가능성이 커진다.  

# 트랜잭션 애노테이션
세밀하게 트랜잭션을 튜닝해야 하는 경우 위와 같은 패턴 방식의 트랜잭션 적용은 한계가 있다.  
스프링은 이를 위해 직접 타깃에 트랜잭션 속성정보를 가진 애노테이션을 지정하는 방법을 제공한다.  

## @Transactional
이 애노테이션을 직접 타깃의 타입레벨이나 메서드레벨에 지정해주면 된다!  
각각 트랜잭션 속성도 지정할 수 있다.  

이 방식이 적용되기 위해 먼저 포인트컷을 `TransactionAttributeSourcePointcut`으로 변경해줘야 한다.  
그리고 `<tx:attrivbutes>`를 통해 지정했던 메서드 패턴의 트랜잭션 속성대신 `AnnotationTransactionAttributeSource`를 사용함으로써 애노테이션으로 부터 직접 속성을 가져와 사용할 수 있다!  

위의 2가지 변경과정을 스프링에서는 더욱 간단한 네임스페이스로 제공해준다.  

```xml
<tx:annotation-driven>
```

이거 하나면 애노테이션 기반 트랜잭션을 적용하기 위한 준비가 끝난다!  

## @Transactional 적용 순서
1. 구현체 메서드
2. 구현체 타입
3. 인터페이스 메서드
4. 인터페이스 타입

의 순서로 트랜잭션을 적용한다.  
우선순위가 높을 수록 아래의 트랜잭션을 무시하니 주의하여야 한다.  
> 인터페이스 메서드 레벨에서 `@Transactional(readOnly=true)` 라고 지정하고  
구현 클래스 타입 레벨에서 `@Transactional` 이라고 지정할 경우  
인터페이스 메서드 레벨에 지정된 읽기 전용 속성은 무시되니 주의하자!  

# 트랜잭션 테스트
전파속성은 굉장히 유용하다.  
이 속성 때문에 코드가 중복되지 않고 어플리케이션을 작은 기능 단위로 쪼개서 만들 수 있다.  
하나의 트랜잭션 메서드(eventRegister)에서 다른 트랜잭션의 메서드(userAdd)가 필요하다고 해보자.  
전파속성이 있을 경우 그냥 해당 메서드에서 필요한 메서드를 호출하면 된다.  
하지만 없을 경우, 트랜잭션은 각각 독자적인 트랜잭션을 만들어버리기 때문에 각각 서로 영향을 미치지 않게 되고, 이는 잘못된 데이터를 만들어낼 수 있게 된다.  
그래서 해결책은 필요한 메서드(userAdd) 코드를 직접 eventRegister내에 써주는 방법 밖에 없는데.. 이러면 코드의 중복이 발생해서 나중에 관리하기 매우 힘들어진다.  
다행히 스프링은 트랜잭션 전파속성을 지원하니 문제될 것 없다.  

선언전 트랜잭션 : AOP를 이용해 코드 외부에서 트랜잭션을 설정하는 것  
프로그램에 의한 트랜잭션 : 메서드에서 직접 트랜잭션을 사용하는 것  

> 이토록 완벽한 트랜잭션 코드를 만들 수 있게 해준데는 AOP와 트랜잭션 동기화가 한몫했다.  

테스트 메서드에서 트랜잭션을 실행할 경우 각각 트랜잭션은 독립적으로 생성된다.  

```java
@Test
public void integrationTest(){
    userDao.deleteAll();

    userDao.add(users.get(0));
    userDao.add(users.get(1));
}
```

셋중에 하나가 오류가 나도 트랜잭션은 롤백되지 않는다. 각자 독립된 트랜잭션이라 하나의 메서드가 끝나면 바로 적용되기 떄문이다.  

여기서 트랜잭션 동기화가 아주 중요하게 작용한다.  
트랜잭션 동기화는 `@Transactional`에만 적용되는 것이 아니라 그냥 실행중인 트랜잭션이 있을 경우 가능한 것이다.  
`PlatformTrnasactionManager`로 트랜잭션을 실행시키고 위의 메서드를 이용하면 셋다 같은 트랜잭션으로 묶이게 된다.  
`userDao`는 `JdbcTemplate`를 사용하고 있고, 이는 실행중인 트랜잭션이 있을 경우 자동으로 참여하는 REQUIRED의 속성을 가지기 때문이다(개념은 조금 다르다고 함).  
꼭 `@Transactional`이어만 서로 속성이 전파되는 것이 아니다!  

## 롤백 테스트
테스트시에는 항상 마지막에 데이터가 롤백되도록 해야한다.  
테스트는 각각 독립적인 단위로 진행되어야 하는데, 현재처럼 데이터베이스에 의존관계를 가지고 있을 경우, 게다가 데이터베이스에서 테스트의 데이터를 계속해서 바꾸는 경우 각각의 테스트는 절대 독립적으로 실행된다고 할 수 없다.  
각 테스트에서 변경하는 데이터가 다음 테스트에 영향을 미치기 떄문이다.  
이래서 테스트는 마지막에 자동으로 롤백하는 롤백테스트로 꼭 작성되어야 한다.  
테스트에서도 트랜잭션을 제어할 수 있어 얻는 가장 큰 장점이 이 롤백 테스트이다. 
초기화 스크립트 같은것을 통해 디비는 항상 초기화 값을 가지게 하고, 필요한 값은 자기가 보충해서 사용하도록 한다.  
그리고 롤백시켜 다른 테스트에 영향이 가지 않게 해줘야 한다.  
이는 매우 유용하게 사용된단다..   

## 테스트 트랜잭션 어노테이션
1. @Transactional  
테스트에서도 쓸 수 있다.  
트랜잭션을 시작시켜 준다. 클래스레벨, 메서드레벨 둘 다 가능하다.  
속성도 지정 가능하다.  
2. @Rollback  
테스트에서 `@Transactional`은 기본적으로 마지막에 항상 롤백되도록 설정되어 있다.  
`@Rollback`은 그러한 테스트에서 마지막에 롤백을 하지 않도록 해주는 애노테이션이다.  
테스트 메서드 위에 `@Rollback(false)` 이라고 써주면 된다.  
기본적으로 메서드 레벨에서만 지원한다.  
3. @TransacationConfiguration  
트랜잭션 관련 속성을 클래스 레벨에서 할 수 있다.  
`@TransactionConfiguration(defaultRollback=false)`  
스프링 개발자들은 기본적으로 일반 테스트와 롤백 테스트를 구분하기를 권장한다.  