# 개인적..
- 단순 반복하는 연습은 실력을 향상 시켜주지 않는다  
    - 이빨닦는 것을 생각해보라  
- 의식적인 연습을 해야한다  
    - 얼마나 의식적으로 연습했느냐에 따라 실력차이가 엄청나게 날 수 있다  
- 익숙한 곳(컴포트존)에서만 연습을 하면 실력이 늘지 않는다  
- 성장을 위해서는 당연히 고통이 수반되어야 한다  

팀원들에게 도움을 요청해서 짝 프로그래밍도 해보면 좋다  

변화를 원한다면, 내가 바꿀수 있는 범위에서 변화를 만들다가 변화를 확장해나가야 한다  

처음에 잘 모를때는 그냥 원칙대로 한다  
그러다 그 원칙을 내가 깰 수 있을때가 생긴다  
그떄가 내가 성장하는 순간이다  

일단 나부터 변화해야 한다  
내가 할수있는 부분은 TDD와 리팩토링을 시도해본다  
한번에 너무 많은 것이 아니라 작은것 하나만 시작해서, 익숙해질때까지 집중해본다  

작은 성공을 경험하기 위해선 시간이 많이 걸린다  
조급함을 버려야 한다  

변화를 만들다가 실패해도 괜찮다. 가장 크게 성장한 것은 내 자신이기 때문이다  
변화를 시도하는것 만으로도 자신감과 용기를 가질 수 있고, 이는 근육처럼 성장해나간다  

# 객체지향, 리팩토링
클린코드를 할 때 처음에는 정량적인 기준으로 하는것이 좋다  
- else 안쓰기 등등  

오픈소스 같은곳에 PR 보낼때의 기본적인 룰  
- 프로젝트를 folk 한다  
- 원본 프로젝트를 remote에 추가한다  
    - e.g. `git remote add upstream https://github.io/username/project-name.git`  
- 브랜치를 추가로 만들어서 작업한다  
    - 해당 브랜치가 계속 변경될 수 있기 때문이다  
        - e.g. folk한뒤 master에서 작업중이었는데 remote 프로젝트의 master가 업데이트 되었을 경우 conflict가 날 수 있다  
        - 굳이 수행하지는 않아도 된다  
- 작업이 끝나면 추가로 만든 브랜치를 remote 브랜치 대상으로 PR을 생성한다  
    - local/fix-something -> upstream/master 로 PR 생성  
- PR이 반영되면 원본 브랜치를 로컬 브랜치로 rebase 한다  
    - `git rebase master upstream/master`  
- 대체적으로 조금 큰 프로젝트의 경우 how to contribute가 다 있으니 그걸 참조하면 된다  

변수 이름에 자료구조는 사용하지 않는것이 좋다  
- carList 라고 짓는것은 List 자료구조를 암묵적으로 의미한다  
- set으로 바뀔수도 있다  
- 그러므로 ~~~s를 쓰는것이 좋다  

중복되는 값을 담는 변수 사용을 자제한다  

```java
List<Car> cars;

List<String> winner; 
// 또는
int topDistance;
```

cars 변수를 통해 충분히 구해올 수 있는 값들이기 때문이다  
게다가 매번 싱크를 맞춰줘야하는 불편함도 있다  

외부에서 계속 get 메서드로 값을 꺼낸뒤 로직을 수행하고 있다면 의심을 해봐야한다    
메세지를 객체한테 보내는식으로 계속 사고를 해야한다(Law of Demeter!)  
- 이러한것이 1차적인 목표가 되고, 그다음이 객체를 역할에 맞게 분리하는 것이다  

객체지향 설계는 도메인 설계에 가장 많은 시간을 투자해야한다  

원시값을 포장한 VO(DDD) 예제  
```java
class Position{
    private int position;

    Map<Integer, Position> positions = new HashMap<>();
    static{
        // 만약 position을 미리 생성해놓아서 성능을 높이고 싶다면  
    }

    public Position(int position){
        this.position = position;
    }

    public Position move(){
        return new Position(position + 1);
    }
}
```
필요할 경우 이런식으로 immutable한 VO 객체를 만들어서 어디서든 변경되지 않게 보장해주는 것이 더 좋다  
(매번 객체를 생성하지만, 성능 로스는 매우 미비하다)  

일급 컬렉션  
- 컬렉션을 래핑한 객체  
- 컬렉션을 조작하는 것도 해당 객체에 선언된 메서드를 통해서 하게된다  
- List<Integer> 같은 것을 감싸서 일급컬렉션인 Lotto 객체를 만들 수 있다  
- lotto의 match 메서드가 colleciton의 contains와 같은 맥락이 된다  

일급 컬렉션은 상속(inheritance)보다 조합(composition)을 사용해 구현하는 것이 좋다  
상속을 사용하면 컬렉션의 모든 기능을 다 사용하게 되는데, 이는  
- 클라이언트에 너무 많은 api가 노출되는 형태가 되고,  
- 일급 컬렉션의 목적(컬렉션의 범위를 제한하거나 등)을 일부 상실하게 되고,  
- 사이드 이펙트 발생의 여지도 있다(상속이므로 list의 add 같은 것을 직접 호출해버릴 수 있다)  

뷰에 도메인 엔티티를 직접 전달하지 않는 이유는 뷰에서 해당 도메인을 조작해버릴 수 있기 떄문이다(JPA OSIV의 경우 특히 위험)  
여기에 DTO를 사용할수도 있고, 도메인 객체의 접근 제어자를 사용할수도 있다  
- 꼭 DTO만 있는것은 아니다  
- private으로 선언해서 접근하지 못하게만 해도 되기 때문이다  

상태를 가지지 않는다면 클래스 메서드(static)을 적극 활용해보는 것이 좋다  

리팩토링을 극단적으로 연습해보는것이 좋다(연습은 뭐든 극단적으로 해보는 것이 좋다)  
- 메서드를 작은 단위로 쪼개는 연습을 많이 해보면 코드가 읽기 쉬워진다(추상화 된 메서드명만 보고 판단 가능)  
- 앞으로 나가서 클래스 분리까지 쉽게 가능해진다  
- 이런식으로 객체지향 설계의 힌트를 많이 얻을 수 있고, 함수형 프로그래밍의 힌트까지도 얻을 수 있다  

리팩토링이나 클린코드는 매일매일 습관처럼 해야한다  
운동하는것이 중요한것은 아는데 매일매일 운동하는 것이 힘든것처럼, 클린코드나 리팩토링을 매일매일 하기가 힘든 현실이다  

클린코드를 만드는 이유는 생산성을 늘리기 위함이 아니라, 생산성을 일정하게 유지하기 위함이다  
클린코드가 아니면 생산성이 떨어지기 때문이다  

생산성이 0에 수렴할때 우리는 원대한 재설계의 꿈을 꾼다  
기존 코드를 클린코드로 구현하지 못한 우리는 새로 만들어봤자 클린코드로 구현할수 없다  
또 하나의 레거시를 만드는 꼴이 된다  
새로운 것을 만들 생각보다는 기존의 레거시 코드를 리팩토링하는 연습을 많이 하는것이 좋다  
계속 새롭게 개발하려 하지말고 기존 코드를 리팩토링 하는 연습을 해야한다  
(레거시 코드에 테스트 추가해서 리팩토링 하는것은 난이도가 거의 최상급이다)  

레거시 코드를 리팩토링 하는것이 새롭게 만드는것보다 훨씬 어려운 일이다  
새롭게 뭔가를 만드는 능력보다 리팩토링하는 능력이 더 높고 중요하다  

그러나 또 너무 강력한 레거시는 리팩토링 하기가 힘들다  
리팩토링이 너무 힘들면, 아까워도 그냥 버리고 처음부터 다시 개발하라  
그러면 뭔가 다른 인사이트를 얻을 수 있다  

객체나 메서드를 작성하면서 애매한 상황들(이름을 짓거나, 역할을 명시하거나..)이 발생하면 의심해봐야한다.  
왜 이런 상황이 생겼을까?  

한 객체를 잘 만들고 객체의 역할을 보장시키면,  
외부에서 이런식의 신뢰할 수 있는 객체를 wrapping해서 또다른 객체를 만들 수 있다  
LottoNumber를 List로 가지는 Lotto 객체는 숫자가 1~45 사이가 아닐것이라는 부분을 걱정하지 않아도 되고, 신경조차 쓸필요 없게된다  
만약 LottoNumber를 감싸지 않았다면 Lotto가 1~45 숫자 범위까지 검증해야 했을 것이다  

처음부터 메서드가 한가지 일만 하게 만드는 것은 어렵다  
그래서 정량적인 기준(indent를 1번만 쓴다 등)을 가지고 연습하는 것이다  

메서드 인자를 3개를 넘기지 마라  

리팩토링은 시간날때마다 계속해야하는데, 그러면 기존 코드에 영향을 미치지않고 리팩토링하는 과정이 필요하다  
만약 리팩토링을 하고있었는데(시간이 꽤나 오래걸리는), 급하게 뭔가를 수정해야한다면 이를 전부 스테이시에 넣거나, 롤백하는 등의 방법을 택해야한다  
그러므로 리팩토링에는 과도기적인 단계가 필요하다  
예를들면 메서드를 중복해서 만든다 e.g. doSomething2()  
그리고 이 메서드를 사용하는 함수들을 한번에 점진적으로 doSomething2()로 바꾼다  
이 후 doSomething() 메서드를 삭제한다  
이런식으로 점진적으로 리팩토링해야한다  

외부에서 객체의 상태를 변경할 수 있게 만드는 setter는 특수한 상황이 아닌 이상 지양해야 한다  

자료구조를 잘 쓰면 복잡하게 처리하는 부분들을 깔끔하게 처리할 수 있다  

객체를 계속 생성하는 것이, 메서드를 분리하는것이, 메서드가 재사용되는 것이 성능 로스를 일으킬 것이라고 걱정할 수 있지만, 이는 아주 미비하다  
오히려 객체나 메서드를 잘 분리해서 얻는 이점이 훨씬 크다  

매번 새로운걸 만드는 것보단, 같은 것을 다른 관점/방식으로 구현하다보면 많은 인사이트들을 얻을 수 있다  

public constructor 대신 static factory method + private constructor 를 사용하는 것도 좋은 방법이다  
생성자는 이름을 가질 수 없기때문에, 무엇을 의미하는지 알기 힘들기 떄문이다  

상속(is-a)보단 조합(has-a) 관계를 사용하는 것이 훨씬 유연하다  
상속은 부모가 변하면 자식도 영향을 받기 때문이다  
구현중에 상속과 조합중 무엇을 선택해야될지 고민된다면, 조합을 사용하는 것이 좋다  

enum은 static 이다. 그러므로 어플리케이션 초기에 한번만 생성된다.  
이말인 즉 값을 변경하면 다른곳에 전부 영향을 미치므로, 값을 절대 변경해서는 안된다  
같은 인스턴스이므로 == 로 비교가능하다.  

enum에도 디미터의 법칙을 적용시켜야 한다  
```java
Rank.FIFTH.getWinningMoney() * 3; // bad
Rank.FIFTH.getWinningMoney(3); // good
```

기존에 만든 클래스에 조합을 사용하여 기능을 확장할 수 있다(물론 상속도 사용 가능)  
> AutoLottoGenerator 클래스에 다른 클래스를 조합해서 수동 + 자동이 가능한 DefaultLottoGenerator 클래스 생성  

# 테스트, TDD
클래스명 + Test를 붙이는게 클래스 테스트의 기본적인 convention  

junit class test를 할때 테스트 메서드들의 순서는 랜덤이고, 병렬로 실행된다  
> 테스트끼리 서로 의존이 없어야함을 의미함  

메서드가 테스트하기 힘들다는 것은 테스트가 주는 피드백이다  
(픽스쳐 세팅이 힘들다던지, 검증할 값이 애매하다던지 등등)  
그럴떈 어떻게 하면 테스트하기 편할까 생각해보고, 그에 맞춰 구조를 변경(개선)해보는 것이 좋다  

```java
car1.move();
car1.move();
car1.move();
car2.move();
car2.move();
```

이런식으로 픽스쳐를 세팅해서 우승자를 검증해야한다면, 구조에 뭔가 문제가 있는 것이다  
매번 이렇게 픽스쳐를 세팅해야한다면 짜증나서 아무도 테스트를 작성하지 않을것이다  

테스트를 위해 메서드나 생성자가 추가로 생기는 경우가 있다  
이럴 경우 해당 메서드가 정말 필요한지 체크해볼 필요는 있는데, 대부분 필요없지는 않은 메서드나 생성자이다  
그리고 해당 메서드를 추가하지 않음으로써 테스트가 힘들어지는것 보단 해당 메서드를 추가하는 것이 더 낫고, 더 중요하다  

테스트하기 쉬운 부분과 어려운 부분을 분리해야한다  

테스트가 무조건 많다고 좋은것은 아니다  
유지보수할 테스트가 늘어남을 의미하기 때문이다  
테스트의 양보다는 테스트 통과율이 더 중요하다  
- `1000개의 테스트 10개 실패 vs 200개의 테스트 0개 실패` 에서는 후자가 더 낫다  

테스트는 경계값에 대해서만 테스트하는 것이 좋다  

테스트의 인스턴스 변수는 모든 테스트에서 사용할 값들에 대해서만 선언하는 것이 좋다 
그 외에는 메서드의 로컬 변수를 사용하는 것이 좋다  
setUp()에서 생성하는 픽스쳐도 마찬가지이다  

exception 테스트는 하나의 부분만 테스트해야한다  
여러개의 exception을 작성해놓고 expected 해봤자, exception이 발생하면 아래의 코드들은 실행되지 않기 떄문이다  
이는 테스트를 통한 검증이 아니다  

TDD = TFD(Test First Development) + refactoring  
- 설계를 짧은 시간동안 자주 해야한다  
- 작은 부분을 설계하고 구현(+TDD)를 통해 개선하고, 또 작은 부분을 설계하고 구현을 통해 개선한다  
- 애자일에서 말하는 점진적 개발이라고 할 수 있다  
- 핵심은 잦은 리팩토링이다  

처음에는 모든 부분을 TDD로 하려는 욕심을 버리는 것이 좋다  
테스트하기 어려운 부분들이 있기 때문이다  
그러므로 처음에는 도메인 모델에만 집중해서 TDD 해보는 것이 좋다  

(?)설계한 부분에서 테스트 가능한 부분을 찾아내는 것이 중요하다  

`테스트 작성 -> 통과 -> 리팩토링` 의 싸이클을 계속 거쳐야 한다  

전체를 다 테스트하려고 하지말고, 특정 부분만 분리해서 테스트를 해보는게 좋을수 있다  

테스트 작성의 처음 스텝은 `어떤 풋이 들어갔을 때 어떤 아웃풋이 나온다` 이다  
이 input을 명확하게 잡아내는 것을 초반에 다들 어려워한다  

테스트를 기반으로 구조를 계속 리팩토링 하는 작업 또한 설계작업의 일부이다  
테스트 코드를 믿고 다양한 시도를 해봐야 설계 연습을 할 수 있다  

기능변경에 많은 테스트가 변경되면 의심해봐야한다  
- 테스트가 제대로 작성된것은 맞는지? 너무 deep하게 작성되어 있는것은 아닌지? 정말 거기서 테스트되어야 하는 것이 맞는지?  
- 객체끼리 너무 의존하고 있는것은 아닌지? 너무 많은 범위를 허용하고 있는것은 아닌지?  

TDD를 통해서 만들어진 완성체들을 계속 갖다쓰도록 한다  

기능을 나누고, 테스트를 작성하는 등 점진적으로 개발을 해야하는데 우리는 한번에 너무 많은것을 하려고하기 때문에 힘들다  

요구사항도 명세하지 않고, 객체도 어느정도 설계하지 않고 TDD를 하려고하니까 힘든 것이다  

인스턴스 메서드로 만드는 것보다 클래스 메서드(static)로 만드는게 테스트하기 더 수월하다  
하지만 이 클래스 메서드를 mocking 해야 할 상황이 온다면 조금 힘들어질 수 있다  
> 이럴때는 인스턴스 변수로 바꾸고 파라미터로 받게끔 하는 것이 좋다  

테스트를 처음에 작성하고 통과하고 끝이 아니라, 해당 테스트의 이름을 전체 만족할때까지 테스트를 계속 확장해나간다  

테스트 메서드는 이 테스트가 뭘 의도하는지를 잘 드러내는것이 중요하다. 소통에 좋은 영향을 미쳐야한다  
한국에서 일하고, 팀원들이 한국인이니 한국어로 테스트 이름을 작성하는 것이 좋겠다  

단위테스트 만드는 것 조차 익숙하지 않다면, TDD는 더 어렵다  

테스트가 가능한 부분을 계속 쪼개는 연습을 해야한다  

TDD를 하면 생각을 좀 덜해도 될수도 있다  
그냥 기대하는 값에 맞추기만 하면 되니까  

테스트 케이스에 없는 코드를 미리 구현하는 것은 TDD의 원칙에 벗어난다  

어떻게 하면 테스트할수 있을까? 어떻게 하면 TDD로 할 수 있을까?  
를 계속 생각하다보면 기존의 내 선입견이 깨지면서 더 나은, 다른 설계가 나오게 된다  
테스트를 하기위해 계속 메서드를 쪼개거나.. 하기 떄문이다  
TDD없이 그냥 설계하면 안나오던것이 TDD를 하다보면 나오게 된다!!  

TDD를 하려면 조급함이 없어야한다  

작은 단계로 진전해나가는 연습을 자주 해야한다  
큰 단계부터 시작한다면 작은 단계로 하는 법을 결코 알지 못한다  

# 실무에 적용하면 좋을 아주 중요한 개념들  
서비스 레이어는 상태를 가지지 않는 부분이라 로직을 가지면 안된다. 전부 도메인 모델로 옮겨야한다.  
서비스 레이어에서 로직을 구현한다는 것은 계속해서 getter를 써서 가져와서 무언가를 수행하게 되고, 이는 중복이 계속 생기게 됨을 의미한다   
객체지향적으로 프로그램이 한다는 것은 비즈니스 로직의 중복을 제거하는 것이다  

서비스 레이어에서 계속 도메인의 상태를 get으로 가져와서 로직을 수행하면 서비스 레이어가 매우 뚱뚱해지고, 객체지향과는 거리가 멀어진다(절차지향적으로 변한다)  
서비스 레이어는 기본적으로 다른 레이어와 dependency가 많은 레이어라 테스트하기가 힘든데, 여기 로직이 구현되어 있다면 이 로직을 테스트하기 힘들어지고, 결국 테스트를 점점 안하게 된다  
서비스 레이어를 테스트하는 것은 도메인 레이어를 테스트하는것 보다 최소 5배는 어렵다  
로직이 도메인 레이어 안으로 이동한다면 단위테스트가 굉장히 수월해진다  

mockito를 자주 사용해서 테스트를 구현하게된다는 것은 서비스 레이어에 로직이 많다는 것을 의미한다  

서비스에서 get 메서드로 무언가 가져와서 수행한다면, 의심해보는 것이 좋다(이건 아닌거같은뎨? 라고)  

서비스는 아래 정도의 역할을 수행하는 것이 맞다  
- 외부 인프라스트럭쳐와 상호작용(데이터베이스 등)  
- 도메인 객체에 메시지 보내기  
- 도메인에서 받은 메시지를 다른 도메인이나 서비스에 전달하기  
- 트랜잭션 바인딩  

테스트 우선순위  
1. 도메인 레벨 유닛 테스트  
2. Acceptance Test  
3. 서비스  
4. 레파지토리(여기부터는 굳이..)  
    - mybatis를 쓰는 경우 조금은 다를 수 있다(쿼리에 로직이 있는 경우)  
> 1번과 2번은 둘 다 중요하다  
> 이 2개만 해놔도 충분한 안전장치가 된다(도메인에 대부분의 로직이 있기 떄문이다)  
> **이런식으로 방식을 전환하면 훨씬 빠르게 개발할 수 있다**  
> 하지만 Acceptance Test 작성은 학습 비용이 매우 높다  

틀에 같힌 개발을 할 필요는 없다  
엔티티에 맞춰 서비스, 컨트롤러를 꼭 생성해야 하는가?  
Question, Answer 엔티티는 서로 밀접한 관계이므로, 묶어서 QnAService, QnAController 작성하는 것이 좋다  
어쩌피 중요한 로직들은 도메인에서 테스트된다  
서비스의 역할을 다시 생각해보면, 타당한 얘기이다  

꼭 service는 service package, repository는 repository package에 넣을 필요도 없다  
qna package에 qnaService, repository, 도메인들을 묶어놓을 수도 있다  
> 이때 각 패키지간 bidirection이 생기지 않도록 주의해야 한다  
> answer package에서 user package의 클래스를 사용했다면, 반대의 상황은 일어나지 않아야 한다  
> 이게 DDD의 aggregate?  

엔티티도 일반적인 객체지향 프로그래밍 할 때 처럼 다 나눠야한다  
```
- Question 엔티티에서 title과 contents를 묶어서 QuestionBody 라는 클래스로 만듦  
- List<Answer>를 일급 컬렉션으로 만듦  
```
엔티티는 database mapper가 아니다  
ORM의 최대 장점은 이런식으로 설계된 클래스에 데이터베이스 매핑을 아주 간단하게 할 수 있다는 점이다  
ORM 뿐만 아니라 스프링도 마찬가지이다  
ORM과 스프링은 객체지향의 극장점을 최대한으로 끌어올리기 위해 나온 기술이다  

도메인 객체를 뚱뚱하게 하지 말고 객체를 계속 분리해서 위임하는 식으로 리팩토링을 계속 해야한다  
> 핵심적이고 끊임없이 리팩토링이 필요한 곳은 컨트롤러, 서비스 등등이 아니라 **도메인 객체**이다  
> 알다시피 도메인 로직은 단위테스트를 작성하기 수월하고, 단위 테스트가 많다면 전투적으로 리팩토링 할 수 있다  

객체지향적 설계와 리팩토링을 하다보면 코드상에서 성능과 조금 멀어지기도 하는데, 사실상 이를 서비스 레벨에서 보면 성능으로 손해보는 점이 거의 없는 수준이다  
코드는 전부 이렇게 짜고, 다른 쪽을 튜닝해서 성능을 개선하면 된다(db, 캐싱 등)  

JPA에서 update가 없는 것이 좀 더 객체지향적인 프로그래밍을 하는데 맞는 것이다  
실제로 생각해보면, 객체의 값을 update 했으면 그대로 변경된 것이기 때문이다  

유닛테스트보다 AcceptanceTest가 적게 작성하는 것이 맞다  
Acceptance Test는 테스트 케이스만큼 작성하는 것이 낭비다. 이는 Unit 테스트로 하면 된다  
클라이언트 입장에서 받을 response만 생각해보면 모든 경우에 수에 대해 Acceptance Test가 필요하지는 않다  
> 케이스가 4가지면 Acceptance Test는 2가지, 유닛테스트가 4개인 경우가 대부분 맞다  

Acceptance Test를 바라보는 관점을 바꿔야한다  
비즈니스 레벨로 바라보고 테스트를 작성해야 한다  
비즈니스 레벨에서 체크되어야 하는 부분!  
검증 또한 정해진건 없는 것 같다  
repository에서 조회해서 체크해도 되고.. 근데 더 좋은 방법이 있을 것 같은데..  

DTO는 외부에 드러나는 객체이고, 이는 변화할 가능성이 매우 높으므로 DTO로 분리하는 것이 좋다  
DTO에 대한 거부감이 드는 이유는 도메인을 객체지향적으로 설계하지 않았기 때문이다  

