# 개인적..
- 단순 반복하는 연습은 실력을 향상 시켜주지 않는다  
    - 이빨닦는 것을 생각해보라  
- 의식적인 연습을 해야한다  
    - 얼마나 의식적으로 연습했느냐에 따라 실력차이가 엄청나게 날 수 있다  
- 익숙한 곳(컴포트존)에서만 연습을 하면 실력이 늘지 않는다  
- 성장을 위해서는 당연히 고통이 수반되어야 한다  

팀원들에게 도움을 요청해서 짝 프로그래밍도 해보면 좋다  

변화를 원한다면, 내가 바꿀수 있는 범위에서 변화를 만들다가 변화를 확장해나가야 한다  

처음에 잘 모를때는 그냥 원칙대로 한다  
그러다 그 원칙을 내가 깰 수 있을때가 생긴다  
그떄가 내가 성장하는 순간이다  

일단 나부터 변화해야 한다  
내가 할수있는 부분은 TDD와 리팩토링을 시도해본다  
한번에 너무 많은 것이 아니라 작은것 하나만 시작해서, 익숙해질때까지 집중해본다  

작은 성공을 경험하기 위해선 시간이 많이 걸린다  
조급함을 버려야 한다  

변화를 만들다가 실패해도 괜찮다. 가장 크게 성장한 것은 내 자신이기 때문이다  
변화를 시도하는것 만으로도 자신감과 용기를 가질 수 있고, 이는 근육처럼 성장해나간다  

요구사항 분석은 기본중의 기본이다  
내가 뭘 만들지에 대해서는 확실히 하고 가야한다  
다 만들었는데 잘못 이해했거나 잘못 만든거면 그것만큼 낭패가 없다  
그리고 내가 생각하는것이 맞는 방향인지 커뮤니케이션을 통해 주기적으로 확인하는 것도 필요하다  

큰 그림을 놓치지 않게 주의하자  
- 내가 무엇을 학습하려고 하는지
- 내가 무엇을 만들어야 하는지
- 등등
- UI 만드는데 시간을 너무 쏟을때 깨달은 부분이다

개발 순서  
1. DDD에서 도메인 모델 도출하는 과정을 사용하여 요구사항을 명확하게 분석하고, 큰 도메인별로 태스크를 작성한다
2. 메인 태스크 아래 서브 태스크들을 등록한다
3. 서브 태스크들에 대해 생각나는 테스트들을 작성해나가면서 TDD로 태스크들을 처리해나간다
    - 중간중간 생각나거나 발견된 태스크들이 있다면 태스크 레벨을 체크하고 추가한다

내가 뭔가 대단한, 남들과는 다른 뭔가를 만들수 있다는 생각을 버리자  
우리는 가끔씩 이상한 것에 집착하려는 경향이 있다  

오픈소스 같은곳에 PR 보낼때의 기본적인 룰  
- 프로젝트를 folk 하고 clone한다
- 브랜치를 추가로 만들어서 작업한다  
    - 해당 브랜치가 계속 변경될 수 있기 때문이다  
        - e.g. folk한뒤 master에서 작업중이었는데 remote 프로젝트의 master가 업데이트 되었을 경우 conflict가 날 수 있다  
        - 굳이 수행하지는 않아도 된다  
- 원본 프로젝트를 remote에 추가한다  
    - e.g. `git remote add upstream https://github.io/username/project-name.git`
- 작업이 끝나면 추가로 만든 브랜치를 remote 브랜치 대상으로 PR을 생성한다  
    - local/fix-something -> upstream/master 로 PR 생성  
- PR이 반영되면 원본 브랜치를 로컬 브랜치로 rebase 한다  
    - `git rebase master upstream/master`  
- 대체적으로 조금 큰 프로젝트의 경우 how to contribute가 다 있으니 그걸 참조하면 된다(CONTRIBUTING.md)  

git outdated?
commit에 comment 남긴것들이 남아있으면 그대로 보여지고, 삭제되거나 변경되었으면 outdated로 표시?  

# 객체지향, 리팩토링
클린코드를 할 때 처음에는 정량적인 기준으로 하는것이 좋다  
- else 안쓰기 등등  

처음부터 메서드가 한가지 일만 하게 만드는 것은 어렵다  
그래서 정량적인 기준(indent를 1번만 쓴다 등)을 가지고 연습하는 것이다  

변수 이름에 자료구조는 사용하지 않는것이 좋다  
- carList 라고 짓는것은 List 자료구조를 암묵적으로 의미한다  
- set으로 바뀔수도 있다  
- 그러므로 ~~~s를 쓰는것이 좋다  

중복되는 값을 담는 변수 사용을 자제한다  
```java
List<Car> cars;

List<String> winner; 
// 또는
int topDistance;
```
cars 변수를 통해 충분히 구해올 수 있는 값들이기 때문이다  
게다가 매번 싱크를 맞춰줘야하는 불편함도 있다  

외부에서 계속 get 메서드로 값을 꺼낸뒤 로직을 수행하고 있다면 의심을 해봐야한다    
메세지를 객체한테 보내는식으로 계속 사고를 해야한다(Law of Demeter!)  
- 이러한것이 1차적인 목표가 되고, 그다음이 객체를 역할에 맞게 분리하는 것이다  

객체지향 설계는 도메인 설계에 가장 많은 시간을 투자해야한다  

원시값을 포장한 VO(DDD) 예제  
```java
class Position{
    private int position;

    Map<Integer, Position> positions = new HashMap<>();
    static{
        // 만약 position을 미리 생성해놓아서 성능을 높이고 싶다면  
    }

    public Position(int position){
        this.position = position;
    }

    public Position move(){
        return new Position(position + 1);
    }
}
```
필요할 경우 이런식으로 immutable한 VO 객체를 만들어서 어디서든 변경되지 않게 보장해주는 것이 더 좋다  
(매번 객체를 생성하지만, 성능 로스는 매우 미비하다)  
static Map을 써서 VO 재사용성을 높일 수 있다  

일급 컬렉션  
- 컬렉션을 래핑한 객체  
- 컬렉션을 조작하는 것도 해당 객체에 선언된 메서드를 통해서 하게된다  
- List<Integer> 같은 것을 감싸서 일급컬렉션인 Lotto 객체를 만들 수 있다  
- lotto의 match 메서드가 colleciton의 contains와 같은 맥락이 된다  
- Map도 일급 컬렉션으로 사용할 수 있다(Map도 컬렉션이다. Collection 구현체가 아닐 뿐)  

일급 컬렉션은 상속(inheritance)보다 조합(composition)을 사용해 구현하는 것이 좋다  
상속을 사용하면 컬렉션의 모든 기능을 다 사용하게 되는데, 이는  
- 클라이언트에 너무 많은 api가 노출되는 형태가 되고,  
- 일급 컬렉션의 목적(컬렉션의 범위를 제한하거나 등)을 일부 상실하게 되고,  
- 사이드 이펙트 발생의 여지도 있다(상속이므로 list의 add 같은 것을 직접 호출해버릴 수 있다)  

Value Object, 일급 객체를 적극 활용한다  

상속(is-a)보단 조합(has-a) 관계를 사용하는 것이 훨씬 유연하다  
상속은 부모가 변하면 자식도 영향을 받기 때문이다  
구현중에 상속과 조합중 무엇을 선택해야될지 고민된다면, 조합을 사용하는 것이 좋다  

기존에 만든 클래스에 조합을 사용하여 기능을 확장할 수 있다(물론 상속도 사용 가능)  
> AutoLottoGenerator 클래스에 다른 클래스를 조합해서 수동 + 자동이 가능한 DefaultLottoGenerator 클래스 생성  

뷰에 도메인 엔티티를 직접 전달하지 않는 이유는 뷰에서 해당 도메인을 조작해버릴 수 있기 떄문이다(JPA OSIV의 경우 특히 위험)  
여기에 DTO를 사용할수도 있고, 도메인 객체의 접근 제어자를 사용할수도 있다  
- 꼭 DTO만 있는것은 아니다  
- private으로 선언해서 접근하지 못하게만 해도 되기 때문이다  

상태를 가지지 않는다면 클래스 메서드(static)을 적극 활용해보는 것이 좋다  

리팩토링을 극단적으로 연습해보는것이 좋다(연습은 뭐든 극단적으로 해보는 것이 좋다)  
- 메서드를 작은 단위로 쪼개는 연습을 많이 해보면 코드가 읽기 쉬워진다(추상화 된 메서드명만 보고 판단 가능)  
- 앞으로 나가서 클래스 분리까지 쉽게 가능해진다  
- 이런식으로 객체지향 설계의 힌트를 많이 얻을 수 있고, 함수형 프로그래밍의 힌트까지도 얻을 수 있다  

리팩토링이나 클린코드는 매일매일 습관처럼 해야한다  
운동하는것이 중요한것은 아는데 매일매일 운동하는 것이 힘든것처럼, 클린코드나 리팩토링을 매일매일 하기가 힘든 현실이다  

클린코드를 만드는 이유는 생산성을 늘리기 위함이 아니라, 생산성을 일정하게 유지하기 위함이다  
클린코드가 아니면 생산성이 떨어지기 때문이다  

생산성이 0에 수렴할때 우리는 원대한 재설계의 꿈을 꾼다  
기존 코드를 클린코드로 구현하지 못한 우리는 새로 만들어봤자 클린코드로 구현할수 없다  
또 하나의 레거시를 만드는 꼴이 된다  
새로운 것을 만들 생각보다는 기존의 레거시 코드를 리팩토링하는 연습을 많이 하는것이 좋다  
계속 새롭게 개발하려 하지말고 기존 코드를 리팩토링 하는 연습을 해야한다  
(레거시 코드에 테스트 추가해서 리팩토링 하는것은 난이도가 거의 최상급이다)  

레거시 코드를 리팩토링 하는것이 새롭게 만드는것보다 훨씬 어려운 일이다  
새롭게 뭔가를 만드는 능력보다 리팩토링하는 능력이 더 높고 중요하다  

그러나 또 너무 강력한 레거시는 리팩토링 하기가 힘들다  
리팩토링이 너무 힘들면, 아까워도 그냥 버리고 처음부터 다시 개발하라  
그러면 뭔가 다른 인사이트를 얻을 수 있다  

리팩토링은 시간날때마다 계속해야하는데, 그러면 기존 코드에 영향을 미치지않고 리팩토링하는 과정이 필요하다  
만약 리팩토링을 하고있었는데(시간이 꽤나 오래걸리는), 급하게 뭔가를 수정해야한다면 이를 전부 스테이시에 넣거나, 롤백하는 등의 방법을 택해야한다  
그러므로 리팩토링에는 과도기적인 단계가 필요하다  
예를들면 메서드를 중복해서 만든다 e.g. doSomething2()  
그리고 이 메서드를 사용하는 함수들을 한번에 점진적으로 doSomething2()로 바꾼다  
이 후 doSomething() 메서드를 삭제한다  
이런식으로 점진적으로 리팩토링해야한다  
이런식으로 리팩토링은 중복, 위임 단계를 거쳐가면서 점진적으로 해야한다. 한번에 너무 크게하면 돌이킬수도 없고.. 위험하다  
(@Deprecated 같은것도 좀 써보고)  

객체를 계속 생성하는 것이, 메서드를 분리하는것이, 메서드가 재사용되는 것이 성능 로스를 일으킬 것이라고 걱정할 수 있지만, 이는 아주 미비하다  
오히려 객체나 메서드를 잘 분리해서 얻는 이점이 훨씬 크다  

객체나 메서드를 작성하면서 애매한 상황들(이름을 짓거나, 역할을 명시하거나..)이 발생하면 의심해봐야한다.  
왜 이런 상황이 생겼을까?  

한 객체를 잘 만들고 객체의 역할을 보장시키면,  
이런 신뢰할 수 있는 객체를 wrapping한 고수준의 객체를 얻을 수 있다  
LottoNumber를 List로 가지는 Lotto 객체는 숫자가 1~45 사이가 아닐것이라는 부분을 걱정하지 않아도 되고, 신경조차 쓸필요 없게된다  
만약 LottoNumber를 감싸지 않았다면 Lotto가 1~45 숫자 범위까지 검증해야 했을 것이다  

메서드 인자를 3개를 넘기지 마라  

외부에서 객체의 상태를 변경할 수 있게 만드는 setter는 특수한 상황이 아닌 이상 지양해야 한다  

자료구조를 잘 쓰면 복잡하게 처리하는 부분들을 깔끔하게 처리할 수 있다  

매번 새로운걸 만드는 것보단, 같은 것을 다른 관점/방식으로 구현하다보면 많은 인사이트들을 얻을 수 있다  

public constructor 대신 static factory method + private constructor 를 사용하는 것도 좋은 방법이다  
생성자는 이름을 가질 수 없기때문에, 무엇을 의미하는지 알기 힘들기 떄문이다  

enum은 static 이다. 그러므로 어플리케이션 초기에 한번만 생성된다.  
이말인 즉 값을 변경하면 다른곳에 전부 영향을 미치므로, 값을 절대 변경해서는 안된다  
같은 인스턴스이므로 == 로 비교가능하다.  

enum에도 디미터의 법칙을 적용시켜야 한다  
```java
Rank.FIFTH.getWinningMoney() * 3; // bad
Rank.FIFTH.getWinningMoney(3); // good
```

출력 + 입력을 하는 부분을 굳이 따로 나눌 필요없다. 별로 얻는 이득도 없고, 어렵기만 해진다.  

중복된 정보, 비슷한 정보를 가진 클래스가 있는지 찾아보고, 있다면 하나만 써보는것도 좋다. 굳이 앞서서 분리할 필요있을까?  

객체를 너무 실생활에 맞춰 디자인하려고 하지말자  

객체지향 프로그램을 하면 할수록 위임 코드가 많아지는 것이 당연하다  

객체지향에서 의존은 어쩌피 존재한다. OOP는 원래 객체간 메시지 전달을 하는 방식으로 진행되는 프로그래밍 방식이다.  
하지만 클래스에서 특정 클래스를 직접 의존하면, 대상에 대해 더 많이 가정해야하는 강한 결합이 형성된다  
그러므로 의존의 대상이 특정 클래스가 아니라 `행위`가 되어야한다   
행위에 대해서만 가정을 세움으로써 의존객체간의 결합도를 낮출 수 있다  
그 행위를 정의하는 방법으로 인터페이스를 사용할 수 있다  
그리고 그 행위를 구현한 구현체는 외부에서 생성해서 주입해주게끔 한다  
외부에서 계속 구현체를 생성해서 넣어주는게 귀찮고 불편하므로, 이런걸 제공해주는 프레임워크를 사용하면 된다 == 스프링  
스프링의 최대 장점은 DI이다  
> 의존을 없애서 객체를 pure하게 만들고, 모든 의존을 관장하는 3자 객체를 자꾸 만들려고 시도했었다  
> 이는 올바른 방법이 아니며, 이로 인해 복잡한 구조가 탄생하게 된다  

메서드를 최소한의 단위로 유지하는 연습을 많이 한다. 그러면 클래스 분리도 얻을 수 있다.  

디미터의 법칙을 지키다보면 메서드가 제자리를 찾아가는 경험을 하게 된다  

너무 완벽하게 머리속으로 구현하고 코딩하려고 하지말고, 어느정도 구상이 그려지면 바로 코딩해보자  
> 전체적인 큰 그림이 아니라 작은부분에 대한 그림이라도, 일단 그것부터 코딩해보자. 피드백을 얻을 수 있다  
> **생각하는 시간이 너무 길어지면 짜증나고 집중력이 떨어진다!!**  
> 일단 하는 것이 중요하다  

private method가 꼭 젤 아래 있을 필요는 없는 것 같다.  
관련된 public 메서드 옆에 있어도 괜찮을 듯  

파라미터를 varargs로 받고 내부에서 List로 저장하는것도 괜찮은 것 같다.  
전달하는 쪽에서는 varargs가 편하고, 받는쪽은 List가 편할테니까?  

객체는 해당 객체만 봐도 알아보기 쉬워야한다. 다른 객체에서 뭔가를 해줘야 한다면, 코드로 명확히 드러나야 한다.  
문서로 표현되어야 할 룰이 있어서는 안된다  

추상화된 파라미터를 받아서 내부의 상태를 세팅하는 객체  
```java
public static Point valueOf(Integer idx, boolean movable) {
    if(idx < MIN_CREATABLE_POINT_NUMBER) {
        throw new IllegalArgumentException();
    }

    return new Point(idx, Direction.nextDirection(movable));
}
```
> 겉에서는 boolean을 받았지만 내부에서는 다른 값으로 변환된다  
> 객체는 mapper가 아니다. 이렇게 프로그래밍 해야한다.  

# 테스트, TDD
클래스명 + Test를 붙이는게 클래스 테스트의 기본적인 convention  

junit class test를 할때 테스트 메서드들의 순서는 랜덤이고, 병렬로 실행된다  
> 테스트끼리 서로 의존이 없어야함을 의미함  

메서드가 테스트하기 힘들다는 것은 테스트가 주는 피드백이다  
(픽스쳐 세팅이 힘들다던지, 검증할 값이 애매하다던지 등등)  
그럴떈 어떻게 하면 테스트하기 편할까 생각해보고, 그에 맞춰 구조를 변경(개선)해보는 것이 좋다  

```java
car1.move();
car1.move();
car1.move();
car2.move();
car2.move();
```
이런식으로 픽스쳐를 세팅해서 우승자를 검증해야한다면, 구조에 뭔가 문제가 있는 것이다  
매번 이렇게 픽스쳐를 세팅해야한다면 짜증나서 아무도 테스트를 작성하지 않을것이다  

테스트를 위해 메서드나 생성자가 추가로 생기는 경우가 있다  
이럴 경우 해당 메서드가 정말 필요한지 체크해볼 필요는 있는데, 대부분 필요없지는 않은 메서드나 생성자이다  
그리고 해당 메서드를 추가하지 않음으로써 테스트가 힘들어지는것 보단 해당 메서드를 추가하는 것이 더 낫고, 더 중요하다  

테스트하기 쉬운 부분과 어려운 부분을 분리해야한다  

테스트가 무조건 많다고 좋은것은 아니다  
유지보수할 테스트가 늘어남을 의미하기 때문이다  
테스트의 양보다는 테스트 통과율이 더 중요하다  
- `1000개의 테스트 10개 실패 vs 200개의 테스트 0개 실패` 에서는 후자가 더 낫다  

테스트는 경계값에 대해서만 테스트하는 것이 좋다  

테스트의 인스턴스 변수는 모든 테스트에서 사용할 값들에 대해서만 선언하는 것이 좋다 
그 외에는 메서드의 로컬 변수를 사용하는 것이 좋다  
setUp()에서 생성하는 픽스쳐도 마찬가지이다  

exception 테스트는 하나의 부분만 테스트해야한다  
여러개의 exception을 작성해놓고 expected 해봤자, exception이 발생하면 아래의 코드들은 실행되지 않기 떄문이다  
이는 테스트를 통한 검증이 아니다  

TDD = TFD(Test First Development) + refactoring  
- 설계를 짧은 시간동안 자주 해야한다  
- 작은 부분을 설계하고 구현(+TDD)를 통해 개선하고, 또 작은 부분을 설계하고 구현을 통해 개선한다  
- 애자일에서 말하는 점진적 개발이라고 할 수 있다  
- 핵심은 잦은 리팩토링이다  

처음에는 모든 부분을 TDD로 하려는 욕심을 버리는 것이 좋다  
테스트하기 어려운 부분들이 있기 때문이다  
그러므로 처음에는 도메인 모델에만 집중해서 TDD 해보는 것이 좋다  

(?)설계한 부분에서 테스트 가능한 부분을 찾아내는 것이 중요하다  

`테스트 작성 -> 통과 -> 리팩토링` 의 싸이클을 계속 거쳐야 한다  

전체를 다 테스트하려고 하지말고, 특정 부분만 분리해서 테스트를 해보는게 좋을수 있다  

테스트 작성의 처음 스텝은 `어떤 인풋이 들어갔을 때 어떤 아웃풋이 나온다` 이다  
이 input을 명확하게 잡아내는 것을 초반에 다들 어려워한다  

테스트를 기반으로 구조를 계속 리팩토링 하는 작업 또한 설계작업의 일부이다  
테스트 코드를 믿고 다양한 시도를 해봐야 설계 연습을 할 수 있다  

기능변경에 많은 테스트가 변경되면 의심해봐야한다  
- 테스트가 제대로 작성된것은 맞는지? 너무 deep하게 작성되어 있는것은 아닌지? 정말 거기서 테스트되어야 하는 것이 맞는지?  
- 객체끼리 너무 의존하고 있는것은 아닌지? 너무 많은 범위를 허용하고 있는것은 아닌지?  

TDD를 통해서 만들어진 완성체들을 계속 갖다쓰도록 한다  

기능을 나누고, 테스트를 작성하는 등 점진적으로 개발을 해야하는데 우리는 한번에 너무 많은것을 하려고하기 때문에 힘들다  

요구사항도 명세하지 않고, 객체도 어느정도 설계하지 않고 TDD를 하려고하니까 힘든 것이다  

인스턴스 메서드로 만드는 것보다 클래스 메서드(static)로 만드는게 테스트하기 더 수월하다  
하지만 이 클래스 메서드를 mocking 해야 할 상황이 온다면 조금 힘들어질 수 있다  
> 이럴때는 인스턴스 변수로 바꾸고 파라미터로 받게끔 하는 것이 좋다  

테스트를 처음에 작성하고 통과하고 끝이 아니라, 해당 테스트의 이름을 전체 만족할때까지 테스트를 계속 확장해나간다  

테스트 메서드는 이 테스트가 뭘 의도하는지를 잘 드러내는것이 중요하다. 소통에 좋은 영향을 미쳐야한다  
한국에서 일하고, 팀원들이 한국인이니 한국어로 테스트 이름을 작성하는 것이 좋겠다  

단위테스트 만드는 것 조차 익숙하지 않다면, TDD는 더 어렵다  

테스트가 가능한 부분을 계속 쪼개는 연습을 해야한다  

TDD를 하면 생각을 좀 덜해도 될수도 있다  
그냥 기대하는 값에 맞추기만 하면 되니까  

테스트 케이스에 없는 코드를 미리 구현하는 것은 TDD의 원칙에 벗어난다  

어떻게 하면 테스트할수 있을까? 어떻게 하면 TDD로 할 수 있을까?  
를 계속 생각하다보면 기존의 내 선입견이 깨지면서 더 나은, 다른 설계가 나오게 된다  
테스트를 하기위해 계속 메서드를 쪼개거나.. 하기 떄문이다  
TDD없이 그냥 설계하면 안나오던것이 TDD를 하다보면 나오게 된다!!  

TDD를 하려면 조급함이 없어야한다  

작은 단계로 진전해나가는 연습을 자주 해야한다  
큰 단계부터 시작한다면 작은 단계로 하는 법을 결코 알지 못한다  

TDD를 하면 빠른 피드백을 받아서 빠르게 개발이 가능하다  
> 싸이클 주기를 빠르게 해야한다  

테스트는 점진적으로 확장시켜야 한다. 한번에 확장 시켜서는 안된다.  

테스트하기 불편하다면 코드 설계를 의심해봐야한다  

테스트를 위해 클래스를 상속으로 만드는 것은 좋지않은 행위이다  

mockito같은 라이브러리는 좋은 구조가 아님에도 불구하고 테스트가 가능하게 만들어버려서. 나쁜 구조를 발견하기 어려워진다  

행위검증은 지양하는 것이 좋다  

인터페이스보단 구현체를 테스트하는것이 맞다  

Random, LocalDate.now()와 같이 제어할 수 없는 값을 반환하는 기능은 테스트 할 수 없다.  
이를 사용하는 코드는 이 부분을 외부에서 주입받을 수 있게 쉽게 분리해놓아야 테스트가 용이하다  

기존 객체를 상속받은 스텁을 만들고 이를 주입해서 테스트할 수 있다  

테스트에 내용이 중복되서 들어가도 괜찮다. 테스트하려는 행위 자체들이 다르기 떄문이다  

private 메서드를 테스트해야 할 상황이 나온다면 설계를 의심해본다  

테스트를 통과시키기 위해선 끔찍한 죄악을 저질러도 괜찮다  
> 나중에 중복 제거만 잘해주면 된다  

# 실무에 적용하면 좋을 아주 중요한 개념들  
서비스 레이어는 상태를 가지지 않는 부분이라 로직을 가지면 안된다. 전부 도메인 모델로 옮겨야한다.  
서비스 레이어에서 로직을 구현한다는 것은 계속해서 getter를 써서 가져와서 무언가를 수행하게 되고, 이는 중복이 계속 생기게 됨을 의미한다   
객체지향적으로 프로그램이 한다는 것은 비즈니스 로직의 중복을 제거하는 것이다  

서비스 레이어에서 계속 도메인의 상태를 get으로 가져와서 로직을 수행하면 서비스 레이어가 매우 뚱뚱해지고, 객체지향과는 거리가 멀어진다(절차지향적으로 변한다)  
(서비스에서 get 메서드로 무언가 가져와서 수행한다면, 의심해보는 것이 좋다(이건 아닌거같은뎨? 라고))  
**서비스 레이어는 기본적으로 다른 레이어와 dependency가 많은 레이어라 테스트하기가 힘든데**, 여기 로직이 구현되어 있다면 이 로직을 테스트하기 힘들어지고, 결국 테스트를 점점 안하게 된다  
서비스 레이어를 테스트하는 것은 도메인 레이어를 테스트하는것 보다 최소 5배는 어렵다  
로직이 도메인 레이어 안으로 이동한다면 단위테스트가 굉장히 수월해진다  

mockito를 자주 사용해서 테스트를 구현하게된다는 것은 서비스 레이어에 로직이 많다는 것을 의미한다  

서비스는 아래 정도의 역할을 수행하는 것이 맞다  
- 외부 인프라스트럭쳐와 상호작용(데이터베이스 등)  
- 도메인 객체에 메시지 보내기  
- 도메인에서 받은 메시지를 다른 도메인이나 서비스에 전달하기  
- 트랜잭션 바인딩  

테스트 우선순위  
1. 도메인 레벨 유닛 테스트  
2. Acceptance Test  
3. 서비스  
4. 레파지토리(여기부터는 굳이..)  
    - mybatis를 쓰는 경우 조금은 다를 수 있다(쿼리에 로직이 있는 경우)  
> 1번과 2번은 둘 다 중요하다  
> 이 2개만 해놔도 충분한 안전장치가 된다(도메인에 대부분의 로직이 있기 떄문이다)  
> **이런식으로 방식을 전환하면 훨씬 빠르게 개발할 수 있다**  
> 하지만 Acceptance Test 작성은 학습 비용이 매우 높다  

틀에 같힌 개발을 할 필요는 없다  
엔티티에 맞춰 서비스, 컨트롤러를 꼭 생성해야 하는가?  
Question, Answer 엔티티는 서로 밀접한 관계이므로, 묶어서 QnAService, QnAController 작성하는 것이 좋다  
어쩌피 중요한 로직들은 도메인에서 테스트된다  
> DDD의 aggregate

꼭 service는 service package, repository는 repository package에 넣을 필요도 없다  
qna package에 qnaService, repository, 도메인들을 묶어놓을 수도 있다  
> 이때 각 패키지간 bidirection이 생기지 않도록 주의해야 한다  
> answer package에서 user package의 클래스를 사용했다면, 반대의 상황은 일어나지 않아야 한다  
> 이게 DDD의 aggregate?  

엔티티도 일반적인 객체지향 프로그래밍 할 때 처럼 다 나눠야한다  
- Question 엔티티에서 title과 contents를 묶어서 QuestionBody 라는 클래스로 만듦  
- List<Answer>를 일급 컬렉션으로 만듦  
- 관련 로직들을 전부 이동
- 이러면 엔티티가 가벼워진다

엔티티는 database mapper가 아니다  
ORM의 최대 장점은 이런식으로 설계된 클래스에 데이터베이스 매핑을 아주 간단하게 할 수 있다는 점이다  
ORM 뿐만 아니라 스프링도 마찬가지이다  
ORM과 스프링은 객체지향의 극장점을 최대한으로 끌어올리기 위해 나온 기술이다  

도메인 객체를 뚱뚱하게 하지 말고 객체를 계속 분리해서 위임하는 식으로 리팩토링을 계속 해야한다  
> 핵심적이고 끊임없이 리팩토링이 필요한 곳은 컨트롤러, 서비스 등등이 아니라 **도메인 객체**이다  
> 알다시피 도메인 로직은 단위테스트를 작성하기 수월하고, 단위 테스트가 많다면 전투적으로 리팩토링 할 수 있다  

객체지향적 설계와 리팩토링을 하다보면 코드상에서 성능과 조금 멀어지기도 하는데, 사실상 이를 서비스 레벨에서 보면 성능으로 손해보는 점이 거의 없는 수준이다  
코드는 전부 이렇게 짜고, 다른 쪽을 튜닝해서 성능을 개선하면 된다(db, 캐싱 등)  

JPA에서 update가 없는 것이 좀 더 객체지향적인 프로그래밍을 하는데 맞는 것이다  
실제로 생각해보면, 객체의 값을 update 했으면 그대로 변경된 것이기 때문이다  

유닛테스트보다 AcceptanceTest가 적게 작성하는 것이 맞다  
Acceptance Test는 테스트 케이스만큼 작성하는 것이 낭비다. 이는 Unit 테스트로 하면 된다  
클라이언트 입장에서 받을 response만 생각해보면 모든 경우에 수에 대해 Acceptance Test가 필요하지는 않다  
> 케이스가 4가지면 Acceptance Test는 2가지, 유닛테스트가 4개인 경우가 대부분 맞다  

**Acceptance Test를 바라보는 관점을 바꿔야한다**  
비즈니스 레벨로 바라보고 테스트를 작성해야 한다  
비즈니스 레벨에서 체크되어야 하는 부분!  
검증 또한 정해진건 없는 것 같다  
repository에서 조회해서 체크해도 되고.. 근데 더 좋은 방법이 있을 것 같은데..  

DTO는 외부에 드러나는 객체이고, 이는 변화할 가능성이 매우 높으므로 DTO로 분리하는 것이 좋다  
DTO에 대한 거부감이 드는 이유는 도메인을 객체지향적으로 설계하지 않았기 때문이다  

HttpMethod별 response와 응답  
(조금 더 생각해야봐야함)  
- GET : 조회한 엔티티 리턴, HttpStatus.OK  
    > List를 오브젝트로 한번 래핑해서 respose로 내려주는 것이 좋다  
    > 나중에 메타데이터 등을 추가할일이 있을수가 있는데, 이때 하위호환성을 깨지 않기 위함이다  
    > 하위호환성을 떠나서도 []를 그대로 내려주는 것은 안티패턴이다  
    ```java
    public class ListResponse<T> {
        private List<T> list;
        private Integer page;
        private Integer size;

        private Integer totalPages;
        private Long totalElements;

        public ListResponse() {
        }

        public ListResponse(Page<T> result) {
            list = result.getContent();
            page = result.getNumber();
            size = result.getSize();
            totalPages = result.getTotalPages();
            totalElements = result.getTotalElements();
        }
    }
    ```
- CREATE : void 리턴, HttpStatus.CREATED, location header 리턴  
- UPDATE : 변경된 엔티티 리턴, HttpStatus.OK  
- DELETE : void 리턴, HttpStatus.OK  

testRestTemplate를 써서 예외를 테스트할때는 리턴 오브젝트의 타입을 Void 또는 String 으로 줘야한다  
예외가 발생했을때 나오는 json으로 오브젝트 매핑이 안되서 다른 오류가 발생하기 때문이다  

Acceptance Test 하나씩 작성해가면서 service, domain을 작성한다
Acceptance Test 작성 -> Controller 작성(이떄 service가 필요하게 됨)  
-> Service Test 먼저 작성 -> Service 작성(이떄 domain이 필요하게 됨)  
-> Domain Test 먼저 작성 -> Domain 작성  

서비스는 mock을 사용해서 테스트하는 것이 좋다.  
db 자체만 해도 힘든데, 여기에 외부의 인프라스트럭쳐 까지 관련되면 테스트가 힘들어질 가능성이 크다  
그리고 테스트 자체도 느려서, 피드백 받는 속도가 느려서 개발 속도가 떨어진다  
여기서 mock 데이터에 대해 andThenReturn 하는 부분을 함수로 만들어놓으니 읽기가 훨씬 편해지는 경향이 있었다  

인수테스트에서 모든 부분에 대해 통합테스트를 진행하는게 좋다  
여기선 사실상 롤백이 힘드니까 필요한 픽스쳐들을 생성해서 테스트해보는게 좋다(import.sql 보단)  
> 이때 너무 특정 상황에 의존적인 Acceptance Test를 작성하지 않도록 해야한다  
> 가령, 1번 게시글을 조회하고, 1번 게시글을 삭제하는 등의 행위는 너무 강력한 acceptance test이다  
> **database가 깨끗하든, 깨끗하지 않던간에 그 api는 성공해야 하지 않는가?**  

DataJpaTest의 경우 매 테스트마다 픽스쳐들을 롤백하긴 하지만,  
내부에서 트랜잭션을 다르게 가져가거나 사용하지 않는 등의 행위를 할 경우 그 부분은 롤백이 안될 수 있다  

fixture는 그냥 원래 이름 그대로 사용함(question, answer 등등)  
service에서 메서드 수행 결과는 returned = returned  
api 호출 결과는 response(+return type) = response, responseQuestion(getBody시에)  
복수형은 s를 붙임 = responseQuestions  

api 수행 후 repository를 조회해서 검증할 수 있다  
목록 api 호출 후 repository 에서 조회한 레코드 개수와 비교한다거나 등등(delete는 Optional이 empty인지 체크 등)  

엔티티의 경우 파라미터로 엔티티를 그대로 받는게 맞는 것 같다. 엔티티에서 식별자를 받아 조회할 수는 없으니까.  
그럼 서비스에서는 식별자를 받는게 맞을까?  

엔티티는 식별자로 equals를 구현하는 것이 좋다  

@Embedded를 구현했을때 delegate 패턴을 구현하는게 좋은것 같다  
> 근데 여기서 embedded 객체를 돌려주는 것도 포함해야하나? 얘는 VO라서 그대로 돌려주는게 여기저기 좋을것 같은데  