---
title: 조영호님 세미나
tags:
---

의존성 관리가 중요하다  
역할이나 책임을 잘 정의하려면 의존성을 먼저 정의해야한다  

설계 = 코드를 어떻게 배치할 것인가?  
- 초점은 변경이다
- 같이 변경되는지, 안되는지
- 이 기준은 의존성이다  

dependency = 변경에 의해 영향을 받을 수 있는 가능성  

연관관계 : A에서 B로 영구적으로 갈 수 있다  
의존관계 : 일시적으로 갈 수 있다  
상속관계와 실체화 관계의 차이 : 구현에 변경이 영향을 받느냐, 시그니쳐의 변경에 영향을 받느냐  

import에 다른 패키지가 있다면 dependency가 있다고 보면 된다  

양방향
- 서로가 바뀌면 영향을 주므로, 원래 하나인걸 억지로 찢어놓은 것이라고 볼 수 있다
- 매번 setter로 동기화해줘야 한다
- 굉장히 많은 이슈가 발생할 수 있다

가급적이면 다중성이 적은 방향으로 관계를 형성해라

의존성이 없다면 빼버리는 것이 가장 좋다  

패키지사이에 의존성 싸이클이 있다면 피해야 한다  

---

언제든 중간에 변경될 수 있으니 검증을 계속 해줘야한다  
- 메뉴 가격이 바뀐다던지
- 메뉴명이 바뀐다던지
- 가게가 문을 닫는다던지

메시지를 어떻게 전달할 것인지 의사결정을 먼저 해야한다  

코드는 모두 동적으로 흘러가지만 우리는 그것을 정적인 코드로 나타내야 한다  
코드를 짜려면 정적인 무언가를 찾아내야 한다  

이 객체와 이 객체는 런타임에 협력할 것인가?  

관계에는 방향성이 필요하다  
= 협력의 방향  
= 의존성의 방향  
런타임에 협력의 방향을 가지고..  

상속과 실체화 관계는 매우  

런타임에 객체들이 어떻게 협력을 할것인가를 기준으로 관계를 설정한다  

해당 연관관계로 1번만 넘어간다면 연관관계로 잡을 필요 없이 의존성 설정만 하면 되고, 빈번히 넘어간다면 연관관계로 설정하면 된다  

내가 무언가를 참조할때는 이유가 있어야한다  

연관관계
- 탐색 가능성  
- 어떤 방식으로든 그 관계로 이동할 수 있어야한다
- 그 통로가 영구적으로 유지가 되어야한다면!

연관관계라는 개념이 있고, 객체참조라는 구현이 있는 것이다  
개념에 구현은 여러가지가 있을 수 있다  
1:1 매칭이 아니다  
객체참조 말고도 방법이 많다  

흐름을 정의해서 메시지를 정의하고, 메서드를 정의해야 한다(순서 중요)  

물리적인 연관관계가 형성되면 연관관계에 메시지를 보낸다  

객체들이 어떻게 협력을 하고, 그 메서드가 그 클래스에 있는게 맞는지?  

디펜던시를 그려봤는데 이상하거나 찝찝한 부분이 보인다면 대부분 이상한 경우가 많다  

잘 모르겠을때는 일단 짜고, 디펜던시를 그려보면서 설계를 고쳐나간다  

레이어라는 것도 개념이고, 자바에서는 패키지로 이를 구현한 것이다  

클래스들이 구체적인것에 의존하지 말고 추상화에 의존함으로써 싸이클을 끊을 수 있다  
디펜던시를 끊음으로써 재사용성을 높일 수 있다  

레이지 로딩, OSIV가 문제가 아니라 객체가 다 연결되어 있는것이 문제이다  

객체참조로 많은 객체를 수정하면 트랜잭션이 길어진다  
여러개의 테이블이 다 락에 걸리게 된다  
이렇듯 객체참조는 성능을 생각안하게 만들어버린다  

shop, order, delivery 묶어서 상태업데이트를 하면 전체적으로 다 락이 걸리게 되는데, 각자의 객체들은 이 외에도 상태를 업데이트하는 주기가 있다  

객체참조는 결합도가 가장 높은 의존성이다  
불필요하다면 다 끊어버려야 한다  

비즈니스 로직은 단방향으로 깔끔하게 만들수 있지만 조회가 들어가면 양방향으로 막 묶이게 된다  

같이 생성되고 같이 제거되는 애들은 묶어줘야한다(어쩌피 같은 트랜잭션 안에서 움직여야 한다)  
이런 애들은 강한 참조를 의미하므로 객체참조로 연결시켜도 되고, 레이지 로딩도 써도 된다  

장바구니에 데이터를 넣는데 컨스트레인트가 없다면 찢어야 한다  

공유하는게 있는지? 시점이 같은지?  

경계안의 객체는 참조로 이어지는게 좋다  
그 외에는 ID로 참조하고 repository로 가져와야 한다  

끊고나면 그 단위로 트랜잭션으로 묶어주면 된다  
한번에 수정하고, 한번에 조회하고  

이런식으로 애그리거트별로 나눠놓으면 영속성 저장소도 변경 가능하다  
어떤 애그리거트는 RDB, 어떤 애그리거트는 NoSQL..  

validation 로직이 여러 객체에 찢어져있으니 한군데 모으면 한군데 볼 수 있다  

응집도는 같이 변경되는 애들이 같이 있어야 응집도가 높은 것이다  

validation이 엔티티에 들어가면 응집도가 낮은 것이다  
로직이 변경하는 시점과 validation을 변경하는 시점이 달라지기 때문이다  

애그리거트가 같이 변경되어야 할 때  
- service 에서 절차지향적으로 하는 방법
- 도메인 이벤트를 사용

디펜던시 싸이클이 도는지 계속해서 그려가며 체크(패키지에)  

디펜던시를 쭉 쫒아가다보면 도메인에 대한 관점이 달라질때가 많다  

패키지 의존성 싸이클을 찢는 방법
- 중간 객체만들기 
- 의존성역전
- 새로운 패키지 추가  

가장 쉬운 방법은  
레이어드 아키텍쳐 안에 도메인을 넣는 패키징  
내부는 도메인 이벤트, 외부는 시스템 이벤트  

리포지터리 인터페이스를 도메인에 넣지 않으면 싸이클이 생긴다  
Custom은 impl  

디펜던시를 잡는 기준  
자주바뀌는 쪽에서 덜 바뀌는 쪽으로 디펜던시를 연결해줘야 한다  

CQRS  
조회와 수정을  

비동기를 선택하는 것은 정합성을 조금 포기하는 것이다  
모든것은 이런식으로 트레이드 오프가 있다

is 메서드를 많이 넣다보면 응집도가 떨어진다  
그러므로 찢어줘야하는데, 찢는 방법도 있고 정합성을 체크해주는 Specification을 만들어주는 방법도 있다  
> Specification 패턴  