# 현 상황
## 대기중인 건
위드이노베이션
카카오페이지
NHN
트리플
티몬
디케이테크인
에스케이엔카닷컴
1. 옵토레인
분당 삼평동, 반도체기반 체외진단 시스템

## 서류 통과
1. 위메프  삼성, 신사업 여행 플랫폼  
> 9/17 11시  
Java/Spring, Spring Data JPA, API, vue.js, ecma6, msa, spring sequrity, git/git flow, gradle, aws
1. 이스트소프트  서초, 웹서비스 개발  
> 9/19 16시
1. 메쉬코리아  봉은사, 물류
> 9/18 2시 30분
1. 와디즈  판교, 크라우드 펀딩
> 9/18 11시
1. 테라펀딩  역삼, 부동산 크라우드 펀딩  
> 9/18 5시

## 기술 면접 결과 대기중
1. EVERYSING
청담역, SM 엔터테인먼트 개열사, EVERYSING 앱 백엔드 서버 개발
> 여긴 안됨~ 일단 내부 시스템이 너무 옛날꺼고, 업무도 나랑 전혀 맞지 않음.
팀장 레벨도 별로 높아보이지 않음.
1. 네이버웹툰
1. 이엠캐스트
선릉역, 이러닝, 포털, 컨텐츠  
> 회사 내부 분위기가 괜찮음. 기술셋도 잘 맞긴하는데, 프론트 백엔드가 나뉘어져 있어서 애매함  

## 결정난 건
1. 야놀자  선릉, 백엔드 개발자  
> **서류 탈락**  
1. 렌딧  종로, 백엔드 개발자  
> **서류 탈락**  
1. 브레인OS연구소  대치동 학여울역, 뇌연구 솔루션
> **면접(1차,2차 통합) 탈락**  
연봉은 3700까지 줄수있다곤 함.  
생각보다 엄청 기술 레벨 높음. 신기술 많이 도입되어 있었고, 팀장의 레벨이 높아보임.  
서비스가 너무 많음(자바 외에도), 트래픽도 엄청 없다고 함.  
1. 씨엔티테크  증산역, 온라인 주문 시스템  
> **면접(1차,2차 통합) 탈락**  
너무 멀음. 연봉도 맞춰주지 않을듯. CTO의 레벨이 별로 높아보이지 않음.
자바외에 다른 시스템도 많은듯.

# 기술 외
자기소개(간단하게)   
> 경력 3년 정도의 웹 개발자이고, 백엔드랑 프론트엔드를 도맡아서 했었습니다.  
전 직장에서는 spring, jpa, mybatis를 이용한 서버 개발과 reactJS를 이용한 클라이언트 개발을 주로 담당했었습니다.  

함께 성장하는 팀워크가 뭔가요?   
> 서로 열심히 공유하고, 격려하고, 같이 고민하며 더욱 더 품질 좋은 소프트웨어를 만들어내는 것을 매우 좋아합니다. 그 과정을 매우 좋아하고 그 무리속에 있고 싶어 한다.  

전 회사를 왜 그만뒀나요?   
> 저는 회사를 다니면서 가장 중요시하게 여기는 가치가 팀 문화, 기업 문화라고 생각합니다.  
함께 공유하고, 격려하고, 고민하면서 품질 좋은 소프트웨어를 만들어내면서 성취감도 얻고 하는 과정이 회사를 다니는데 가장 큰 이유라고 생각합니다.. 하지만 전 회사에서는 그게 충족되지 못했습니다.  
다들 좀 폐쇄적이고.. 저 개인적으로 노력을 많이 하긴 했는데 이게 생각보다 잘 안되더라고요, 그래서 결국 시간이 지나고 지나다보니 지쳐서.. 나오게 되었습니다.  
그 외에도 회사가 돈이 없어가지고 월급 밀리고.. 사장님은 따른 사업한다고 기존 서비스에는 아예 관심도 가지지 않고 하셔서 나오게 되었습니다.  
배움에 관해서는 잘 설명했는데, 부차적인 부분의 설명이 더 필요하다  
좀 더 상세하게! 알아야 하는건데도 안 알아야 한다.. 이런 얘기 부분이 좀 더 다듬어야 함  

팀원과의 소통이랑 뭘 말하는건가요?   
> 일반적인 업무 소통을 말하는 것은 아닙니다.  
좀.. 같이 뭔가 해나가는 그런 분위기?  

자신의 장단점이 무엇인가요?   
> 모든 일을 할때 항상 많이 고민하고 노력하는 스타일입니다. 모든 일은 고민하고 노력하는 만큼 결과가 나오게 되어있다고 믿는 편이어서..  
그리고 자아성찰을 좀 잘합니다. 제 자신을 3인칭 관점으로 바라보고 감정 빼고 어느부분을 잘했는지, 못했는지 판단하고 개선해나가는 과정을 잘 합니다.  
단점은 가끔씩 고집이 쎌때가 있는데 이부분은 계속해서 개선하려고 노력중인 부분입니다.  

학교는? 어디어디 다녔나?   
> 부산에 동명대 중퇴하고 학은제로 졸업했습니다.  
(중퇴 왜 안썼나?)최종학력 외에는 딱히 중요하다고 생각안해서.. 기재 안했습니다.  

우리 회사가 무슨 사업을 하는 회사인지 아나? 들어는 봤나?   
> 이 부분은 면접 전마다 챙기긔~  

지원한 이유는 뭔가?   
> 이것도.. 대신 잘 말해야 할 필요가 있다!  

우리 회사의 어떤 서비스가 끌려서, 어느 파트가 하고 싶어서 여기 지원했나?   
> 이것도!  

진행중인 채용건이 있는지?   
> 왜?  

연봉은 어느정도 바라나?  
> 이건 아직 얘기할 단계가 아닌것 같습니다. 서로가 마음에 들어서 같이 일하겠다고 결정이 나면 그떄 협상할 부분인 것 같습니다.  
어쩔수 없이 말해야 한다면... 3500 이상!  

이 얘긴 언제하지?  
> 내가 어릴때부터 일해서 정신차려가면서 하나씩 성장하는 모습을 긍정적으로 보심. 잘 성장하고 있다고 함.  
다음회사에서 진짜 후회없게 더 잘해보고 싶다.  
왜 그때 그렇게 하지 못했지를 후회한다.  
이런것을 좋게 보심.  

어떤 개발자가 되고 싶은가요?   
> 별로 특별한건 없고, 기술스택 높고, 소통이 잘 되는 개발자.  
그 정도만 해도 최고라고 생각함.  

본인이 면접관이라면 뭘 물어볼거같나요?  
> 트러블 슈팅 경험  

웹개발자라는 직업을 가지게 된 과정?   
> 왜 이떄까지 난 이걸 숨겨왔던가..  
부산 동명대학교 정보통신공학과 진학 -> 학비도 너무 비싸고 그 당시에 진로에 대해 확실한것도 없어서 일단 휴학 -> 여기저기 일 하면서 진로에 대해 고민 -> 자퇴 후 학은제 + 웹개발자 과정 수료 -> 취업  

스터디 3개 외에 다른 커뮤니티가 또 있나?  
> 없당~  

1시간이란 우리가 니를 알아가는 것과 니가 우리를 알아가기에는 시간이 너무 작다고 생각해서 추가적으로 프로세스가 필요하다고 생각한다  
> 그렇다. 이런것에 겁내지 말자.  

개발팀 몇명이었나?  
> 총 8명 정도. 식신 사업 3명, 식권 사업 2명, 앱 개발자 3명.  

회사에 궁금한거 있나?  
> 기술셋..  
AWS 플러그인, 기능들이 있으면 쓴다  

네이버웹툰에 입사하면 어떤 경험을 하면서 본인을 성장시키고 싶나?  
> 대용량 트래픽, 높은 기술력, 네이버의 팀 문화  

기술적인 스킬은 대부분 어디서 습득하나?  
> 책에서 습득합니다  

자신의 러닝커브가 어느 정도인것 같나? 빠르나?  
> 보통인 편이다.  

개발할때 충분히 고민하고 개발하는 스타일인가, 개발하면서 알아가는 스타일인가?  
> 충분히 고민하고 개발하는 스타일인데, 정의가 잘 안되거나 감이 안 잡힐 경우 개발하면서 하나하나 알아가기도 한다.  

요구사항이 의도치 않게 변경될때 스트레스 받는편인가 자연스럽게 풀어나가는 편인가?  
> 자연스럽게 풀어나가는 편이다. 모든 요구사항은 변한다는 전제를 가지고 있기 때문이다.  

# 기술 내
## 자바
클래스패스란 뭔가?  
> jvm이 class 파일을 찾기 위해 뒤지는 경로이다.  
시스템 환경변수에 CLASSPATH에 나열하거나 java runtime에 -classpath를 이용하는 방법이다.  
:으로 연결되며 디렉토리, zip, jar 파일등이 올 수 있다.  

jvm 구조 아시나요?   
> 크게 메서드 영역, 힙 영역, 스택 영역이 있다.  
> Java Virtual Machine의 약자로써 자바 바이트 코드(.class 파일들)를 실행할 수 있다.  
>> Java는 모든 class 파일을 메모리에 올려서 실행하지 않고, 필요한 시점에 해당 class 파일을 메모리에 올려 실행하는 On-Demand 방식을 사용한다(static 변수도 이때 초기화)  
> 일반적으로 프로그램은 OS에 종속적인데, 자바로 작성한 프로그램은 각 OS에 맞는 JVM만 있으면 어느 OS든 동일하게 실행 가능하다.  
> JVM 메모리 영역은 5개 영역으로 나뉘고, 크게 3가지 영역 정도로 볼 수 있다.  
>   1. **Method(static) Area**  
    위에서 JVM은 On-Demand 방식으로 필요 시점에 class 파일(바이트 코드)를 올려서 실행한다고 했었다. Method Area에는 그 중 메서드의 바이트코드가 저장된다.(메서드가 실행의 대부분이므로 모든 바이트 코드가 올라간다고 봐도 무방함)  
    여기에 전역변수(static)까지 같이 올라간다. static 메서드는 당연히 올라간다.  
    JVM에서 오직 하나의 영역만 존재하고, 공유할 수 있다(다른 스레드에서 접근 가능)  
>   1. **Heap Area**  
    new 연산자로 생성된 인스턴스들의 정보를 저장하는 곳.  
    JVM에서 오직 하나의 영역만 존재하고, 공유할 수 있다.  
>   1. **Stack Area**  
    메서드의 매개변수, 지역변수를 저장하는 곳이다. 스레드마다 런타임시에 각각 생성되고, 메서드 호출이 완료되면 소멸된다.(공유 자원이 아니다)  
    먼저 호출한 메서드부터 아래쪽에 쌓인다.       

```java
class Item{
    String name;
    int price;
    public Item(String n, int p){
        this.name = n;
        this.price = p;
    }
}

class Main{
    static void main(String[] args){
        int inputPrice = 10;
        String inputName = "Vaccume";        

        Item item = new Item(inputName, inputPrice);
    }
}
```

> 1. 먼저 inputPrice 변수가 stack에 쌓인다.  
> 2. "Vaccume"은 객체이므로 heap 영역에 생성되고, inputName이 stack에 쌓이면서 "Vaccume"의 주소를 가진다.  
> 3. Item 객체가 생성되면서 heap 영역에 생성된다(name, price 또한 이 영역에 속함). stack엔 item이 쌓이고, heap에 생성된 객체를 가리키게 된다.  
> 4. Item의 생성자가 실행되면서 n, p가 stack에 쌓이고, heap에 있는 변수에 값을 세팅하고 소멸된다.  

가비지컬렉션에 동작방식 아시나요?   
> 힙 영역에 생성된 객체들 중 사용되지 않는 애들(Garbage)을 JVM이 정리하는 과정을 Garbage Collection이라고 한다.  
stack 변수와 static 변수에 깊이우선탐색(DFS)를 실행하여 참조되지 않는 애들을 Garbage로 분류하고, 이를 청소하여 메모리를 확보하는 형태로 진행한다.  
(stack 변수와 static 변수를 root 라고 표현한다.)  
3가지 정도의 방식이 있다.  
>> 1. 마크청소 GC  
root로 부터 DFS를 수행하여 도달 가능한 애들에 마크 표시를 한다.  
이후 마크 표시되지 않은 애들을 삭제한다.  
중간중간 삭제되었으니 객체들이 단편화(퍼져있음) 되었을 것이므로, 이를 새로운 위치로 깔끔하게 정리한다.  
근데 이 과정에서 객체들의 주소가 바뀌므로, root들의 참조 주소를 전부 바꿔줘야 하는 낭비가 발생한다.  
그래서 중간에 객체주소를 저장하는 공간을 따로 둬서 이런 비효율을 없게끔 한다.  
`root들 -> 객체주소저장공간 -> 객체`  
마크하고, 청소하고, 옮기므로 좀 느리다는 단점이 있다.  
>> 1. 복사 GC  
힙 영역을 2개로 나누어 관리한다. DFS를 하며 live한 객체들을 반대편 heap 영역으로 정렬하며 복사한다. 반대편 영역끼리 이 과정을 반복한다.  
마킹, 정렬들의 과정이 없으므로 속도가 빠른 장점이 있지만 heap 영역을 반으로 나눈다는 단점이 있다.  
>> 1. 세데 기반 GC  
객체들의 수명이 대부분 매우 짧다는 것에 기반하여 생긴 방법이다.  
heap 영역을 크게 YOUNG, OLD 영역으로 나누고 수명이 짧은 객체와 긴 객체를 나눠서 저장한다.  
YOUNG 영역은 EDEN 영역 1개, SURVIVOR 영역 2개로 나눈다.  
초기에 객체가 생성되면 무조건 EDEN 영역에 들어오고, 여기서 DFS 탐색을 수행하여 살아남은 객체에 대해 SURVIVOR 영역으로 복사 GC를 수행한다.  
이 다음부턴 SURVIVOR 영역 + EDEN 영역에 대해 DFS를 수행하고, 살아남은 객체에 대해 반대편 SURVIVOR 영역으로 복사 GC를 수행한다. 이 과정을 반복한다.  
이 과정에서 오랫동안 살아남는 객체를 OLD 영역으로 올려보내게 되는 것이다.  
OLD 영역의 경우 변화가 적으므로 GC를 자주 수행하진 않는다. OLD 영역이 꽉 찼을 경우 GC를 수행한다. 여기서는 마크청소 GC를 사용한다.  

자바의 장점이 무엇인가요?   
> 객체지향 프로그래밍이라는 것. 한번 작성한 코드는 어느 OS든 종속되지 않고 사용할 수 있다는 점(write once run anywhere), 자료가 상당히 많다는 점, 오픈 소스라는 점. 오픈소스 생태계에서 굉장히 많은 발전을 해서 자바로 된 프로그램들이 굉장히 많다는 점. 여러가지 플랫폼(웹, 모바일, 응용프로그램)을 만들 수 있다는 점. 전세계 프로그래밍 언어 순위 1등이라는 점 등등..  

객체지향 언어는 많은데, 왜 하필 자바인가요?   
> 위에서 언급했다!  

본인의 자바 레벨이 몇 정도라고 생각하나요?   
> 중간 정도? 문법적인 부분은 문제없고, 아직 숙지해야할 부분이 많다고 생각한다. 객체지향 같은..  

인터페이스에 대해 설명해보세요.   
> 약간 설계도 같은것 정도라고 볼 수 있다. 기능에 대해 정의는 해놨는데 구현은 아직 없는 상태. 메서드의 몸통이 없고 구현하는 애들이 그 몸통을 구현헤야한다. 추상클래스보다는 좀 더 자유롭다.  

자바 8 어디까지 공부했는지?  
> 람다, 메서드/생성자 레퍼런스, 스트림 그룹핑 까지 공부했다.  

자바 8의 몇가지 특징들을 아나? 자바 8에서 뭐가 변했나? 자바8의 장점이 뭔가?  
> 일단 가장 큰것은 람다식. 람다식이 들어오면서 함수형 프로그래밍이 훨씬 편리해졌다.  
스트림을 통해 컬렉션을 다루는 새로운 방식이 탄생. 반복이 내부로 숨어버렸고, 파이프 연산으로 처리할 수 있다.  
또한 여기에 유틸리티에서 제공하는 그룹핑 함수를 적절히 사용하면 복잡한 그룹핑도 간결하게 작성할 수 있다.  
디폴트 메서드를 통해 하위 호환성을 건드리지 않고 메서드를 추가할 수 있다. 근데 욕 많이 먹었다는데..  

자바8에서 가장 좋아하는 기술은 뭔가?  
> 스트림에서의 그룹핑이다. 간결하고 빠르게 우리가 원하는 목표를 달성할 수 있기 때문.  
람다도 괜찮지 않나? 함수형 프로그래밍을 하는 습관을 들이게 해주니까?  

Collection같은 경우 리스트 부분만 탐색하는게 가능한데 Stream은 아니지 않나?  
이건 어떻게 생각하나? 아니면 Stream에서 그런게 가능한가?  
> if else는 사용할 수 있으나 중간부터 탐색은 불가능하다.  
그럴때는 스트림을 쓰지 말아야 하지 않을까?  

메서드 레퍼런스는 써봤나? 메서드 레퍼런스가 뭔가?  
> 함수형 인터페이스의 형태가 메서드의 호출 형태와 동일할 경우 메서드 이름만 써줘서 호출시킬 수 있다.  
문법적으로 매우 깔끔해보인다.  

자바8 스터디를 진행하면서 기억나는점이 특히 있나? 코드리뷰나 그런거에 대해서..  
> 람다를 쓰면서 함수형 프로그래밍을 본것, 스트림을 그룹핑을 이용해서 매우 간결하게 복잡한 그룹핑에 도달한 것.  
코드리뷰 처음해봐서 좋았고, 박재성님 자료중에 고민을 많이 해보게 하는 것들이 많았다  
일급 콜렉션만 써야한다거나, 모든 원시값을 포장한다거나..  

제네릭이 뭔가?  
> 클래스에 직접 명시적인 타입을 선언하지 않고 클래스 구현하는 쪽에서 타입을 지정하게 하는 방법.  
유연하게 프로그래밍 가능하고, 캐스팅 연산자로 직접 캐스팅 해줄 필요도 없다.  
또한 컴파일러 레벨에서 문법적인 검사도 해주므로 캐스팅을 잘못하다가 runtime에 오류가 나는 행위를 막을 수 있다.  

제네릭은 많이 써봤나? 제네릭 키워드들은 많이 써봤나?  
> 제네릭은 자주 썼다. 하지만 키워드들까지 쓰진 않았다.  

애노테이션 만들어봤나?  
> 간단하게 만들고 handlerInterceptor에서 사용하도록 했다.  
만들었던 API는 항상 access token이 필요했다. (access token이 없을 경우 access deny exception을 반환했다.)  
어쩌다보니 토큰을 만들지 못하고 api를 호출해야 하는 상황이 있었다.  
그래서 그때 annotation을 추가하고 해당 annotation을 구현한 api일 경우 access token 검증 로직을 타지 않도록 했었다.  

자바의 접근제어자는 뭐뭐가 있나? 다들 범위가 어떻게 되나?  
protected 메서드를 오버라이딩 했을때 하위클래스의 접근제어자는 뭐뭐 쓸수 있나?  
> 접근권한은 확장만 가능하다.  

자바에서 싱글턴을 지원하는 방식이 또 있는데, 싱글턴처럼 쓸수있는 것들이 있는데 뭔지 아나?  
> enum이 있다. enum은 자체적으로 public static 으로 정의된다.  

enum 써봤나? enum 메서드 정의 해봤나? enum의 장점이 뭔가?  
> 해봤다.  
1. 값의 범위를 제한할 수 있다. final 상수같은걸 사용해봤자 사용자가 일반 숫자값을 넣으면 끝이다.  
enum을 쓰면 문법적으로 걸러버려 실수를 방지할 수 있다.  
2. 같은 이름의 상수가 공존 가능  
3. 내부에 메서드도 정의할 수 있음  

## 스프링
DI란?   
> IOC란 제어의 역전을 의미하는 말로써 흐름을 직접 주도하는 메인 메서드 개발 방식과는 달리 프레임워크가 흐름을 주도하며 개발자가 만들 애플리케이션 코드를 사용하는 방식이다.  
DI는 이 과정에서 각 클래스간의 의존관계가 있을 경우 주입해주는 역할을 한다.  
이 DI가 진짜 중요한 이유가 뭐냐면, 이 행위 자체가 결합도가 낮은 프로그래밍, 전략패턴을 사용한 프로그래밍을 하는 과정이고, 이 과정을 너무 편리하게 해줘서 우리가 이 프로그래밍 방식을 계속 준수하여 개발하게끔 해준다는 것.  

스프링 부트 버전 몇 썼나요?   
> 1.5.9  

스프링 부트를 사용하신 이유가 무엇인가요?   
> 스프링 부트는 스프링을 쉽게 사용하도록 도와주는 도구이다.  
스프링을 직접 세팅하는데는 시간도 많이 걸리고, 설정할 것도 많다. 또한 배포 또한 복잡하고, 톰캣도 외장으로 직접 설치해줘야 한다. 스프링 부트는 이러한 문제점을 해결해준다.  

스프링 프레임워크랑 스프링 부트 차이점이 뭐라고 생각하나?  
스프링 프레임 구버전에서 이게 괜찮았는데 부트에서는 이게 아쉬운데.. 하는거 없었나?  
> 스프링 부트 자체가 스프링 프레임워크를 지원해주기 위해 나온것이기 때문에 장점이 매우 많다.  
기존의 스프링 프레임워크의 복잡한 설정들을 대부분 디폴트화 해서 따로 설정해줄 것이 거의 없으며(확장도 매우 쉽게 가능),  
starter 의존성을 통해 의존성을 한방에 관리해준다. 그리고 내장 톰캣, 쉬운 배포.  
아쉬운건.. 잘 모르겠다.  

스프링 프레임워크랑 부트 버전이 뭐였나?  
스프링 부트 안의 스프링 버전은?  
> 스프링 부트 1.5, 스프링 4.3, 톰캣 8.5(Show Effective pom)  

AOP는 어디까지 써봤나?  
> 페이지나 API 접근 권한 설정할 때 정도 써봤다.  
Controller 메서드에 커스텀 어노테이션으로 각 메서드를 호출할 권한을 설정한다. ex) AdminRoll.root, AdminRoll.manager..  
그리고 handlerInterceptor에서 사용자의 id를 보고 권한을 체크한 뒤, request scope의 빈에 사용자의 roll 타입을 넣는다.  
그리고 aop에서 setting된 사용자의 권한과 컨트롤러 메서드의 권한을 비교하고 부합하면 컨트롤러 통과, 부합하지 않으면 exception을 발생시킨다.  

interceptor와 filter의 차이가 뭔가?  
> filter는 web.xml에 지정하므로 어플리케이션 전반에 적용할 수 있으나, 스프링 빈이 아니라는 점과 섬세한 컨트롤이 불가능 하다는 단점이 있다.  
interceptor는 특정 handlermapping에 국한된다는 점이 있으나, 스프링 빈으로 등록되고 더욱 정교한 컨트롤(ModelAndView)이 가능하다는 장점이 있다.  

Exception은 어떻게 처리했나?  
> ExcpetionHandler를 구현한 클래스를 만들었다.  
비즈니스 로직 exception이 발생했을 때는 직접 정의한 Exception을 발생시키고 세팅한 error code, message를 json으로 만들어서 리턴.  
비즈니스 로직이 아닐 경우는 적절한 에러메세지를 보내도록 했다. 관리자한테 문의하라는 둥..  

DispatcherServlet의 Flow에 대해서 설명해봐라  
> 먼저 Front Controller인 DispatcherServlet이 사용자의 request를 받고, 공통 전처리 작업이 있으면 이를 수행한다.  
그리고 컨트롤러를 바로 호출하는 것이 아니라 HandlerMapping을 통해 세부 컨트롤러를 찾고, HandlerAdapter를 통해 이를 수행한다.  
이후 컨트롤러 로직 수행, 모델 생성, 뷰 이름 리턴 하면서 컨트롤러의 역할은 끝이남.  
DispatcherServlet은 전달받은 뷰 이름으로 ViewResolver에게 뷰를 찾아달라고 요청하고, 찾은 View에 모델을 전달하면서 페이지 생성 요청.  
등록된 후처리 작업이 있으면 수행.  
생성된 페이지를 response로 만들어 사용자에게 전달.  

## JPA
JPA와 MyBatis를 같이 쓴 이유가 뭔가요?   
> JPA를 선호하는 사람도 있었고, MyBatis를 선호하는 사람도 있었다보니 그렇게 되었다.  

또 다시 그런 상황이 온다면 어떻게 설득할건가? 지금 한번 설득해봐라  
> 먼저 MyBatis의 단점을 설명한다. SQL과 객체지향의 패러다임을 맞추기 위한 노력.  
(SQL과 객체지향 언어 자체의 패러다임이 아예 다르기 때문에 계속해서 변환해주는 과정이 필요하다.  
SQL 의존적인 개발, 쿼리가 바뀌면 엔티티가 변환해야 하고, 엔티티가 바뀌면 쿼리를 바꿔야 한다.)  
반면 JPA를 사용하면 이러한 패러다임 문제를 대부분 해결할 수 있다.  
자바의 상속을 사용하여 엔티티를 설계 할 수 있다.  
객체지향에서는 객체가 다른 객체를 속성으로 가지면서 관계가 형성되지만, SQL의 경우 JOIN이라는 행위로 관계가 형성된다.  
그래서 만약 A테이블 데이터를 가져올떄 B테이블을 조인해서 가져오고 싶으면 쿼리를 따로 만들어야 하고, C테이블을 조인하고 싶어도 쿼리를 따로 만들어야 한다.  
JPA에서는 테이블간 관계만 맺어주면 이런 행위를 동적으로 할 수 있어서 SQL에 의존적이지 않게 된다.  
탐색 또한 마찬가지.  
영속성 컨텍스트 때문에 동일성도 보장받을 수 있다. 똑같은 조건의 쿼리를 두번 때리면 캐시를 사용하므로 결과적으로 1번만 조회하게 된다.  

JPA 써보니까 어떤가?  
> JPA를 사용하면서 얻는 장점에 대해 설명했다.  
MyBatis의 SQL 의존적 개발에서 벗어날수도 있다  
생산성, 패러다임 불일치 해결, 높은 추상화, 성능 향상  

JPA는 얼마나 써봤나? 
> API서버나 백오피스에서 JPA를 사용했고, 흥 이라는 사이트는 전체 JPA로 만들었다.  

jpa, hibernate, orm의 차이가 무엇인가요?   
> ORM이란 Object Relation Mapping의 약자로써 오브젝트와 데이터베이스간 매핑을 지원해주는 방법론을 얘기하고, JPA는 자바진영에서 ORM의 표준을 말한다. 쉽게 얘기하면 인터페이스의 모음이다. 그러므로 이에 대한 구현이 필요하다. hibernate나 eclipse link는 그 구현채이다.  

JPA는 어떤식으로 공부한건가?  
어디까지 공부했나?  
> 김영한씨 JPA 책으로 공부했고, JPQL 정도까지 공부했다. Spring Data JPA랑..  

JPA의 엔티티들의 상태가 어떤식으로 관리되는가?  
> 상태는 비영속, 영속, 준영속, 삭제가 있다.  
엔티티를 간단히 new로 생성했을 경우가 비영속 상태이고, 이때는 영속성 컨텍스트에 의해 관리되지 않으며 어떤 행위도 DB에 영향을 미치지 않는다.  
여기서 이 엔티티를 엔티티매니저를 통해 저장하거나, 엔티티매니저를 통해 특정 엔티티를 조회해왔을 경우 영속상태가 된다.  
영속성 컨텍스트에 들어간 엔티티들은 캐시, 쓰기지연SQL, 변경감지 등의 기능을 제공받게 된다.  
그리고 detatch를 사용하면 엔티티 매니저가 더 이상 관리되지 않게 되는데, 이러면 영속성 컨텍스트에서 삭제된다.  
이런 엔티티는 위의 영속성 컨텍스트가 제공해주는 장점들을 누리지 못하고, DB에도 아무 영향을 주지 않는다.  
삭제는 해당 엔티티를 조회해서 영속성 컨텍스트로 들고온 다음 영속성 컨텍스트와 데이터베이스에서 삭제하는 과정이다.  

CQRS? 써봤나?  

엔티티 매핑 어디까지 해봤나?  
OneToOne, ManyToMany 까지 다 써봤나?  
> 기본적인건 다 써봤다. ManyToOne, OneToMany, OneToOne, ManyToMany  

Embedded를 1:N로 연결하려면 어떻게 해야하나?  
> Embedded는 벨류 오브젝트라 다른 엔티티와 관계를 맺을수 없는걸로 알고 있고,  
Embedded 내에서 관계 매핑을 말하는것 같은데, 그냥 일반적인 엔티티와 동일하게 @OneToMany등으로 연결해주면 된다.  

상속은 써봤나? 좋던가?  
> CreateDate, ModifiedDate를 가지는 부모 클래스 생성하고 상속하는거 한번 해봤다. 집에서 한번..  

JPA에서 벨류 오브젝트가 있는데, 특징이 뭔가?  
> 엔티티 타입은 @Entity로 정의한 객체이고, 값 타입(벨류 오브젝트)는 int, Integer, String 처럼 단순히 값으로 사용하는 자바 기본타입이나 객체를 말한다.  
JPA에서는 primitive type, wrapper, String 같은 것 외에 직접 값 타입을 정의해서 사용할 수 있는데, 이걸 임베디드 타입이라고 부른다.  

임베디드 타입은 좀 써봤나?  
> 대체적으로 복합 기본키 생성할 때 사용했다.  
/**
또는 가끔씩 테이블 내에 성격이 비슷한 값들을 묶을때 사용했다.  
뭐 얘를 들면.. 주소나 날짜 같은것들.  
**/

임베디드 타입의 장점은 뭔가?  
> 비슷한 성격을 가진 애들끼리 클래스로 묶음으로써 훨씬 객체지향적이게 된다.  
응집력이 강해지고, 여러군데서 재사용할 수 있다.  
내부에서 객체 매핑도 할 수 있다. 즉, 그냥 나열된 것들을 한데 모아주는 역할 정도 하는데 이로 인해 얻는 이점이 상당히 많다.  
관리도 한방에 된다! setAddress(null) -> address 관련 필드 전부 null 처리

다중 식별자를 하는 방식이 2개인데, 2개 다 써봤나? 두개 차이점은 좀 아나?  
> @IdClass와 @EmbeddedId가 있다.  
@IdClass는 일단 엔티티쪽에 복합키로 선언해야 할 애들을 @Id로 쭉 나열하고, 걔네들을 묶은 클래스를 하나 더 만든다.  
그리고 기존 엔티티에 @IdClass(XXXId.class) 라고 선언해줌으로써 사용할 수 있다.  
좀 객체지향적이지 않다. 관리할 포인트가 2개로 늘어난다는 점이 불편하지만 JPQL 작성 시 좀 더 간결해질 수 있다.  
@EmbeddedId는 복합키로 선언해야 할 애들을 하나의 클래스로 만들고, 엔티티쪽에는 @EmbeddedId 어노테이션과 해당 클래스만 선언하면 된다.  
좀 더 객체지향적이긴 하지만 JPQL 작성시 더 길어질 수 있다. embeddedId.컬럼명 으로 접근해야 하므로..
그리고 @IdClass를 사용하든 @EmbeddedId를 사용하던 PK 클래스에는 equals와 hashCode를 오버라이드 해줘야 한다.  
영속성 엔티티는 엔티티의 식별자를 키로 사용하여 엔티티를 관리하기 때문이다.  
그러므로 hashCode나 equals가 제대로 나오지 않을 경우 똑같은 조건의 엔티티인데도 다른 엔티티가 나오는 등의 위험한 상황이 발생할 수 있다.  

@MapsId가 뭔가?  
> @EmbeddedId에 식별관계를 형성할 때 사용된다.  
PK클래스를 만들고 부모테이블의 기본키를 클래스 형태 말고 벨류 오브젝트의 형태로 나열한다.  
그리고 엔티티쪽에 부모 오브젝트의 관계를 매핑해준 뒤, @MapsId로 어느 컬럼에 매핑되는지 지정해줘야 한다.  
이유는 모른다~  

엔티티의 특징은 뭘까? 뭘 엔티티라고 하나?  
> 엔티티 매니저에 의해 관리되는 클래스?  
꼭 1개의 테이블만을 말하는건 아니다. @ManyToMany에 의해 생성되는 교차테이블도 엔티티이다.  

ManyToMany로 생성되는 교차테이블은 엔티티인가?  
>  

OneToOne 관계에서 fetch에 대한 특징이 따로 있나?  
> Lazy Loading 이슈가 있다. 단방향 양방향 관계없이 연관관계의 주인이 lazy 로딩을 하면 되고, 주인이 아닌 애가 lazy 로딩을 하면 되지 않음.  
ManyToOne, OneToMany로 변경하는 방법이나, bytecode instrumentation?을 이용하는 법이 있다.  

다이나믹한 쿼리를 생성하기 위해 어떤 기술을 써봤나?  
어떤것 같나? 구성은 직접 했나?   
> 간단하게 queryDSL을 사용헀다.  
메이븐에 queryDsl 관련해서 의존성과 플러그인 추가하면 자동으로 QEntity가 생성되고, 그것으로 동적 쿼리를 생성할 수 있다.  

JPQL을 왜 썼는가?  
> 초반에는 아마도 MyBatis 처럼 직접 쿼리를 쓰는 형태의 개발에 익숙해서 그랬던것 같다.  
어쩌피 객체로 다 매핑되므로 문제도 없고..  
하지만 동적 쿼리를 생성할 수 없다는 점과, 문법의 오류를 런타임 전까지 알 수 없다는게 문제다.  

## 프론트
리액트를 강요하는데, 뷰나 앵귤러 같은거랑 비교는 해봤나?   
> 그 당시에 끝판왕 급으로 등장하는 중이어서 다른 애들이랑 비교하진 않았습니다. jQuery를 이용한 개발 방식과만 비교했습니다.  

리액트에 타입스크립트 적용해봤나요?   
> 아니요 ㅠ ES6 밖에 적용 안했습니다.  

Grunt는 무슨 용도로 썼나요?   
> minify 정도로만 썼습니다.  

서버사이드 렌더링을 어떤식으로 적용했나요?   
> react의 renderToString을 사용해서 노드에서 html 페이지를 만들게 했고, 컨테이너 클래스에 static 메서드를 만들어서 api를 먼저 조회한 후 render 메서드를 실행하게끔 했다.  
조회한 api 결과는 mobx라는 객체에 저장되어 클라이언트에서 공유 가능하게 했다.  

리액트를 왜 써야 하나?   
> 가장 큰 장점은 UI 모듈화, Virtual DOM이라고 생각한다.  
UI를 모듈화 할 수 있다. UI 모듈화는 개인적으로 혁명이라고 생각함. UI쪽에서는 객체지향적 프로그래밍이 불가능했었기 때문에..  
항상 똑같은 html 코드를 갖다 붙이고 거기에 서버랭귀지를 써가며 코딩했었다.  
이는 변화에 유연하지 못하다. UI가 바뀌면 해당 페이지를 다 수정해줘야 하지 않는가!  
게다가 리액트에서 제공하는 class + JSX의 구조는 매우 직관적이다.
그리고 또 좋은점은, Virtual DOM 이다.  
요즘은 대부분 SPA여서 DOM 조작이 매우 많은데, 일반적으로 그냥 DOM을 조작하게 되면 우리 눈에는 별다를게 없지만 브라우저는 html 트리를 다시 재해석하게 된다.  
Virtual DOM을 이용하면 DOM에 무언가 변경이 행해졌을떄 Virtual DOM이 최종적으로 DOM에 업데이트 하기전에 정말 변경되었는지 체크하고, 변경되었으면 이를 최종적으로 적용시키면서 연산횟수를 줄여준다. 그리고 실제 변경여부 체크를 VirtualDOM이 알아서해주기 때문에 우리는 이것에 신경쓰지 않아도 된다.  

리액트는 니가 도입했나?   
> 제가 도입하진 않았지만 열심히 퍼트렸다고는 할 수 있습니다.  

ES6의 특징은 뭔가?  
> 우리가 평소에 사용하던 자바스크립트는 ES5이고, ES6는 2015년에 나온 그 다음 버전이다.  
const, let, 구조화대입, class, 에로우펑션 등 다양한 문법이 생겼다.  

에로우 펑션의 가장 큰 장점은 뭘까?  
> 람다처럼 간결한 표현 가능, this 스코프의 변화  
https://www.zerocho.com/category/JavaScript/post/5740531574288ebc5f2ba97e  

리액트는 처음 도입한건가? 이때 리액트를 처음 쓴건가?  

리액트 외에 추가로 해보고 싶은건 있나?  
> 프론트엔드 쪽에는 Vue.js를 해보고 싶다.  

리액트를 사용하면서 UI 모듈화를 좀 하면서 했나?  
> 당연하다. UI 모듈화가 리액트의 가장 큰 핵심이라고 생각한다.  

리액트는 어느정도 공부하고 했나?  
> state, parent 관리랑 라이프사이클 정도 익힌 다음에 개발을 시작했다.  
대부분은 개발하면서 익혔다.  
그리고 타입스크립트 계속 언급되는데, 뭔지만 한번 봐놓자  
타입을 지정할 수 있으므로 안전한 코드를 작성 가능하다.  

jQuery는 거의 안썼겠네?    
> 최대한 안쓰려고 했다. jQuery DOM 선택자를 써버리면 리액트를 쓰는 이유가 모호해진다.  

## 서버
리눅스를 어느정도 하나? 프로젝트 배포할 수 있나? 신기술 설치할 수 있나?   
> 기본적인 명령어는 대부분 사용 가능하고, 프로젝트 배포나 새로운 프로그램 설치정도 할 수 있다.  
물론 구글신의 도움이 좀 있어야 하겠지만..ㅎ  

WAS에서 오류가 발생했을때, 응답하는 status 코드는 어떻게 해줘야 하나?  
> 

서버 쪽 유지보수도 했나?  
> 일단 기본적인 관리 했고, 왜냐면 배포를 직접 했기 때문.  
프로젝트 추가될 때 도메인 추가하고 아파치 톰캣 세팅하는것 정도까지 했었다.  

톰캣을 8.0에서 8.5로 올렸는데 소스가 안돌아가네요. 뭘 봐야할까요?  
>  

## DB
데이터 모델링 해봤나요?   
> 처음부터 해본적은 없고 추가기능 개발할 때 몇개씩 추가해본적은 있다.  

MySQL 실행계획에 대해서 말해달라  
> 옵티마이저가 작성한 쿼리를 어떻게 수행할 것인지 볼 수 있는 방법이다. 옵티마이저는 여러가지 통계정보를 참고하여 최적의 계획을 세운다. 쿼리가 실행되면 옵티마이저가 해석 가능하도록 SQL 파스트리로 변경되고, 옵티마이저는 그걸 읽어서 어떤 테이블 먼저 처리할지, 어떤 인덱스를 사용할지 등을 결정한다. 그리고 해당 쿼리를 수행하여 스토리지 엔진으로부터 데이터를 가져온다.  
우리는 실행계획을 보면서 쿼리가 올바른 방향으로, 최적화된 방향으로 수행되었는지 체크할 수 있다.  

실행계획에서 Using filesort가 나오면 뭘 의미하나?  
> ORDER BY에 인덱스를 사용하지 못했을 경우 나온다.(인덱스가 없는 컬럼으로 정렬 등)  
이럴 경우 조회결과를 메모리 버퍼에 복사한 뒤 퀵소트 알고리즘을 수행한다.  
쿼리를 튜닝하거나 인덱스를 생성해주는 것이 좋다.

실행계획에서 Using index가 나오면 좋은건가? 개선해야하나?  
> 데이터 파일을 읽지 않고 인덱스만 읽어서 처리할 수 있을 때.  
(인덱스 풀 스캔을 의미하는 것은 아님. range도 Using index 나옴.. ㅠ)  
딱히 개선해야 할 쿼리는 아니다.  

## Restful API
Restful api에 대해 설명해보세요.   
> 일단 REST라는건 HTTP URI를 리소스 지향 형태인 명사형으로 디자인하고, 각각의 행위를 HTTP Method로 표현하고, 사용되는 메세지는 HTTP Body에 json, xml등으로 전달하는 것을 말한다. 그리고 Restful API란 이런 REST의 특징을 지키면서 API를 제공하는 것을 말한다.  

REST에서 get, post, put, delete는 각각 무슨 역할을 하나요?   
> GET  조회, POST  등록, PUT  수정, DELETE  삭제  

Restful api의 장점에 대해 한줄정도로 얘기해봐라   
> 무상태성, http 표준을 그대로 사용하기 때문에 웹에서 사용하는 기존 인프라 그대로 활용 가능. 자체 표현 구조를 가진다. API 자체가 워낙 쉬워서 API만 보더라도 API를 이해 가능하다. 리소스와 메서드를 통해 무슨 행동을 하는지도 직관적으로 알 수 있다. 최소한의 문서만으로도 API를 이해할 수 있다.  

Restful api 만들때 힘든게 뭐였나?   
> URI 디자인. 가장 고민이 많이 필요하다. 직관적이어야 하고, 의미를 명확하게 표현해야 하기 때문.  

HTTP 스펙에서 리스폰스 코드에 정의된것 중에 아는것들 있나?  
> 500(Server Internal Error), 400(Bad Request), 403(Forbidden), 404(Not Found), 304(Not Modified-캐쉬사용)  

500 에러는 어떨때 발생하나?  
서버에서 오류가 났을때요? 어떤 오류든 상관없이 500이 발생하는 건가요?  
> WAS에서 오류가 발생했을 때.  

POST는 어떨때 사용하나요?  
> 뭔가를 등록할 때  

POST하고 GET하고 요청방식의 차이는 뭔가?  
> GET은 리소스를 조회하기 위해 사용하고, POST는 리소스 삽입 등 뭔가를 수행하기 위해 사용된다.  
GET은 HTTP Body가 없고, POST는 HTTP Body가 있다.  

POST인데 바디가 없을수도 있나?  
> 

## 기타
외부연동 api는 뭐뭐가 있나? 왜 모르나?   
> 저희 쪽에서는 많지 않았다. 그냥 T-Map이나 Google-Map, Naver-Blog-Api 정도 사용했다.  

외부로 나가는 api는 뭐뭐가 있었나?   
> 그 부분은 내 담당이 아니었다. 공유를 안해주셔서..  

식신 데이터는 어떻게 등록하나?  
보통 자기가 관리하는 데이터가 어디서 쓰이는지는 알지않나?   
> 내부 직원이 등록했다. 알바생도 썼고, 맛집 추천이라는 기능이 있어서 사용자도 등록 가능했다. 결과적으로 직원의 검수를 거쳐야 하긴 하지만.  

tdd 어느정도까지 해봤나요   
> 회사다닐때는 tdd까지는 못하고 단위테스트 만드는 것 정도까지 했었다.  
하지만 점점 tdd의 중요성을 깨닫고 이제는 항상 tdd로 개발해보려고 한다.  

그래서 tdd가 뭔데?   
> Test Driven Development라고 해서 테스트를 먼저 만들고 개발 코드를 만드는 식의 방법을 말한다.  
구현해야 할 기능을 파악하고, 목록을 작성한 뒤, 실패하는 테스트를 만든다.  
그리고 테스트가 성공하도록 메서드를 작성해나간다.  
이후 리팩토링 한다.  
이 과정을 계속해서 반복한다.  

신기술을 좋아하는거 같은데, 요즘 아는 신기술은 뭐가 있나요?   
> 백엔드 진영에서는 내가 아는건 MSA이고, 프론트엔드 진영에서는 Vue.js이다.  

MSA가 뭔데?   
> Micro Servie Architecture의 줄임말이고..  
기존의 프로젝트들은 하나의 프로젝트에 여러개의 서비스가 들어가있는 형태였는데, 이렇게 하다보면 안좋은 점이 하나의 서비스가 장애가 낫을 경우 다른 서비스에도 영향을 주게 되고, 하나의 서비스에서 변경사항이 있어도 전체 프로젝트를 다시 배포해야하는 상황이 발생하게 된다. 이렇게 하면 배포 한번한번이 너무 무거워진다.  
MSA란 이러한 프로젝트를 서비스별로 나눠서 각각의 작은 프로젝트들로 여러개를 만드는 방법을 말합니다. 그리고 젤 앞단에 API 게이트웨이라는 것을 둬서 전체적인 API요청을 받아서 각각의 프로젝트로 나눠서 요청해주는 부분이 있고요.  
이렇게하면 장점이 서비스 하나의 로직이 변경되면 그 프로젝트만 재배포하면 되니까 잦은 배포가 가능하고, 하나의 서비스가 장애가 나도 다른 서비스에 영향을 미치지 않게 된다.  
그리고 API 게이트웨이가 앞에 끼어있기 때문에 여기서 또 다른 성능향상을 도모할 수 있게 된다. 인증, 캐싱 등  

개발 분야에서 내 강점은?   
> 미래지향적이고 변화에 유연한 클린코드를 만드는데 고민을 많이 하는 편이다.  
하나의 클래스에는 딱 그 역할에 집중되게 프로그래밍 하는 것, 확장에 유연한 것.  
조그만 변화에 소스가 많이 수정되야하면 그 코드는 클린하지 않다고 말함.  

rx java에 대해 아나요?   
> 자바 진영에서 비동기 프로그래밍을 할 때 사용되는것.  

요즘 비동기가 핫한데, 비동기 아나요?   
> 보통 일반적인 동기 프로그램의 경우 순차적으로 일을 끝내나가는 방식인데, 비동기 프로그래밍의 경우 순차적으로 일을 진행하다가 비동기 메서드를 만나면 그부분은 실행시켜버려서 따로 작업흐름을 만들고, 계속 작업을 진행하는 방식.  
브라우저에서 네트워크 관련된 작업은 전부 비동기 방식으로 진행된다.  

그럼 본인의 프로젝트가 부족했다는 뜻인가요?   
> 그 당시에 리액트를 처음 사용했기 때문에 많이 부족했다. 이런 부분을 팀원들과 같이 고민하며 개선해나갔으면 좋았을텐데 라는 아쉬움이 들었다. 그렇다고 절대 팀원에 의존하는 것은 아니고, 그냥 팀워크의 힘이 개인의 힘보다 크다고 믿는 것이다.  

클린코드란 책 읽어봤나요? 클린코드가 뭔가요?  
> 미래지향적이고 변화에 유연한 소프트웨어를 만드는 방법.  

초기부터 프로젝트를 구성하신 적은 없나요?   
> 넹.. 항상 윗 선임들이 프로젝트 기본 구성을 해주시고, 거기에 내가 맞춰 개발하는 식이었다.  

트래픽이 어느 정도였는지 아나요?   
> 웹 1일 2만, 앱 1일 6만  

디자인패턴 뭐 아나요? 아는거 하나만 골라서 설명해보세요.   
> 1. 전략 패턴  A클래스가 B클래스에 의존적일때 B클래스의 구현체를 직접 사용하지 않고 구성(인터페이스)를 사용해서 확장에 유연하게끔 하는 방식.  
예를 들어 A라는 클래스에서 MySQL 디비 커넥션을 맺는 메서드를 가진 클래스를 사용하고 있었다고 하면, 이를 디비 커넥션을 맺는 인터페이스로 추상화 한 뒤 그것을 사용하게 한다.  
이렇게 하면 나중에 Oracle 커넥션을 맺는 클래스가 필요할 때 해당 인터페이스를 구현해서 전달해주기만 하면 되지, 기존 A클래스의 소스는 변경될 필요가 없다.  
1. 옵저버 패턴  신문 구독 시스템이랑 같다. 주체 객체(신문사)가 있고, 서브 객체(독자)들이 있는 형태이다. 구독하고 싶으면 신문사에 알려서 구독하고, 해지하고 싶으면 신문사에 알려서 해지한다. 주체 객체에서는 변경이 있을때 자신을 구독한 모든 클래스에게 변경 사항을 알려준다.  
1. 데코레이터 패턴  객체에 행동을 동적으로 덧붙이는 패턴이다. 어느 클래스 메서드의 앞뒤로 추가적인 기능을 덧붙이고자 할 떄, 해당 클래스를 일단 인터페이스랑 구현 클래스로 구분한다.  
그리고 추가할 기능을 정의하기 위해 클래스를 하나 만드는데 해당 인터페이스를 구현함과 동시에 그 인터페이스를 인스턴스 변수로 가지는 형태로 생성한다. 그리고 메서드를 오버라이드 하면서 추가기능을 앞뒤로 넣고, 중간에는 다시 인터페이스의 구현 메서드를 호출한다. 이렇게 함으로써 초기 클래스에 데코레이팅을 적용했다. 그리고 이런 클래스를 계속 추가해나가며 데코레이팅을 할 수 있다.  
1. 템플릿 메서드 패턴  부모 메서드에서 자식 클래스마다 구현이 달라져야 하는 부분에 대해서는 abstract 메서드로 만들어서 자신을 구현한 자식 클래스에서 해당 abstract 메서드를 구현하게 한다.  
1. 팩토리 메서드 패턴  객체를 생성하기 위해 인터페이스를 만들고, 실제 객체를 생성하는건 그 인터페이스를 구현한 자식 객체에게 맡기는 것.  
1. 빌더 패턴  매개변수가 많은 객체의 경우 텔리스코핑 방식으로 생성하게 되면 생성자 매개변수가 너무 많아지게 되고, 상황에 따라 생성자를 다 구현해야 하는 불편함이 있다. 그렇다고 자바빈즈 패턴으로 하자니 값이 무분별하게 수정될 수 있으므로 값들이 immutable 하지 않게 된다. 빌더 패턴의 경우 해당 클래스를 생성하는 클래스를 따로 만들어 직관적이게 객체에 값을 추가해나갈 수 있게 한다. 필수값과 선택값을 구분할 수 있으며, 객체가 생성되는 순간 해당 객체를 freezing 가능하다.  

다국어는 어떻게 적용했나?  
> 다국어 적용할 테이블 만듦(파파고api이용). api 호출 시 헤더에 langcode를 전달하도록 함.  
langcode가 ko가 아닐 경우 만들어둔 다국어 테이블과 left join.  
번역 데이터가 있을 경우 뿌려주고, 없을 경우 한국어가 나오도록 처리.  
클라이언트 페이지 컨텐츠의 경우 스프링 다국어처럼 메세지 파일을 따로 만들어서 처리했다.  
번역본이 없을 경우 번역기 때려서 저장하는 로직은 없었나?  

최근에 진행한 프로젝트가 어떤건지 설명해달라  
> 기존의 스프링 MVC로 되어있던 레거시 프로젝트를 새로 구축하는 프로젝트였고, 처음으로 API서버와 클라이언트 서버를 분리했다.  
API서버는 스프링부트, MyBatis, JPA를 사용했고 40~50프로 정도 개발에 참여했고,  
클라이언트는 리액트를 사용하여 거의 100프로 다 개발했다.  

식신 서비스에서 구버전이 스프링 프레임웤, 신버전은 스프링 부트. 아예 새로운 프로젝트?  
프로젝트는 누가 만든건지? 니가 직접 만든건지?  
> 다른분이 만들어주셨다. 항상 그런식으로 개발했다.  

관심있는 기술은 뭔가?  

클린코드란 뭔가?  

보통은 클린코드를 설명할 때, 문법적인 부분을 많이 설명한다.  
말씀하신 부분은 설계부분인 것 같다.  
그러면 본인이 지향하는 구조적인 설계는 무엇인가?  
> 각 클래스는 각자의 역할에 충실하고, 추상화도 잘 되어 있어 변화에 유연한 코드  

최근에 읽은 기술서적 중, 이거는 남들에게 추천할만하다 하는건 어떤게 있고 이유가 뭔가?  
> 자바 8 인 액션인데.. 이거 말고 딴걸로 할까  

마지막으로 하고싶은 말이나 질문은 뭔가?  
전반적인 기술셋은 뭔가요?  
기본적으로 웹개발자들이 백엔드 프론트 다 하고, 스프링, 노드, 제이쿼리, 자바, RDB, NoSQL  
서비스 상황에 맞춰 기술을 사용하고 있다.  
> 기업에 맞춰 질문을 변경해야 한다.  

요새 구직중에 뭔가 특별했던 경험 없었나?
> 거기서 특별할껀 별로 없고 그냥 이직 준비를 하면서 정리도 한번 싹 되고, 자기 자신도 돌아보게 된다.  
이 시간이 너무 필요하고 좋은 시간이라 생각한다.  

깃 코드 리뷰가 있던데 이건 누가한건지?  
> 자바 8 스터디할때 스터디원들 끼리 코드리뷰 하면서 로뜨 시스템을 구현했다.  

스터디 얼마나 하신건가? 실제로 프로젝트를 생성해서 하나?  
> 스터디는 2년정도 되었고, 평소에는 올사람 모여서 각자 개인공부하고 서로 원하는 주제가 있을 경우 같이 스터디한다.  
최근에는 Java8 스터디 했다.  

스터디 하시는 분들이 어떤 분들이신지?  
> 그냥 1~5년차 사이의 주니어 개발자들이 있다.  

배포 영역도 AWS 기능을 썼나?  
> 그냥 로드밸런서에서 뻇다 넣었다 하면서 수동으로 배포했다.  

알고리즘 스터디는 좀 하셨나요?  
> 초창기다. 친구랑 종만북을 읽으면서 스터디 하려고 계획중이다.  

디자인 패턴은 어느정도나 아나? 많이 써봤나?  
> 전략, 옵저버, 데코레이터, 빌더, 팩토리 메서드, 템플릿 메서드, 싱글턴 정도 알고 있다.  
그리고 많이 써보려고 한다.  

디자인 패턴에 대해 어떻게 생각하나?  
> 사람들이 엄청 많이 고민하고 만들어진거기 때문에 매우 좋다..  
하지만 또 무조건 좋은건 아니고 상황에 맞춰 써야한다  

스프링 DI 같은거에 종속되지 않고 디자인 패턴 써봤나?  
> 추상화를 자주 고민하는 편이라 전략패턴을 자주 사용한다.  
템플릿 메서드 패턴도 가끔씩 사용한다.  

FP는 공부좀 해봤나? 자바 8되면서 FP에 대해 알게되었나?  
> 

일급객체란 무엇인가? 일급객체의 특징이 뭔가?  
> 변수에 할당할수 있어야 하고, 메서드의 인자로 넘길수 있어야 하고, 리턴값으로 리턴할수 있어야 한다.  

AWS를 어느정도 까지 활용해봤나?  
EC2 인스턴스까지만 써봤나?  
> AWS 서버에서 스프링 부트 어플리케이션 받은 뒤, 빌드하고 띄웠다.  
EC2 인스턴스(micro.t2) 생성 후 띄우고, 보안그룹(ssh는 내 ip, https, http는 all) 지정.  
엘라스틱 ip등록 후 인스턴스에 연결(안하면 인스턴스가 재시작될때마다 ip가 변경되므로 도메인 연결이 불가능함)  
인스턴스 생성 시 pem키 파일을 받게 되는데, 그 파일을 ssh -i pem키 형태로 이용해서 ssh 접근 가능하다.  
RDS는 mariadb로 만들고(프리티어 이용 가능) 보안그룹을 생성해 접근을 제어한다.  
(ec2와 연결하려면 ec2 인스턴스 보안그룹의 id를 넣어줘야 한다)  

로그인은 어떻게 처리했나?  
> JWT로 구현했다.  
id, password로 로그인하면 JWT를 만들어 사용자가 받고, 이를 쿠키에 저장한 뒤 모든 API 통신에 사용하도록 했다.  
쿠키에 expire을 2시간으로 설정한 뒤 jwt를 세팅했다. 2시간 지나면 삭제되므로 재로그인 필요하다.  

JWT가 뭔가?   
> JSON Web Token의 약자로 일반적인 인증/인가 시스템에 사용되는 토큰이다.  
header, claim set, signature로 구성되며 이 3정보가 .으로 연결된 형태이다.  
header에는 어떤 방식으로 암호화 할지 등의 정보가 들어있고,  
claim set에는 만료시간, 사용자 정의 데이터가 들어있다. 이 2개는 base64로 인코딩되어 연결된다.  
그리고 마지막 signature는 위 2개의 base64 인코딩 데이터를 .으로 연결한 뒤 header에 있는 암호화 방식으로 암호화한다.  
JWT의 특징은 토큰이 데이터를 가진다는 점이다. 이로 인해 불필요한 API 조회를 막을 수 있다.  
하지만 claim set의 경우 암호화 없이 base64 인코딩이므로 간단히 디코딩해서 볼 수 있다. 민감한 정보는 넣지 말아야 한다.  

OAuth가 뭔가?   
> facebook이나 twitter같은데서 로그인 한 후 특정접근 권한만 가진 access token을 발급받는 것.  
클라이언트 쪽에서는 그 access token으로 facebook이나 twitter api를 이용하여 사용자 정보를 가져올 수 있다.  

싱글턴 써봤나? 싱글턴 패턴에 대해서 설명해봐라.  
> 인스턴스를 하나만 가지게 하는 패턴.  
생성자를 private으로 선언해서 외부에서 직접 생성하지 못하게 하고, 자신의 인스턴스를 static 변수로 가지고 있는다.  
그리고 getInstance 같은 메서드를 만들어두고, 사용자가 요청했을시에 인스턴스 변수가 있으면 그대로 돌려주고, 없으면 new로 생성하게 해서  
항상 같은 인스턴스를 사용하게 하는 패턴이다.  

프론트랑 백엔드 관심도 어느정도 되나?  
> 백엔드 7, 프론트 3. 근데 백엔드에 대한 의지를 막 밝히는게 좋을까?  
두개 다 해도 괜찮지 않나..ㅋ  

처음부터 프론트엔드를 했나? 첫회사에 대한 부분 정리가 좀 더 필요하다. 경력은 둘째회사에서 다 했다는게.. 애매하다   
> 첫 회사에서는 주로 공공기관 SM을 했기 때문에 백엔드나 프론트엔드를 제대로 만져볼 기회가 없었다.  
라는 얘기를 깔 필요는 없는거 같기도 하다.  

인텔리 제이 써봤나? 좋나? 이유가 뭔가?  
>  

말하고 있는 팀워크가.. 뭐 때매 잘 안된것 같나?  

개발자들이 폐쇄적이 되는 이유가 뭘까요?  
> 자기 코드 보여주기 싫어하고, 겁내하기 때문이 아닐까?  
아니면 그 문화의 좋은 점을 많이 느껴보지 않았다거나..  

식신은 개발자가 몇명이었나?  

프론트 엔드는 SPA 방식으로 개발했나?  

결제까지 붙어있는 시스템인가?  
실제로 식신 결제는 화이트 페이지로 넘기는건가?  
결제가 없다는거는 다른쪽 몰이랑 연동했다는건데, 어느쪽 몰인가?  
PG사 이름은 모르고요?  
프론트 엔드를 했다면, 상품 상세 페이지가 있으면 그 결제로 이동시켜야 하지 않나?  

프론트랑 백 선택하라면 뭘 할껀가?  

어제까지 읽은 책중에서 역순으로 5권만 불러주세요. 최근에 읽은 책으로  
> 실용주의 프로그래머, 헤드퍼스트 디자인 패턴, java 8 in action, 자바 ORM 프로그래밍, `토비의 스프링, TDD, real MySQL,

토비스프링 다봤다고 했는데, 다 봤다고 하면 안됬다..ㅋ;  

어댑터, 싱글톤, 빌더, 옵저버 빼고 나머지 6개 메서드만 더 불러주세요  
> 전략, 템플릿 메서드, 팩토리 메서드, 데코레이터, 프록시, 커멘드, 파사드..  

TDD 읽었으면 mockito나 power mock 써봤어요? 뭔지 아나?  
> 하나의 기능의 다른 기능에 의존적일때, 예를들어 회원 등업 여부를 체크하고 부합할 시 등업하고 메일을 쏴주는 메서드가 있다고 하면  
등업 여부체크 -> 등업만 체크하면 되지 메일을 쏘는 메서드 까지 테스트 할 필요 없다  
이럴경우 mailSender 인스턴스에 동작이 진행되게만 해주는 stub을 넣을 수 있다  

@BeforeClass
@Before
@Test
@Test
몇번씩 실행되는지 말해달라.  
> 1, 2, 1, 1  

스프링 3.1 읽었다고 했는데, Reactive 동영상 봤나?  

개발할 때 람다로 개발하나?  

자바가 제공하는 FunctionalInterface 3개만 불러주세요  
> Predicate, Consumer, Supplier, Function, UnaryOperator  

FunctionalInterface 많이 써봤어요?  
> 많이 못 써봤다  

Optional 쓰세요? 써봤어요?  
> 뭔지만 알고 못 써봤다. NULL 나올 수 있을 경우 null을 리턴하지 않고 Optional이라고 감싸진 객체로 리턴  

빌드는 뭘로해요? 메이븐으로 배포해요?  
제일 많이 배포해본 서버가 몇대에요?  
> 2대  

어떻게 배포했나?  
> jar로 말아서  

저희는 AWS를 쓰는데, 프로모션이나 마케팅 때문에 서버 100대로 늘릴때가 있다.  
어떻게 할건가?  
> CI 툴을 사용해야 한다. 젠킨스 같은.  

Jenkins로 만드는거 하면 시간을 얼마나 줘야하나?  
> 학습시간 포함해서 3주?  

JPA도 해보셨네요. n+1 조인 문제 어떻게 해결했나? 3가지만 불러달라.  
Lazy를 써봤다면서 n+1 조인 고민 안해봤어요?  
> fetch -> http://wonwoo.ml/index.php/post/975  
http://lng1982.tistory.com/298  

토비 책 다읽었다고 했으면 Security 안 읽었어요? 다 읽었다면서요?  
Authorization, Authentication 안했어요?  

스프링 프레임웤 = POJO 기반의 Pure 자바로 된 빈들의 집합체.  
싱글톤이 기본인데, 다른 빈 스코프 다른거 뭐있나?  
> prototype, session, request  

본인이 사용했던 포인트 컷좀 써달라. 어노테이션으로.  
포인트 컷 뭐 기억안나나?  
어떻게 유지보수 했는지도 보고 싶어서 그런다.  
> execution([접근제한자] 리턴타입 [클래스타입(패키지포함).]메서드이름(타입 | "..", ...) [throws 예외])  
```java
@Pointcut("execution(* com.siksin.hotplace.controller..*Controller.*(..))")
private void controller() {
}

@Pointcut("execution(String *(..))")
private void returnString() {
}

@Pointcut("execution(org.springframework.http.ResponseEntity *(..))")
private void returnResponseEntity() {
}

@Before("controller() && @annotation(accessRole)"){

}  
```

컴퓨터 사이언스 전공했나? 컴퓨터 사이언스 책 봤나?  

알고리즘 가장 간단한거 내볼게요.  
제가 1~1000부터 중에 생각해볼테니까, 아무 질문이나 하면서 제 숫자를 맞춰보세요.  
> 500보다 작은가? 250보다 작은가?  

바이너리 서치 시간 복잡도가 얼마인가?  
> O(logN) 할때마다 줄어드므로  

HTTP 메서드 활용하는데, CRUD에 해당하는 메서드들 다 불러달라.  
C = POST, R = GET, U = PUT/PATCH, D = DELETE  
OPTIONS, TRACE가 있다  

스웨거? API랑 문서랑 자동 동기화 되는건데, 써봤나?  

tps 기준 동접자가 몇명인가? 가장 많은 트래픽이 얼마였나?  

성능 튜닝을 해본적은 있나?  

톰캣에 배포하게 되면 start.sh를 볼 수 있지않나, 이니셜 메모리, xms 메모리 다 기억나나?  
거기서 쓰이던 GC모드 기억나나?  
니가 아는 GC는 뭔가?  
serial GC, parerral GC...  

JVM 메모리에 대한 일반적인 가비지 컬렉션을 말하는거 같은데.. 
에덴, 서바이벌1/2, 퍼머넌트, 마이너GC, 메이저GC, 풀GC 단어를 써서 GC 과정을 설명해봐라  

이펙티브 자바 읽어봤나?  

힙 덤프를 떠본적은 있나?  
> jmap으로 덤프뜨고 MAT로 분석했다  

DFS, BFS 설명해달라  

Collection 프레임워크의 대표적인 인터페이스와 대표적으로 구현한 애들을 말해달라.  
List, Set, Map(Map은 컬렉션이 아니라 컬렉션 프레임워크다)  
3가지의 특징을 알려달라  

LinkedList 사용해봤나?  
1 3 5 7 9 를 LinkedList를 넣고, 5와 7 사이에 11을 넣을테니 그걸 코드로 써달라  
Node temp = bottom;
while(temp.getNextNode() != null){
    if(temp.value == 5){
        Node node = new Node(11);
        node.setNextNode(temp);
        temp.setNextNode(node);
    }

    temp = temp.getNextNode();
}

리액트는 어디까지 해봤나?  
mobx도 스테이트 관리하는건가?  
> 서버 사이드렌더링이랑 코드 스플리팅 까지 했다  

코드 스플리팅은 어떻게 구현했나?  

ajax도 붙여봤나? ajax 붙여본 방식을 좀 말씀해주실 수 있나?  
api 호출하는 그 과정을 좀 설명해주실 수 있나?  
스테이트가 어떻게 움직이는지 등등..  

그렇게 하면 DOM은 몇번 렌더링되나?  

스크립트 사용할때는 프레임워크 리액트만 사용했나?  
웹팩 세팅은 직접 안했고?  

스크립트 태그안에 console.log(1)이 있으면
setTimeout이 있고 그 안에 console.log(3)이 있고,  
그 아래 console.log(2)가 있으면 1,3,2가 찍히는데, 왜 그런지 아나? 상세하게 설명 가능하나?  
function이 어디들어가고.. 어디 쌓이고..  

코드 짤 떄 use strict 쓰나? 그게 뭔지는 아나?  

==랑 === 차이점이 뭔지 아나?  
주로 어떻게 사용했나?  

javascript 짜다보면 this 컨텍스트가 바뀔때가 있는데,  
에로우 function을 안쓸떄는 어떻게 대처할 수 있을까? 위에서 담는거 말고 또 다른 방법이 있을까?  

Promise도 많이 다룰텐데, 간략하게 설명좀 부탁한다  

Promise.all도 다뤄봤나?  

프론트단에서 웹사이트 성능 최적화는 뭘 해봤나?  

자바스크립트 단에서 할 수 있는 성능 최적화는 뭐가 있나?  

스크립트 로드할 때 헤드에도 넣고, 바디 밑에도 넣을 수 있는데 어디넣었나?  

바디 아래에 넣은 이유가 있나?  

이미지 레이지 로딩 도입해봤나?  

접근성 작업 해봤나?  

타입 스크립트 해봤나? 뭔지는 아나?  

차이점이 뭔지 아나?  