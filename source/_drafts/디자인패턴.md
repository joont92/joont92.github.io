---
title: 디자인패턴
date: 2018-03-18 13:29:10
tags:
---

1. 전략패턴
인터페이스 : 기능에 대한 선언과 구현 분리, 기능 사용 통로

인터페이스 : 기능에 대한 선언
인터페이스 구현체 : 기능에 대한 구현

델리게이트 : 위임하다

클래스의 함수에서 다른 클래스의 기능을 호출하는 것

Strategy Pattern : 여러 알고리즘에 추상적인 접근점을 둬서 교체 가능하도록 함

public interface Weapon{
  public void attack();
}

public class Sword implements Weapon{
  @Override
  public void attack(){
    syso("sword attack")
  }
}

public class Gun implements Weapon{
  @Override
  public void attack(){
    syso("gun attack")
  }
}

public class GameCharacter{
  private Weapon weapon; // 접근점

  // 교체 가능
  public void setWeapon(Weapon weapon){
    this.weapon = weapon;
  }

  public void attack(){
    // 위임(delegate)
    weapon.attack();
  }
}

무기를 쉽게 추가할 수 있고, 추가되어도 GameCharacter 클래스는 변경되지 않는다.
사용하는쪽에서 필요에 따라 무기를 바꾸기 편리하다


2. 어댑터 패턴
어댑터 : 기계, 기구등을 다목적으로 사용하기 위한 부가 기구  

사전적 의미와 용도가 매우 비슷하다.  
만약 아래와 같은 킹왕짱 정렬 라이브러리가 있다고 하자.  
```java
public class VeryGoodSortLibrary{
  public <T> T[] buubleSort(T[] list){
    // sort really fast..
    return list;
  }
}
```
이 라이브러리를 사용하고 싶은데, 정렬을 원하는 리스트가 List 타입이라 저 라이브러리를 바로 사용할 수 없다.  
이럴 경우 어댑터 패턴을 사용할 수 있다.  
```java
public class VeryGoodSortLibraryAdaptor{
  public List<T> buubleSort(List<T> list){
    T[] array = list.toArray(new T[list.size()]); // 문법틀림 ㅋㅋㅋ

    VeryGoodSortLibrary lib = new VeryGoodSortLibrary();
    array = lib.bubbleSory(array);

    return Arrays.asList(array);
  }
}
```
VeryGoodSortLibrary를 바로 사용할 수 없으니 VeryGoodSortLibraryAdaptor 어댑터를 중간에 두고  
호출하게 하는 것이다.  


<!-- more -->
