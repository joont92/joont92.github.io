---
title: '디자인패턴'
date: 2018-03-18 13:29:10
tags:
---

# 전략패턴
인터페이스 : 기능에 대한 선언과 구현 분리, 기능 사용 통로

인터페이스 : 기능에 대한 선언
인터페이스 구현체 : 기능에 대한 구현

델리게이트 : 위임하다

클래스의 함수에서 다른 클래스의 기능을 호출하는 것

Strategy Pattern : 여러 알고리즘에 추상적인 접근점을 둬서 교체 가능하도록 함

```java
public interface Weapon{
  public void attack();
}

public class Sword implements Weapon{
  @Override
  public void attack(){
    syso("sword attack")
  }
}

public class Gun implements Weapon{
  @Override
  public void attack(){
    syso("gun attack")
  }
}

public class GameCharacter{
  private Weapon weapon; // 접근점

  // 교체 가능
  public void setWeapon(Weapon weapon){
    this.weapon = weapon;
  }

  public void attack(){
    // 위임(delegate)
    weapon.attack();
  }
}
```

무기를 쉽게 추가할 수 있고, 추가되어도 GameCharacter 클래스는 변경되지 않는다.
사용하는쪽에서 필요에 따라 무기를 바꾸기 편리하다


# 어댑터 패턴
어댑터 : 기계, 기구등을 다목적으로 사용하기 위한 부가 기구  

사전적 의미와 용도가 매우 비슷하다.  
만약 아래와 같은 킹왕짱 정렬 라이브러리가 있다고 하자.  
```java
public class VeryGoodSortLibrary{
  public <T> T[] buubleSort(T[] list){
    // sort really fast..
    return list;
  }
}
```
이 라이브러리를 사용하고 싶은데, 정렬을 원하는 리스트가 List 타입이라 저 라이브러리를 바로 사용할 수 없다.  
이럴 경우 어댑터 패턴을 사용할 수 있다.  
```java
public class VeryGoodSortLibraryAdaptor{
  public List<T> buubleSort(List<T> list){
    T[] array = list.toArray(new T[list.size()]); // 문법틀림 ㅋㅋㅋ

    VeryGoodSortLibrary lib = new VeryGoodSortLibrary();
    array = lib.bubbleSory(array);

    return Arrays.asList(array);
  }
}
```
VeryGoodSortLibrary를 바로 사용할 수 없으니 VeryGoodSortLibraryAdaptor 어댑터를 중간에 두고  
호출하게 하는 것이다.  

# 템플릿 메서드 패턴
알고리즘의 구조를 메서드에 정의하고, 하위 클래스에서 알고리즘 구조의 변경없이 알고리즘을 재정의 하는 패턴  

1. 알고리즘을 여러 단계로 나눈다
2. 나눠진 알고리즘의 단계를 메서드로 선언한다
3. 나눠진 알고리즘을 수행할 템플릿 메서드를 만든다
4. 하위클래스에서 나눠진 메서드들을 구현한다.

![img](https://cloud2.zoolz.com/MyComputers/Images/Image.aspx?q=bT00MDcyNDcma2V5PTIwMjQ2MTcyMTkmdHlwZT1sJno9MjAxOC8wNC8wMSAwODo1NQ==)

```java
public abstract class AbstractTest{
  // 변경가능한 내부 메서드들
  // 외부에 노출되지 않아야 하고, 자식클래스가 구현해야 하므로 protected abstract
  protected abstract void aa();
  protected abstract void bb();
  protected abstract void cc();

  // template method(일정한 프로세스를 가짐)
  public void call(){
    aa();
    bb();
    cc();
  }
}

public class DefaultTest extends AbstractTest{
  @Override
  protected abstract void aa(){
    // aa
  };
  @Override
  protected abstract void bb(){
    // bb
  };
  @Override
  protected abstract void cc(){
    // cc
  };
}

public class Main{
  public static void main(String[] args){
    AbstractTest test = new DefaultTest();

    test.call();
  }
}
```

# 팩토리 메서드 패턴  
객체를 직접 만들지 않고 객체를 만들어주는 팩토리(공장)을 정의  
![img](https://cloud2.zoolz.com/MyComputers/Images/Image.aspx?q=bT00MDcyNDcma2V5PTIwMjQ2MTcyMjImdHlwZT1sJno9MjAxOC8wNC8wMSAwODo1NQ==)  
여기서는 Creator가 팩토리 메서드가 됨.  
현재는 템플릿 메서드 패턴이 추가된 그림이다. 실제로는 Creator와 Product의 관계 정도만 보면 된다.
create를 통해 Product 오브젝트를 생성할 수 있고, 각 클래스들을 상속할 수 있다.  
<http://jdm.kr/blog/180>  
```java
public class Item{

}

public class Factory{
  // factory method
  public Item create(){
    Item item;

    // ...

    return item;
  }
}

public class Main{
  public static void main(String[] args){
    Factory factory = new Factory();

    Item item = factory.create();    
  }
}
```
팩토리 메서드는 템플릿 메서드의 형태롤 가질 수 있음

# 싱글톤 패턴  
클래스의 인스턴스를 하나만 생성하는 패턴  
```java
public class Singleton{
  private static Singleton instance;

  private Singleton(){}; // new 생성 막음

  public static Singleton getInstance(){
    if(instance == null){
      instance = new Singleton();
    }

    return instance;
  }

  private int num = 5;
  public int getNum(){
    return nul
  }
  public void setNum(int num){
    this.num = num;
  }
}

public class Main{
  public static void main(String[] args){
    Singleton singleton1 = Singleton.getInstance();
    Singleton singleton2 = Singleton.getInstance();

    // 5, 5
    sout(singleton1.getNum());
    sout(singleton2.getNum());

    // 10, 10
    singleton1.setNum(10);
    sout(singleton1.getNum());
    sout(singleton2.getNum());

    // 20, 20
    singleton2.setNum(20);
    sout(singleton1.getNum());
    sout(singleton2.getNum());
  }
}
```

# 프로토타입 패턴
생산 비용이 높은 인스턴스를 복사를 통해서 쉽게 생성할 수 있도록 하는 패턴  
간단하게 말해 new를 통해 객체를 생성하지 않고, clone을 통해 생성된 객체의 복사본을 받는 것이다.  
아래와 같은 상황에 사용될 수 있다고 한다.  
1. 종류가 너무 많아 클래스로 정리되지 않는 경우
2. 클래스로부터 인스턴스 생성이 어려운 경우
3. framework와 생성할 인스턴스를 분리하고 싶은 경우  

사실 아직 실질적으로 와닿지는 않는다. 2번은 좀 와닿긴 하네..  
그 외에는 생성 비용이 높은 인스턴스의 경우? ㅋㅋ  

객체의 복사
최상위 클래스인 Object 클래스는 clone이라는 메서드를 가지고 있고, 이는 객체를 복사해주는 메서드이다.  
이 메서드가 호출되려면 클래스에 Cloneable 인터페이스를 구현해야 한다.  
구현하지 않을 시 CloneNotSupportedException이 발생한다.  
근데 기본적으로 Object의 clone은 shallow copy(얕은 복사)를 진행한다.  
이는 객체는 복사되나, 내부 필드는 primitive 까지만 복사된다.  
즉 내부 필드가 참조형일 경우 주소값만 복사되므로 같은곳을 바라보게 된다.  
이에 대한 방안으로 deep copy(깊은 복사)를 진행하는데, 이는 clone을 오버라이드 하는 곳에서 각자 복사를 진행해주는 방식이다.  
```java
@Override
public Object clone() throws CloneNotSupportedException {
    MyNumber myObj = super.clone();
    myObj.numbers = (int[]) numbers.clone();
    return myObj;
  }
```
이런식으로 말이다.  
위와 같이 배열은 기본적으로 Cloneable을 구현하고 있어서 괜찮으나,  
오브젝트를 클론할 경우에는 해당 오브젝트가 Cloneable을 구현하고 있는지 확인해야 한다.  
```java
public Object clone() throws CloneNotSupportedException {
  MyClass myObj = super.clone();
  myObj.data = (MyData) data.clone(); // data가 Cloneable을 구현하지 않았으면 CloneNotSupportedException 발생
  return myObj;
}
```
Collection의 경우 가장 주의해야 하는데, 기본적으로 Collection 객체들은 Cloneable을 구현하고 있어 복사가 가능하다.  
하지만 만약 자료구조의 내부 클래스들 중에 Cloneable을 구현하지 않은 오브젝트가 있다면 동일하게 CloneNotSupportedException이 발생한다.  
<http://javacan.tistory.com/entry/31>  

# 빌더 패턴
복잡한 단계가 필요한 인스턴스 생성을 빌더 패턴을 통해 구현할 수 있다.  
용도는 팩토리 메서드 패턴과 동일하나 방식이 좀 다르다.  
```java
class ComputerBuilder(){
  private Computer computer;

  public ComputerBuilder(){
    computer = new Computer("default cpu", "default ram", "default storage");
  }

  public static ComputerBuilder start(){
    ComputerBuilder builder = new ComputerBuilder();    
    return builder;
  }

  public ComputerBuilder setCpu(String cpu){
    computer.setCpu(cpu);
    return this;
  }

  public ComputerBuilder setRam(String ram){
    computer.setRam(ram);
    return this;
  }

  public ComputerBuilder setStorage(String storage){
    computer.setStorage(storage);
    return this;
  }

  public Computer build(){
    return this.computer;
  }
}

class Main(){
  public void static main(String[] args){
    Computer computer = ComputerBuilder.start()
                        .setCpu("i7")
                        .setRam("8g")
                        .build();
  }
}
```
팩토리 패턴과 차이점은 체이닝을 통해 속성을 추가해나갈수 있다는 점?  
팩토리 패턴은 한번에 다 해야하는것에 비해..


# 추상 팩토리 패턴
많은 수의 연관된 서브 클래스를 특정 그룹으로 묶어 한번에 교체할 수 있도록 만든 디자인 패턴
```java
interface BikeFactory{
  Wheel createWheel();
}

interface Wheel{

}

class GTBikeFactory implements BikeFactory{
  Wheel createWheel(){
    return new GTWheel();
  }
}

class GTWheel implments Wheel{

}

public class Main{
  public static void main(String[] args){
    BikeFactory bike = new GTBikeFactory();
  }
}
```

// 어댑터, 팩토리/추상 팩토리, 빌더 패턴

# 브릿지 패턴
기능 부분과 구현 부분의 분리  
delegate + strategy pattern..?  

```java
class MorseCode{
  // strategy
  MorseCodeFunction mcf;
  public MorseCode(MorseCodeFunction mcf){
    this.mcf = mcf;
  }

  public void dot(){
    // delegate
    mcf.dot();
  }

  public void dash(){
    // delegate
    mcf.dash();
  }

  public void space(){
    // delegate
    mcf.space();
  }
}

class MorseCodeFunction{
  public dot();
  public dash();
  public space();
}

class DefaultMorseCodeFuntion implements MorseCodeFunction{
  // implementaion
}
class SoundMorseCodeFuntion implements MorseCodeFunction{
  // implementaion
}
class FlashMorseCodeFuntion implements MorseCodeFunction{
  // implementaion
}

class Main{
  public void static main(Stirng[] args){

    // strategy + delegate
    MorseCode ms = new MorseCode(new DefaultMorseCodeFunction());
    MorseCode ms = new MorseCode(new SoundMorseCodeFunction());

    // ms. ~~~
  }
}
```

# 컴포지트 패턴
객체와 객체의 그룹을 구분없이 하나의 인터페이스로 다룰 수 있게 한다.  
클라이언트가 개별 객체와 객체 그룹을 차이없이 사용하고 싶을 떄 사용한다.  
대표적으로 파일시스템이 있다.  

```java
class Component{
  private String name;
  private String type;

  public Component(String name, String type){
    this.name = name;
    this.type = type;
  }
}

// leaf component
class File extends Component{
  public File(String name, String type){
    super(name, "F");
  }
}

// composite component
class Folder extends Component{
  private List<Component> list = new ArrayList<>();

  public Folder(String name, String type){
    super(name, "D");
  }

  public boolean add(Component component){
    return list.add(component);
  }

  public boolean remove(Component component){
    return list.remove(component);
  }
}
```
클라이언트에서는 동일하게 Component 인터페이스로 접근할 수 있음  

<!-- more -->
