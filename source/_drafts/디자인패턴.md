---
title: 디자인패턴
date: 2018-03-18 13:29:10
tags:
---

1. 전략패턴
인터페이스 : 기능에 대한 선언과 구현 분리, 기능 사용 통로

인터페이스 : 기능에 대한 선언
인터페이스 구현체 : 기능에 대한 구현

델리게이트 : 위임하다

클래스의 함수에서 다른 클래스의 기능을 호출하는 것

Strategy Pattern : 여러 알고리즘에 추상적인 접근점을 둬서 교체 가능하도록 함

public interface Weapon{
  public void attack();
}

public class Sword implements Weapon{
  @Override
  public void attack(){
    syso("sword attack")
  }
}

public class Gun implements Weapon{
  @Override
  public void attack(){
    syso("gun attack")
  }
}

public class GameCharacter{
  private Weapon weapon; // 접근점

  // 교체 가능
  public void setWeapon(Weapon weapon){
    this.weapon = weapon;
  }

  public void attack(){
    // 위임(delegate)
    weapon.attack();
  }
}

무기를 쉽게 추가할 수 있고, 추가되어도 GameCharacter 클래스는 변경되지 않는다.
사용하는쪽에서 필요에 따라 무기를 바꾸기 편리하다


2. 어댑터 패턴
어댑터 : 기계, 기구등을 다목적으로 사용하기 위한 부가 기구  

사전적 의미와 용도가 매우 비슷하다.  
만약 아래와 같은 킹왕짱 정렬 라이브러리가 있다고 하자.  
```java
public class VeryGoodSortLibrary{
  public <T> T[] buubleSort(T[] list){
    // sort really fast..
    return list;
  }
}
```
이 라이브러리를 사용하고 싶은데, 정렬을 원하는 리스트가 List 타입이라 저 라이브러리를 바로 사용할 수 없다.  
이럴 경우 어댑터 패턴을 사용할 수 있다.  
```java
public class VeryGoodSortLibraryAdaptor{
  public List<T> buubleSort(List<T> list){
    T[] array = list.toArray(new T[list.size()]); // 문법틀림 ㅋㅋㅋ

    VeryGoodSortLibrary lib = new VeryGoodSortLibrary();
    array = lib.bubbleSory(array);

    return Arrays.asList(array);
  }
}
```
VeryGoodSortLibrary를 바로 사용할 수 없으니 VeryGoodSortLibraryAdaptor 어댑터를 중간에 두고  
호출하게 하는 것이다.  

3. 템플릿 메서드 패턴
알고리즘의 구조를 메서드에 정의하고, 하위 클래스에서 알고리즘 구조의 변경없이 알고리즘을 재정의 하는 패턴  

1. 알고리즘을 여러 단계로 나눈다
2. 나눠진 알고리즘의 단계를 메서드로 선언한다
3. 나눠진 알고리즘을 수행할 템플릿 메서드를 만든다
4. 하위클래스에서 나눠진 메서드들을 구현한다.

![img](https://cloud2.zoolz.com/MyComputers/Images/Image.aspx?q=bT00MDcyNDcma2V5PTIwMjQ2MTcyMTkmdHlwZT1sJno9MjAxOC8wNC8wMSAwODo1NQ==)

```java
public abstract class AbstractTest{
  // 변경가능한 내부 메서드들
  // 외부에 노출되지 않아야 하고, 자식클래스가 구현해야 하므로 protected abstract
  protected abstract void aa();
  protected abstract void bb();
  protected abstract void cc();

  // template method(일정한 프로세스를 가짐)
  public void call(){
    aa();
    bb();
    cc();
  }
}

public class DefaultTest extends AbstractTest{
  @Override
  protected abstract void aa(){
    // aa
  };
  @Override
  protected abstract void bb(){
    // bb
  };
  @Override
  protected abstract void cc(){
    // cc
  };
}

public class Main{
  public static void main(String[] args){
    AbstractTest test = new DefaultTest();

    test.call();
  }
}
```

4. 팩토리 메서드 패턴  
객체를 직접 만들지 않고 객체를 만들어주는 팩토리(공장)을 정의
[img](https://cloud2.zoolz.com/MyComputers/Images/Image.aspx?q=bT00MDcyNDcma2V5PTIwMjQ2MTcyMjImdHlwZT1sJno9MjAxOC8wNC8wMSAwODo1NQ==)  
여기서는 Creator가 팩토리 메서드가 됨.  
```java
public class Item{

}

public class Factory{
  // factory method
  public Item create(){
    Item item;

    // ...

    return item;
  }
}

public class Main{
  public static void main(String[] args){
    Factory factory = new Factory();

    Item item = factory.create();    
  }
}
```
팩토리 메서드는 템플릿 메서드의 형태롤 가질 수 있음

5. 싱글톤 패턴  
클래스의 인스턴스를 하나만 생성하는 패턴  
```java
public class Singleton{
  private static Singleton instance;

  private Singleton(){}; // new 생성 막음

  public static Singleton getInstance(){
    if(instance == null){
      instance = new Singleton();
    }

    return instance;
  }

  private int num = 5;
  public int getNum(){
    return nul
  }
  public void setNum(int num){
    this.num = num;
  }
}

public class Main{
  public static void main(String[] args){
    Singleton singleton1 = Singleton.getInstance();
    Singleton singleton2 = Singleton.getInstance();

    // 5, 5
    sout(singleton1.getNum());
    sout(singleton2.getNum());

    // 10, 10
    singleton1.setNum(10);
    sout(singleton1.getNum());
    sout(singleton2.getNum());

    // 20, 20
    singleton2.setNum(20);
    sout(singleton1.getNum());
    sout(singleton2.getNum());
  }
}
```

<!-- more -->
