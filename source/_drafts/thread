- 쓰레드는 메모리, 파일 핸들 같은 프로세스에 할당된 자원을 공유한다
- 쓰레드는 각기 별도 프로그램 카운터, 스택, 지역변수를 갖는다
- 현대 운영체제의 대부분은 프로세스가 아니라 스레드를 기본 단위로 CPU를 스케줄링한다
- 의도적으로 설정하지 않는 한 스레드는 다른 스레드와 상관없이 비동기적으로 실행된다
- 쓰레드로 분리하기만 하면 멀티 프로세서 시스템에서 자연스럽게 하드웨어 병렬성을 이용 가능하다
  - 프로세서가 2개인 시스템에서 싱글 스레드 프로그램을 돌리면 CPU 자원의 50%를 낭비하는 셈이다
- 단일 프로세서라도 멀티 쓰레드를 사용하면 성능이 향상된다
  - 단일 쓰레드일 경우 쓰레드 하나가 동기 I/O를 하게되면 이를 계속 기다려야 하기 때문이다
- 쓰레드는 서로 같은 메모리 공간을 공유하고 동시에 실행되기 때문에 동기화 문제를 항상 신경써야 한다
- 쓰레드간 컨텍스트 스위칭, 공유 데이터 접근을 위한 동기화 등을 사용하다가 성능이 낮아질수도 있다

- 멀티 쓰레드로 작성되는 코드는 모두 thread-safe 하게 작성해야 한다
- thread-safe 한 코드를 작성하는 것은 근본적으로는 공유되고 변경될 수 있는 상태에 대한 접근을 관리하는 것이다
- thread-safe 하도록 나중에 고치는 것보단 처음부터 thread-safe 하게 설계하는 편이 훨씬 쉽다
  - 나중에 변경하고자 할때는 설계를 상당히 많이 고쳐야 할 가능성이 높다
- 캡슐화와 thread-safe? 성능?
- thread-safe한 클래스의 특징
  - 상태 변수가 쓰레드간에 공유되지 않거나
  - 상태 변수를 변경할 수 없도록 만들거나
  - 상태 변수에 접근할때는 항상 동기화를 사용한다
- 여러 쓰레드가 클래스에 접근할 때, 쓰레드를 어떻게 스케줄링하든 호출하는 쪽에서 추가적인 동기화나 조율이 필요없이 정확하게 동작한다면 해당 클래스는 thread-safe 하다고 할 수 있다
  - 순차적이든, 동시든 어떤 작업들을 행해도 해당 인스턴스를 잘못된 상태로 만들 수 없어야 한다
- thread-safe 한 클래스는 클라이언트에서 별도 동기화 할 필요가 없도록 동기화 기능도 캡슐화 한다

- 상태(인스턴스 변수, static 변수)가 없는 객체는 항상 thread-safe 하다
- 경쟁조건 : 둘 이상이 하나의 공유 자원에 동시에 접근해서 발생하는 문제점(유효하지 않은 값을 참조해서 다음에 뭘 할지를 결정)
  - 흔한패턴 : 싱글톤 패턴의 lazy init
  - 경쟁조건은 연산이 단일연산이 아니라서 발생하는 것이다
    - num++ 도 단일 연산이 아니다
  - 경쟁조건은 이 자체로 심각한 문제를 일으킬 수 있다
- 경쟁조건을 피하기 위해 AtomicXXX 같은 변수를 사용할 수 있다
- 상태변수로 Atomic을 2개 이상 가지면 결국 또 경쟁조건 발동의 대상이 된다
- 부모가 있는 객체의 경우 락이 걸릴 때 부모 인스턴스까지 같이 락을 건다
- 자바는 락 재진입성을 제공하므로 재귀함수 같은 연산을 사용하더라도 데드락이 걸리지 않는다
- synchronized 와 변수는 사실 직접적 관계는 없다
  - 변수를 동기화 하고 싶다면 해당 변수에 접근하는 모든 부분을 다 동기화해야한다
- 메서드를 전부 동기화하였더라도 그 동기화 메서드들을 여러개 사용하는 부분은 추가적인 동기화가 필요하다
- 서블릿 메서드 자체에 동기화를 걸면 안전성은 확보할 수 있지만, 성능이 너무 떨어지게 된다(1번에 1개만 실행가능해지므로)
- 락을 얻는 작업만으로도 어느 정도의 부하가 따른다
- 단순성(전체 메서드 동기화)와 성능(최대한 짧은 부분만 동기화) 사이에 균형을 맞춰야한다
  - 성능을 위해 단순성을 마구 훼손하고픈 유혹을 버려야한다
- 오래걸리는 계산 작업, 네트웍 작업 등이 있는 구간에서는 가능한 한 락을 잡지 말아야한다