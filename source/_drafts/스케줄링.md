프로세스 = 응용프로그램  
스케쥴링 = 여러가지 응용 프로그램을 시간순서에 따라 CPU에 배치하는 방법  

- 배치처리 시스템
큐 방식과 비슷하다(FIFO)  
여러 프로그램을 순차적으로 실행시킴  
> app1이 12시간, app2가 30분 걸린다면 배치처리 시스템에선 app2가 끝날때까지 12시간 30분이 걸린다  
하나씩 등록해서 처리하는 방식이므로 멀티 태스킹이 불가능하다  

시분할 시스템, 멀티 프로그래밍은 결과적으로 하나의 기술로 이루어져 있고, 혼용해서 사용된다  
여러 프로그램들을 시간 단위로 쪼개서 사용한다  
1번 프로그램에서 뭔가 입력을 해도, 다른 프로그램이 끝날떄 까지 기다려야 하는것이 아니므로 멀티 태스킹이 가능하다(응답시간이 짧기 때문에)  
응답시간이 굉장히 짧아지려면 시간을 굉장히 잘개 나누어서 분배해야 한다  

MP3 음악을 들으며 문서작성을 한다  
시분할 시스템에서 MP3 프로그램을 실행하는 시점에  
다른 프로그램들이 수행될 시간만큼 음악을 들을 수 있도록 음악을 미리 만들어 놓는다  
시분할 단위가 매우 짧기 때문에 사람이 인지하지 못한다(10 ~ 20ms 단위로 프로그램이 바뀌므로 사람이 잘 인지하지 못함)  

보다시피 멀티태스킹 기술이 시분할 시스템의 기술과 동일하다  

멀티 태스킹이 시분할 시스템을 이용해서 구현한 것이고,  
멀티 프로세싱은 CPU를 여러개 사용하면서 성능을 극대화 한것  

---

저장매체는 CPU 시간으로 보면 굉장히 느린 매체이다  

응용프로그램이 실행하다가 다른 작업(파일 읽기, 프린팅 등)을 하는 경우가 많은데, 응용프로그램이 그 instruction이 끝날때까지 아무것도 못하고 기다리지 않는 이유는 멀티 프로그래밍 때문이다  

open("data.txt") 로 파일 오픈여부를 알려면 저장매체있는 파일에 접근해야 한다.  
어플리케이션에 `파일을 읽어서 fd를 얻어와!` 라고 명령을 주고, 이 결과를 무작정 기다리게 되면(blocking) CPU는 해당 명령이 끝날때까지 놀게된다.  
그러므로 이 시간동안에는 다른 응용프로그램을 실행해서 CPU가 노는 시간이 없게 한다(== 멀티 프로그래밍의 원리)  
이런 기술이 있기 때문에 멀티 태스킹이 가능한것이다.  

프로그램에서 하드디스크에 접근하는 로직이 있다면, cpu가 그 응용프로그램을 잡고 있기보단 그 instruction이 수행되는 동안 다른 응용프로그램의 로직을 수행하는 것이 더 효율적이다.  
그러므로 `CPU가 직접 가서 데이터를 가져오는 행위를 사용하지 않고`, DMA라는 애한테 해당 작업을 요청하고, 그 작업이 완료되면 DMA가 CPU에 인터럽트를 거는 방식으로 동작한다  
CPU와 디스크의 속도도 너무 차이나기 떄문에 CPU가 디스크에 직접 접근하는건 매우 손해이다.  
> 최신 컴퓨터 시스템/운영체제에서는 CPU가 모든 처리를 관장하면, 아까우니까, 디스크, 메모리등등은 DMA등과 같은 별도 칩이 다루고, CPU는 코드 실행에 집중토록 해서, 효율을 높였다. 로 이해하는게 좋다.  

---

프로세스  
- 프로세스 == 실행중인 프로그램  
- 응용 프로그램 != 프로세스  
    - 응용프로그램은 여러개의 프로세스로 이루어질 수 있다  
    - 여러개의 프로세스가 상호작용을 하면서 실행될 수도 있음(유닉스)  
    - IPC 기법 : 프로세스끼리 통신하는 방법  
- 메모리에 올려져서 실행중인 프로그램  
- 폰노이만 구조  
    - 메모리에 코드가 올려지고, CPU가 그걸 한줄씩 읽어서 실행하는 방식  
- 작업, task, job 이라는 말로 혼용 가능  

FIFO 스케줄러  
- 들어온 애들 순서대로 실행한다(실행시간 상관없이)  
- 자료구조 Queue 사용  

최단작업 우선(SJF) 스케줄러  
- 이상적인 알고리즘  
    - 프로세스들의 실행시간을 예측할 수 없으니까  

---

시간에 굉장히 민감한 프로세스들을 실행시켜야 하는 경우  
RTOS는 간단하다  
복잡하면 정확한 프로그램 시작, 완료 시간을 보장하기 힘들어지기 때문이다  
SJF 처럼 실행시간을 정확하게 알수도 있다  
RTOS의 Real Time은 내가 생각하는 것과 조금 달랐다.  
<https://ppua.tistory.com/entry/%EC%8B%A4%EC%8B%9C%EA%B0%84-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-RTOS%EC%9D%98-%EC%9D%B4%ED%95%B4>  

- priority based
우선순위를 어떻게 지정한다는거야?  
정적으로 우선순위를 매긴다는건 현실적으로 좀 안맞을 수 있으니, 동적 우선순위를 사용할 수 있다  
e.g. 오래된 프로세스는 우선순위를 높게 설정해놓아서 CPU가 요청할 때 바로 사용할 수 있게 한다던가  

- round robin
시분할 시스템을 기본으로 함  
프로세스 하나 받고 정해진 시간만큼 돌고, 젤 뒤의 큐로 넘겨버린다  

프로세스 큐에 있는 프로세스들을 정해진 시간만큼 분할해서 Round Robin Queue에 넣어둔다.  

---

각 프로세스의 wait 시간은 모두 파일 읽기라고 가정한다.  
프로세스의 wait 시간에 wait 되지 않은 프로세스들을 들고와서 CPU에서 돌린다. 이렇게 함으로써 CPU 사용량을 극대화 할 수 있다.  

이렇게 구성할려면 스케줄러가 프로세스들을 파악할 수 있어야하는데, 이떄 중요한것이 프로세스 상태이다.  
어느시점에 어느 프로세스를 넣어줄까 에 프로세스 상태가 중요하게 사용된다(스케줄러에게)  

# 프로세스 상태  
3가지 상태가 가장 중요하다  
- block state : wait 상태  
파일읽기가 끝나면 process에 인터럽트 하게되고, 그때 프로세스의 상태가 바뀜  
러닝 상태로 변경되는 것이 아니라(그건 스케줄러가 하는 것), 레디 상태로 변경된다  
- running state : CPU에서 실행되고 있는 상태, 기존의 running 상태 프로세스는 block이 되거나 ready가 됨. cpu가 1개라면 running state에 있는 프로세스는 최대 1개일 것이다  

- 생성 상태 : 생성 중 이라는 뜻의 짧은 상태  
- 종료 상태 : 프로세스가 잡고있는 시스템 리소스를 풀어주기 위해 일정시간이 필요해서, 종료 상태가 있는 것이다(바로 종료되는것이 아닌)  

# 프로세스 스케줄링 방법
여러개의 프로세스가 모두 ready 상태일 때 cpu는 어떻게 프로세스를 선택할 수 있을까?  
- FIFO 스케줄러   
큐 자료구조를 사용한다  
3개의 큐를 둔다(Ready State Queue, Running State Queue, Block State Queue)  
프로세스가 아무리 동시다발적으로 실행되더라도 시간차가 있기때문에 큐에 순서대로 넣는 것이 가능하다  
그러므로 CPU는 Ready State Queue에 있는 첫번째 큐를 꺼내와서 먼저 실행하게 된다  
이를 Running State에 올리고 실행하고,  
일정 시간이 지나면 이 프로세스를 Ready State의 가장 뒤로 넣고,  
Ready State에서 하나 pop해서 Running State에 등록 후 실행한다  

- 만약 CPU가 프로세스를 실행중에 wait가 필요한 operation을 수행한다면 ready state 대신 block state에 들어가게 된다  
- block state에 들어간 프로세스는 CPU의 실행 대상이 아니다  
- wait operation이 끝나게 되면 스케줄러에 이벤트를 발생시키게 되고, 프로세스는 ready state로 다시 돌아가서 스케줄러의 실행 대상이 된다  
- 만약 block state 대기시간이 끝나지 않았는데 ready state의 모든 작업을 다 했을 경우, cpu는 수행할 process가 없으므로 idle 상태가 된다  

```
프로세스 // o는 cpu가 실행해야 하는 부분, x는 wait를 뜻함  
1 : o o 
2 : o x x x o
3 : o o x x x o

cpu 실행 결과
1 2 3 1 3 2 x x 3
```

---

프로세스가 CPU를 차지할 수 있다는 말이 좀 애매한데,  
선점형과 비선점형 스케줄러의 차이는 CPU가 프로세스를 제어할수 있느냐 아니냐 이다.  
시분할 시스템을 사용하려면 선점형 스케줄러를 사용해야 한다  
처음엔 비선점형 스케줄러가 기본이었다. 선점형 스케줄러는 나중에 나왔는데, 구현하기가 매우 힘들었었기 때문이다.  

비선점형은 CPU에 들어있는 프로세스를 제어할 수 없어서, 다른 프로세스가 들어와도 자체적으로 바꿀 수 없고 기프로세스가 끝날때까지 기다려야함  
- 정확히 말하면 끝날때만은 아니고, terminated와 block 상태를 포함한다  
- block 상태나 terminated 상태에 들어가야만 스케줄러가 ready state에 있는 프로세스를 실행시킬 수 있다  

선점형은 CPU에 들어있는 프로세스를 제어할 수 있다  
요즘의 운영체제는 전부 선점형 스케줄러의 특징을 띄고 있다.  

먼저 들어온 프로세스를 시분할 시스템에서 나눠놓은 시간만큼 실하다가,  
시분할 시스템이 쪼개놓은 시간 안에서 프로세스가 block이나 terminated 상태가 되면 다시 스케줄러가 동작해서 ready state의 프로세스를 실행한다  
running state에 있는 프로세스가 시분할 시스템이 쪼개놓은 시간이 경과하기 이전에 block 이나 terminated가 되어버리면, 남은 시간만큼 ready state에 있는 프로세스를 실행한다.  

바선점형 스케줄러의 경우 앞의 프로세스에 의존하므로 응답시간이 길어질 수 있다는 단점이 있다.  
선점형 스케줄러는 앞의 프로세스 처리시간이 길든말든 상관없다  

스케줄러는 아래와 같은 로직을 가질 수 있다  
1) 각 프로세스가 실행되는 시간이 2초가 경과한 후, 다른 프로세스로 바꾸는 로직  
2) 0초, 2초, 4초, 6초 와 같이 2초마다 정해진 시간에 다른 프로세스로 바꾸는 로직  

---

CPU를 어떻게 분배할까 하는 `정책`중에 하나가 스케줄링이다.  
FIFO, SJF, Priority-based는 비선점형 스케줄링 방식에 좀 더 가깝다.  
RoundRobin은 선점형 스케줄링 방식을 기본적인 가정으로 깔고 있다  

아래와 같은 가정도 가능하다  
```
1. 우선순위 기반(정적)
2. 선점형
3. 시분할
4. 프로세스 상태
```

복잡한 스케줄러에서는 Ready State에 우선순위가 높은 애들이 들어오면 바로 컨텍스트 스위칭을 하지만,  
간단한 스케줄러에서는 시분할 시점에서만 우선순위를 체크하거나 block이나 terminated가 되었을때만 우선순위를 체크한다.  

우선 순위 기반 스케줄러에서는 State를 담아놓는 곳이 큐가 아니다.  
그러므로 Ready State에 2가지 이상의 프로세스가 들어있더라도, 우선순위가 높은 애를 먼저 뺴와서 실행한다. 

ex) 우선순위가 높은 애가 키보드 입력/출력 같은 쉘 프로그램(응답시간이 빨라야하는 애들)을 두게 되고,  
파일을 처리하는 애들(응답시간이 빠르지 않아도 되는 애들)은 우선순위를 낮게 두는 식으로 사용한다.  
요즘 스케줄러는 이런 모든 것들을 다 포함하여 동작한다. 아주 복잡하다.  

프로세스 타입을 미리 알게되면 개선된 스케쥴링이 가능함  
(쉘 처럼 우선순위가 빨라야 하는 애들, IO 처럼 우선순위가 느려도 되는애들, CPU를 엄청 써야 하는 프로그램인 경우)  

프로세스가 많으면 스케줄러가 해야 할 일이 많아서 느려진다?  

마우스/키보드다 반응이 느린 경우는 스케줄러가 해결해야 하는 이슈이다.  

---

인터럽트  

PC(레지스터)가 마지막에는 코드를 가리키게 된다  

IO작업이 끝났다고 누가 알려주는걸까?  
(block 상태에서 ready 상태로 가게 하는것) -> 이것을 인터럽트라고 한다  

CPU는 한순간에 한 명령만을 실행한다  
이벤트 발생 -> 처리 : 인터럽트  
CPU 외부에서 뭔가 이벤트가 발생했을떄 CPU?에 알려주는 기능  
READY state로 바꾸는것도 결국 CPU가 수행해야 하는걸까?  

running 중인 process를 ready로 바꿔주는 것도 결국 인터럽트이다.  
(block, terminated는 그냥 process의 기능이다)  

