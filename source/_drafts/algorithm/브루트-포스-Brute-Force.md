---
title: ''브루트 포스(Brute Force) ''
tags:
---

# 브루트 포스란?
무식하게 푼다(Brute Force)라는 뜻으로 가능한 모든 경우의 수를 나열해서 문제를 푸는 방식을 말한다.  
(이를 **완전탐색** 이라고 함)  
> 대체적으로 이런 방식을 말한다.  
> 1. 두 점 사이의 최단경로를 구하여라  
>> 두 점 사이의 경로를 전부 구한 뒤 가장 짧은 것을 고름  
> 2. 3개의 주사위를 던졌을 때 각각 숫자가 다르게 나오는 경우의 수를 구하여라  
>> 처음부터 끝까지 다 세어봄  

이게 무슨 알고리즘이냐 라고 할수도 있지만 사실 브루트포스는 컴퓨터의 장점을 가장 잘 이용하는 방법이다.  
컴퓨터의 최대 장점은 속도가 빠른것이기 때문이다.  

A,B,C라는 3명의 학생을 각각 다른 방식으로 세우는 경우의 수를 구한다고 해보자.  
`{A,B,C},{A,C,B},{B,A,C},{B,C,A},{C,A,B},{C,B,A}`  
보다시피 총 6가지 경우의 수가 발생한다.  
근데 만약 학생이 10명이라면?  
이는 `10!`으로 대략 360만번 정도의 경우의 수가 발생하는데, 이를 사람이 직접 구하는건 불가능하다.  
하지만 컴퓨터는 이러한 작업을 1초도 걸리지 않고 처리한다.  

## 재귀 호출
완전 탐색의 방식으로 일반적인 for 반복문이 외에 재귀(recursive) 함수라는 좋은 방식이 존재한다.  
재귀 함수란 자신이 수행할 작업을 유사한 여러개의 작업으로 쪼갠 뒤 그 중 하나를 실행하고 나머지는 자기 자신을 호출해 실행하는 함수를 말한다.  

간단히 위의 factorial을 재귀함수로 바꿔보겠다.  
먼저 수행할 작업이 뭔가 보자.  
factorial이므로 `1부터 n까지의 곱셈을 구한다` 가 수행할 작업이 된다.    
그럼 이제 이 작업을 쪼개어 보자.  
위의 작업에서 n을 떼어내면 `(n-1)! * n`의 형태가 된다.  
`(n-1)!`도 여전히 `1부터 n까지의 곱셈을 구한다`를 만족한다. 
즉, 이 작업을 재귀를 통해 처리하면되고, n을 직접 처리하면 된다는 의미이다.  
> 여기서 만약 n이 아닌 1을 떼어냈다면 재귀함수 구현이 불가능해진다.  
n을 떼어낸 `(n-1)!`은 `1부터 n까지의 곱셈을 구한다`를 여전히 만족하지만,  
1을 떼어내면 `2부터 n까지의 곱셈을 구한다`가 되어버려서, 완전히 다른 문제가 되어버린다. 이렇게 작업이 분리되면 재귀로 처리할 수 없다.  

```java
public int factorial(int n){
    if(n == 1){
        return n;
    }

    return n * factorial(n - 1);
}
```

보다시피 직접 n을 처리하고 나머지 작업을 자기 자신을 호출해 처리하고 있다. 이게 전형적인 재귀함수의 모습이다.  

여기서 `if(n == 1)` 구문을 볼 수 있는데, 이는 `base case`라고 불리우는 부분이다.  
기본적으로 재귀함수는 자기자신을 호출하는 함수라 빠져나올 포인트가 없으면 무한루프에 빠지게 되므로 위와 같은 `base case`를 항상 선언해줘야 한다.  
`base case`는 더 이상 쪼개지지 않는 최소한의 답에 도달했을 때 답을 곧바로 반환하는 조건문이다.  

### base case 선택 팁
1. 탐색 없이 간단하게 답을 낼 수 있는 애들을 base case로 먼저 선택한다.  
> 예를 들면 위의 factorial에서 n이 1일때 와 같은 부분을 먼저 base case로 선택하는 것이다.  
2. 입력이 잘못되거나 범위에서 벗어난 경우도 base case로 선택해서 맨 처음에 처리한다.  
> 재귀함수는 기본적으로 한군데 이상에서 호출된다(외부 호출 + 자기 자신 호출)  
그러므로 이러한 처리를 재귀함수 내에 직접 선언하게 되면,  
함수 호출 시점에서 이런 오류 검사를 할 필요도 없고,  
중복된 코드를 제거하는데도 큰 도움이 된다.  

### 문제(problem)과 부분 문제(sub problem)의 정의
재귀호출에서 가장 중요한 부분이다.  
일단 문제의 정의부터 보면, 
'문제'란 항상 수행해야 할 작업과 그 작업을 적용할 자료의 조합을 의미한다.  
즉, 아래와 같은 두 문제가 있다고 하자.  

- 주어진 자연수 수열을 정열하라  
- {4,3,6,9,2}를 정렬하라  

앞에서 언급한 개념에 따르면, 첫번째 문제의 경우 적용할 자료의 조합이 없으므로 '문제'라고 할 수 없다.  
또한 자료의 조합이 변경되어도 다른 '문제'로 인식된다.  
즉, `{4,3,6,9,2}를 정렬하라 != {5,7,9,10,2}를 정렬하라` 의 형태가 되는 것이다.  

그럼 '부분 문제'는 뭘까?  
간단하게 위에서 정의한 '문제'를 여러 부분으로 나눈 문제들을 말한다.  
[보글게임](https://algospot.com/judge/problem/read/BOGGLE)을 예로 들어보자.  
먼저 '문제'를 정의하면 아래와 같다.  
> 해당 단어(word)를 좌표 (x, y) 부터 시작해서 찾을 수 있는가?  

그리고 '부분 문제'를 정의하면 아래와 같다.  
> 처음 위치(x, y)에 첫 단어(word)의 첫 글자가 있는가?  
> 윗칸(x, y-1)부터 시작해서 단어의 나머지 글자들을 찾을 수 있는가?  
> 왼쪽 위칸(x-1, y-1)부터 시작해서 단어의 나머지 글자들을 찾을 수 있는가?  
> ....

보다시피 원래의 문제에서 조금씩 떼어내서 조각조각 분리하였다.(조금 어렵다..)  
재귀호출의 경우 하나의 작업을 유사한 여러개의 작업으로 쪼개는 과정이 중요한데,  
이렇게 문제를 분리하는 것을 시작으로 유사한 여러 작업들을 쪼개나가는게 좋은 것 같다..  
(좀 어려운 것 같다. ㅠㅠ)  


## 완전탐색 레시피
어떠한 문제를 완전 탐색으로 해결하기 위해 필요한 과정을 말한다.  
1. 완전 탐색은 가능한 답의 수를 모두 검사하는 방식이기 때문에,  
입력이 많아질수록 걸리는 시간이 정비례하게 늘어난다.  
그러므로 최대 입력값의 크기를 가정했을 때의 답의 개수를 예상하고,  
이를 제한시간 안에 구할 수 있는지 가늠해봐야 한다.  
이게 불가능하면 브루트 포스가 아닌 다른 방식으로 풀어야 한다.  
2. 가능한 답의 후보를 만드는 과정을 여러개의 선택으로 나눈다.  
3. 이 중 하나를 선택해 답의 일부를 만들고, 나머지 답을 재귀호출을 통해 완성한다.  
4. `조각이 하나밖에 남지 않은 경우 or 하나도 남지 않은 경우` == 이미 답을 구했다  
가 성립하므로, 이를 base case로 선택한다.  


## 최적화 문제
문제의 답이 하나가 아니라 여러개고,  
그 중 어떤 기준에 따라 `가장 좋은` 답을 찾아내는 문제를 최적화 문제라고 한다.  
최적화 문제를 푸는 방식은 여러가지가 있는데, 그 중 가장 기초적인 것이 완전 탐색이다.  
가능한 모든 경우의 수를 다 구한 뒤, 가장 좋은 것을 찾아내면 되기 때문이다.  

## 자주 등장하는 완전탐색 유형
### 순열
5개중에 3개를 중복없이, 순서에 맞게 뽑는 <sub>5</sub>P<sub>3</sub>을 한번 구현해보자.  

```java
public int permutation(int n){
    int count = 0;

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if(i != j){
                for (int k = 0; k < n; k++) {
                    if(i != k && j != k){
                        count++;
                    }
                }
            }
        }
    }

    System.out.println(count);
}
```

보다시피 이 형태는 r이 변경되는 상황에 대처하지 못한다.  
n개중에 4개를 뽑게되면 중첩을 한개 더 추가해야하고, 2개를 뽑으면 중첩을 한개 빼야한다. 즉, r의 개수만큼 for문을 써줘야하는 아주(..) 불편한 상황이다.  

하지만 여기서 재귀함수를 이용하면 아주 깔끔하게 처리할 수 있다!  

```java
public int permutation(int n , int r, int depth){
    int count = 0;

    if(depth == r){
        return 1;
    }

    for (int i = 0; i < n - depth ; i++) {
        count += permutation(n, r, depth + 1);
    }

    return count;
}

// 사용
permutation(5, 3, 0);
```

재귀함수는 이처럼 특정 상황에서 아주 강력한 힘을 발휘한다.  
또한 코드의 가독성을 올려주는 역할도 하니(quick sort, merge sort 등) 아주 유용하게 사용할 수 있다!  

> 재귀호출이 너무 많이 일어나면 StackOverflow가 발생할 수 있으니 유의해야 한다.  
자바는 메서드가 매개변수, 지역변수가 계속해서 스택에 쌓이기 때문이다.  

### 조합
