---
title: '브루트 포스(Brute Force) '
tags:
---

# 브루트 포스란?
무식하게 푼다(Brute Force)라는 뜻으로 가능한 모든 경우의 수를 나열해서 문제를 푸는 방식을 말한다.  
(이를 완전탐색 이라고 함)  
> 대체적으로 이런 방식을 말한다.  
> 1. 두 점 사이의 최단경로를 구하여라  
>> 두 점 사이의 경로를 전부 구한 뒤 가장 짧은 것을 고름  
> 2. 3개의 주사위를 던졌을 때 각각 숫자가 다르게 나오는 경우의 수를 구하여라  
>> 처음부터 끝까지 다 세어봄  

이게 무슨 알고리즘이냐 라고 할수도 있지만 사실 브루트포스는 컴퓨터의 장점을 가장 잘 이용하는 방법이다.  
컴퓨터의 최대 장점은 속도가 빠른것이기 때문이다.  

A,B,C라는 3명의 학생을 각각 다른 방식으로 세우는 경우의 수를 구한다고 해보자.  
`{A,B,C},{A,C,B},{B,A,C},{B,C,A},{C,A,B},{C,B,A}`  
보다시피 총 6가지 경우의 수가 발생한다.  
근데 만약 학생이 10명이라면?  
이는 `10!`으로 대략 360만번 정도의 경우의 수가 발생하는데, 이를 사람이 직접 구하는건 불가능하다.  
하지만 컴퓨터는 이러한 작업을 1초도 걸리지 않고 처리한다.  

## 재귀 호출
완전 탐색의 방식으로 일반적인 for 반복문이 외에 재귀(recursive) 함수라는 좋은 방식이 존재한다.  
재귀 함수란 자신이 수행할 작업을 유사한 여러개의 작업으로 쪼갠 뒤 그 중 하나를 실행하고 나머지는 자기 자신을 호출해 실행하는 함수를 말한다.  

간단히 위의 factorial을 재귀함수로 바꿔보겠다.  
먼저 수행할 작업이 뭔가 보자.  
factorial이므로 `1부터 n까지의 곱셈을 구한다` 가 수행할 작업이 된다.    
그럼 이제 이 작업을 쪼개어 보자.  
위의 작업에서 n을 떼어내면 `(n-1)! * n`의 형태가 된다.  
`(n-1)!`도 여전히 `1부터 n까지의 곱셈을 구한다`를 만족한다. 
즉, 이 작업을 재귀를 통해 처리하면되고, n을 직접 처리하면 된다는 의미이다.  
> 여기서 만약 n이 아닌 1을 떼어냈다면 재귀함수 구현이 불가능해진다.  
n을 떼어낸 `(n-1)!`은 `1부터 n까지의 곱셈을 구한다`를 여전히 만족하지만,  
1을 떼어내면 `2부터 n까지의 곱셈을 구한다`가 되어버려서, 완전히 다른 문제가 되어버린다. 이렇게 작업이 분리되면 재귀로 처리할 수 없다.  

```java
public int factorial(int n){
    if(n == 1){
        return n;
    }

    return n * factorial(n - 1);
}
```

보다시피 직접 n을 처리하고 나머지 작업을 자기 자신을 호출해 처리하고 있다. 이게 전형적인 재귀함수의 모습이다.  

여기서 `if(n == 1)` 구문을 볼 수 있는데, 이는 `base case`라고 불리우는 부분이다.  
기본적으로 재귀함수는 자기자신을 호출하는 함수라 빠져나올 포인트가 없으면 무한루프에 빠지게 되므로 위와 같은 `base case`를 항상 선언해줘야 한다.  
`base case`는 더 이상 쪼개지지 않는 최소한의 답에 도달했을 때 답을 곧바로 반환하는 조건문이다.  

## 괜히 보기만 더 불편한거 같은데..
아니다! factorial을 재귀함수로 구현해서 그렇다 ㅠ.ㅠ  
재귀함수의 장점을 부각시킬 수 있는 순열(<sub>n</sub>P<sub>r</sub>)을 구현해보겠다.  

5개중에 3개를 중복없이, 순서에 맞게 뽑는 <sub>5</sub>P<sub>3</sub>을 한번 구현해보자.  

```java
public int permutation(int n){
    int count = 0;

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if(i != j){
                for (int k = 0; k < n; k++) {
                    if(i != k && j != k){
                        count++;
                    }
                }
            }
        }
    }

    System.out.println(count);
}
```

보다시피 이 형태는 r이 변경되는 상황에 대처하지 못한다.  
n개중에 4개를 뽑게되면 중첩을 한개 더 추가해야하고, 2개를 뽑으면 중첩을 한개 빼야한다. 즉, r의 개수만큼 for문을 써줘야하는 아주(..) 불편한 상황이다.  

하지만 여기서 재귀함수를 이용하면 아주 깔끔하게 처리할 수 있다!  

```java
public int permutation(int n , int r, int depth){
    int count = 0;

    if(depth == r){
        return 1;
    }

    for (int i = 0; i < n - depth ; i++) {
        count += permutation(n, r, depth + 1);
    }

    return count;
}

// 사용
permutation(5, 3, 0);
```

재귀함수는 이처럼 특정 상황에서 아주 강력한 힘을 발휘한다.  
또한 코드의 가독성을 올려주는 역할도 하니(quick sort, merge sort 등) 아주 유용하게 사용할 수 있다!  

> 재귀호출이 너무 많이 일어나면 StackOverflow가 발생할 수 있으니 유의해야 한다.  
자바는 메서드가 매개변수, 지역변수가 계속해서 스택에 쌓이기 때문이다.  