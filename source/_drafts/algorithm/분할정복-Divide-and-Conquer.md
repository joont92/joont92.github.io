---
title: 분할정복(Divide and Conquer)
tags:
---

# 분할정복이란?
**각개 격파!** 라는 단어로 간단하게 정의해볼 수 있다.  
문제를 둘 이상의 부분 문제로 나눈 뒤, 각 부분 문제에 대한 답을 재귀호출을 이용해 계산하고, 부분 문제들로부터 최종 답을 계산해내는 방식을 말한다.  

그림으로 나타내보면 대충 이런식이다.  
![분할정복](https://cloud2.zoolz.com/MyComputers/Images/Image.aspx?q=bT00MDcyNDcma2V5PTI3NTQwNTUxNDUmdHlwZT1sJno9MjAxOC8xMC8yMSAxOTo0OQ==)

분할정복은 대개 아래 3가지 요소를 가지고 있다.  
> 1. 문제를 더 작은 요소로 분할하는 과정(divide)  
2. 각 문제에 대해 구한 답을 원래의 답으로 병합하는 과정(merge)  
3. 더이상 답을 분할하지 않고 곧장 풀 수 있는 작은 문제(base case)  

## 재귀호출 vs 분할정복
1부터 n까지의 합을 구하는 메서드를 구현해야 한다고 해보자.  
재귀를 사용하면 아래와 같이 구현할 수 있다.  

```java
public int getSum(int n){
    if(n == 1){
        return 1;
    }

    return n + getSum(n - 1);
}
```

재귀라 따로 반복문이 존재하지 않으므로, 함수의 시간복잡도는 함수의 호출 횟수에 비례한다.  
전달받은 n를 1까지 깎아가며 함수를 호출하므로 총 n번 호출된다.  
즉, 시간복잡도는 `O(n)`이다.  

이를 분할정복으로 풀어보자.  
먼저 문제를 2개로 쪼개야한다.  
1부터 n까지의 합을 구하는 문제니까, `1부터 n/2까지` 구하는 문제와 `n/2+1 부터 n까지` 구하는 문제로 쪼개면 아래와 같은 형태가 된다.  

```
getSum(n) = getSum(n/2) + 
            (n/2 + 1) + (n/2 + 2) + (n/2 + 3) + ... + (n/2 + n)
```

각 부분문제에 대해 재귀호출을 이용해 계산해야하는데  
현재 정의된 재귀함수의 형태가 `1부터 n까지의 합` 이므로,  
두번째 부분 문제의 `a부터 b까지의 합` 형태를 처리할 수 없다.  
그러므로 형태를 조금 바꿔줘야 한다. 먼저 공통된 부분을 정리해보자.  

```
getSum(n) = getSum(n/2) + 
            2/n * 2/n + (1 + 2 + 3 + ... + 2/n)
```

공통 분모를 뽑았더니 놀랍게도(오글) `1부터 n까지의 합`이 추출해내었다.  
이제 이를 재귀를 사용하는 형태로 바꿔보면 아래와 같다.  

```
getSum(n) = 2 * getSum(n/2) + (2/n * 2/n)
```

크...  
공식이 나왔으니, 간단하게 코드로 구현가능하다.  

```java
public int getSum(int number){
    if(number == 1){
        return 1;
    }

    // 바로 뒤에서 설명
    if(number % 2 == 1){
        return getSum(number - 1) + number;
    }

    return 2 * getSum(number / 2) + ((number / 2) * (number / 2));
}
```

이 함수는 호출할 때 마다 n이 반으로 줄어드는 `O(logN)`의 시간복잡도를 가진다!  
현재는 한낱 1부터 n까지의 합계를 구하는 함수이지만, 좀 더 복잡한 함수에, 입력값이 상당히 큰 상태라면 분할정복으로 상당한 효과를 누릴 수 있을것이다.  
## 반으로 나누어 떨어지지 않을때는 어떻게 해야하나?
보다시피 위의 `getSum(n)` 함수는 매번 연산의 범위를 반으로 줄여나가는 함수이다.  
근데 알다시피 홀수의 경우 반으로 딱 나뉘어지지 않는다.  
그래서 위의 함수에서는 짝수로 만든 뒤 반으로 나누는 방식을 택했는데, 이를 2가지 케이스를 비교해가며 설명하겠다.  
1부터 7까지의 합계를 구하는 `getSum(7)`을 호출한다고 가정하겠다.  

1. getSum(4) + getSum(3) 으로 처리하는 방법  

```
getSum(7) -> getSum(3) ->  getSum(2)
                       ㄴ> getSum(1)
          -> getSum(4) ->  getSum(2) -> getSum(1)
```

보다시피 `getSum(2)`와 `getSum(1)`은 2번씩 중복해서 호출되고 있다.  
이 말인 즉, n이 증가함에 따라 `getSum(n)`의 호출횟수는 선형적으로 증가하게 됨을 의미한다.  

2. getSum(6) + 7 으로 처리하는 방법  

```
getSum(7) -> 7 + getSum(6) -> getSum(3) -> 3 + getSum(2) -> getSum(1)
```

반면 이 처리방법에서는 중복 호출되는 부분이 없다!!  

이런식으로 같은 문제라도 어떻게 분할하느냐에 따라 시간 복잡도 차이가 커지게 된다.  
문제를 반으로 나누는 분할정복에서 1번과 같이 중복해서 호출되는 부분이 효율 저하를 일으키는 원인이 된다. (이를 위해 다이나믹 프로그래밍이 제안되었다)  