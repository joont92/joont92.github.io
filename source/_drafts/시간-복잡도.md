---
title: 시간 복잡도
tags:
---

## 알고리즘 분석

알고리즘 분석은 일반적으로 실행시간의 분석임  
시간이라는 것이 그나마 가장 정확한 지표(?) 이므로  
하지만 실행시간은 실행환경(하드웨어, 컴파일러) 등에 따라 달라지므로  
기본적으로 시간복잡도는 `연산의 실행 횟수`를 카운트한다.  
실행 횟수는 입력 데이터의 크기에 관한 함수로 표현한다.  
데이터의 크기가 같더라도 실제 데이터에 따라 달라진다.  
그래서 대부분 평균 시간복잡도나 최악의 경우 시간 복잡도를 구한다.  
(평균 시간 복잡도는 구하기 어려워서 최악의 경우 시간 복잡도를 구하는 경우가 많다.)  
## 점근적 분석
데이터가 n->무한대일때 수행시간이 증가하는 growth rate로 시간복잡도를 표현  
대표적으로 Big-O 표기법을 사용  
가장 좋은 분석법은 아니지만, 상대적으로 간단하고 실행환경에 비의존적이라 가장 광범위하게 사용된다.  
시간복잡도는 최고차항의 차수만을 남기고 낮은 차항이나 상수는 다 버려서 계산한다.  
낮은 차수나 상수는 시간복잡도에 크게 영향을 미치지 않기 때문이다.  

### 상수 시간복잡도
```java
int sample(int[] data, int n){
    return data[n/2];
}
```
n에 관계없이 상수시간이 소요되므로 시간복잡도는 `O(1)` 이다.  

### 선형 시간복잡도
```java
int sum(int[] data, int n){
    int sum = 0;
    for(int i=0; i<n; i++){
        sum += data[i];
    }

    return sum;
}
```
실행횟수가 항상 n번이므로 시간복잡도는 `O(n)` 이다.  

### Quadratic
2중 루프가 돌았을 때 `O(n^2)` 로 표시한다  

### Logarithmic
```java
for(int i=1; i<n; i*=2){
    // do something
}
```

점화식..  
어떤 함수를 자신보다 더 작은 변수에 대한 함수와의 관계로 표현한 것  
