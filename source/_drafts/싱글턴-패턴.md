---
title: 싱글턴 패턴
tags:
---

전역변수의 단점  
생성해놓고 만약 한번도 사용하지 않는다면, 괜히 자원만 잡아먹는 쓸데없는 객체가 된다.  

싱글턴 패턴 : 애플리케이션 전반에 걸쳐 인스턴스가 하나만 만들어지고, 어디서든지 접근 가능할 수 있게 하는 패턴  

```java
class SingleTon{
    private static SingleTon singleton;
    private SingleTon(){}

    public static SingleTon getInstance(){
        if(singleton == null){
            singleton = new SingleTon();
        }
        return singleton;
    }
}
```

싱글턴 객체를 사용하면 한 애플리케이션에 들어있는 어떤 객체에서도 똑같은 자원을 활용하도록 할 수 있다.  
커넥션 풀 또는 스레드 풀 같은 자원 풀을 관리하는데도 자주 이용된다.  

위와 같은 패턴은 멀티스레드 환경에서 문제가 될 수 있다.  
여러 스레드에서 호출할 때 각각의 스레드에서 동시에  
`if(singleton == null)` 조건에 걸리게 되버리면 인스턴스가 2개 생성되는 상황이 발생한다.  

이를 방지해 메서드를 동기화 하는 방법이 있다.  

```java
public static synchronized SingleTon getInstance(){
    if(singleton == null){
        singleton = new SingleTon();
    }
    return singleton;
}
```

하지만 동기화를 하면 성능이 100배정도 떨어지는 단점이 있다!  
근데 뭐 자주 호출되지 않는다면 이 정도 성능저하는 무시하고 저렇게 놔두고,  
만약 자주 호출된다면 아싸리 처음부터 싱글톤을 만드는 것도 방법이다.  

```java
// 클래스 로딩시에 생성됨
private static SingleTon singleton = new Singleton();
private SingleTon(){}

public static SingleTon getInstance(){
    return singleton;
}
```

아니면 아래와 같이 DCL(Double Checking Locking)을 사용하는 방법도 있다.(java 1.5 이상)  

```java
private volatile static SingleTon singleton;
private SingleTon(){}

public static synchronized SingleTon getInstance(){
    if(singleton == null){
        synchronized(SingleTon.class){
            if(singleton == null){
                singleton = new SingleTon();
            }
        }        
    }
    return singleton;
}
```

인스턴스가 생성되지 않았을 때만 동기화를 사용하고, 생성되어 있을 경우 동기화를 사용하지 않는다.  

