---
title: 그림으로 공부하는 IT 인프라 정리
tags:
---

현재 네트워크는 그 구조를 알지 못해도 사용할 수 있도록 되어있음
네트워크 데이터 처리/교환에는 다양한 구조가 존재함(3계층형 시스템을 구성하는 경우 대부분 TCP/IP를 사용함)
컴퓨터는 대부분 계층구조
	- 커질수록 계층화하지 않으면 구조가 복잡해진다
계층들간에 교환방법(인터페이스)만 정의해놓으면 됨
- 어떤일을 하는지는 알지만 어떻게 하는지는 모른다
- 인터페이스만 바꾸면 변경도 용이하다
- 대신 성능이 조금 떨어짐

커널과 JVM은 시스템콜로 연결되어있다?

네트워크 표준화 = IEEE, IETF(RFC 만듦)
OSI는 TCP/IP가 defecto라 사용되지 않는다?
우리가 아는 프로토콜 HTTP, TCP/IP 등 이런것만 프로토콜인가?
RFC는 프로토콜이 아닌가? == 인터넷 기술과 관련된 표준 문서
이건 어디서 정하는 것인가?

표준이 필요해 OSI 를 만들었지만 이미 TCP/IP가 보급되고 있었으며, OSI는 사장됨  > TCP/IP 4계층
이처럼 네트워크가 상호협력 하면서 인터넷이 발전했고, 이 가운데서 TCP/IP가 발전

TCP/IP 4계층이지만 현업에서는 OSI 레이어를 토대로 계층을 부르는 경우가 많다
이더넷 계층 L2, IP 계층 L3, 전송 계층 L4, 애플리케이션 계층 L7(5, 6을 모아서 애플리케이션 계층으로 취급하기 때문)

통신의 시작점은 애플리케이션이다
애플리케이션 계층 프로토콜은 자신이 통신을 하는 것이 아니라 모두 OS(TCP/IP)에게 맡긴다

HTTP가 하위 계층인 IP 등등을 제어하지는 않는다
단순히 요청, 헤더, 바디만 보내고 받는 간단한 구조이다

애플리케이션 계층 프로토콜은 필요한 데이터를 소켓에 기록만 하며, 통신은 모두 TCP/IP에게 위임한다
TCP/IP가 실패할 수는 없다.. 뭐 이게 그 말일까?

어플리케이션 프로세스는 시스템 콜로 커널에 TCP/IP 통신 요청을 하면서 소켓이 열리고, 열린 소켓으로 IP와 PORT 정보를 전달하면 통신이 된다
즉 TCP/IP 레벨부터는 커널단에서 다 구현되어 있다는 의미이다 == 브라우저 없이도 TCP/IP 통신은 가능하다

HTTP는 기본적으로 요청이 많고, 한번에 한 요청만 한다
> HTML 파일을 받고 파일내에 이미지나 스크립트가 있으면 다시 요청하기 떄문
이 때문에 하위 계층인 TCP/IP 에서 소켓을 열고 닫는 행위를 자주해야 되므로, 많은 오버헤드를 발생시킨다(3way hand shaking)
keep alive = https://b.pungjoo.com/entry/HTTP-11-Keep-Alive-%EA%B8%B0%EB%8A%A5%EC%97%90-%EB%8C%80%ED%95%B4
> HTTP 요청에 keep alive가 있다면 사용하던 소켓을 계속 사용하게 된다(TCP/IP 레벨)

TCP = 서버가 송신할 때와 서버가 수신한 후 애플리케이션에게 전달할 때만 담당
IP = 실제 서버까지 전송하는 부분 담당

모든 네트워크가 다 빠르지 않다. 데이터가 유실되는 경우도 굉장히 많다. 그러므로 서로간 신뢰성을 담보하는 기능이 필요하다
그리고 인터넷은 공평성도 중요하다. 보내는쪽에서 아무리 빨리줘봤자 받는쪽에서 빨리 받지 못하는 환경이면 아무 의미가 없다.
TCP는 이런 신뢰확인 시스템(+재전송)과 폭주제어 기능을 가지고 있다
IP만 가지고 통신할 수 있으나, TCP의 이런 특징 없이는 신뢰성을 가진 네트워크를 구성할 수 없는것이다
IP는 그냥 데이터를 전송하는 기능만을 담당하기 때문이다.
> 인터넷은 모두의 것이라는 생각을 가지고 접근해야 한다

어플리케이션 데이터가 소켓에 들어오면 소켓의 큐를 경유하여 소켓 버퍼라고 불리는 메모리 영역에서 처리된다
데이터는 TCP 세그먼트라는 단위(MSS)로 나눠진다
> 최종적으로 링크계층에서 데이터를 전송하기 때문에 MSS는 링크 계층에서 전송할 수 있는 최대 크기에 의존한다
MSS로 나누는 것도 TCP의 기능이다
TCP 세그먼트는 각각 TCP 헤더를 가지고 있다

전달받은 데이터를 어느 어플리케이션에 전달해야할 지 모르므로, 포트번호를 전달해줘야 한다
서버는 LISTEN 할 포트를 지정하지만 클라이언트는 송신할 포트를 지정할 수 없다
이때는 OS에서 사용하지 않는 포트번호(0~65xxx)가 자동으로 할당되어 통신한다

3way handshaking
1. 통신 의뢰를 받으면 소켓을 생성하기 위해 상대편 IP의 포트로 통신 요청을 한다
2. 상대편 IP가 유효하고, 포트가 LISTEN 상태면 통신 할 수 있다는 응답을 한다
3. 확인했다는 메시지를 보내면 가상 경로(소켓)이 열린다
> 이런 요청이든 통신이든 결과적으로는 물리적인 선을 경유해서 이루어진다

소켓과 소켓 사이에 입력/출력 스트림 2개가 형성되어 통신한다
핸드쉐이킹 3번 과정에서 양쪽 소켓이 생성되고 스트림으로 연결되는걸까?
