# 레이싱카에서 내가 얻은 것
테스트를 먼저 작성하고 프로덕션 코드를 작성한다
테스트는 점진적으로 확장시켜야 한다. 한번에 확장 시켜서는 안된다.
테스트하기 불편하다면 코드 설계를 의심해봐야한다
테스트를 위해 함수가 생성되어도 괜찮다
시작부터 추상화를 하는 것은 별로 안좋은 것 같다
테스트를 위해 클래스를 상속으로 만드는 것은 좋지않은 행위이다
mockist같은 라이브러리는 좋은 구조가 아님에도 불구하고 테스트가 가능하게 만들어버려서. 나쁜 구조를 발견하기 어려워진다
행위검증은 지양해야 한다
인터페이스보단 구현체를 테스트하는것이 맞다
Random, LocalDate.now()와 같이 제어할 수 없는 값을 반환하는 기능은 테스트 할 수 없다. 이를 사용하는 코드는 이 부분을 외부에서 주입받을 수 있게 테스트를 작성해야한다
기존 객체를 상속받은 스텁을 만들고 이를 주입해서 테스트할 수 있다
상태값을 가지지않는다면 static 메서드로 구현하는것이 좋다
출력 + 입력을 하는 부분을 굳이 따로 나눌 필요없다. 별로 얻는 이득도 없고, 어렵기만 해진다.
중복된 정보, 비슷한 정보를 가진 클래스가 있는지 찾아보고, 있다면 하나만 써보는것도 좋다. 굳이 앞서서 분리할 필요있을까?
자꾸 실생활에 뭔가 맞추려고 하지말자
테스트에 내용이 중복되서 들어가도 괜찮다. 테스트하려는 행위 자체들이 다르기 떄문이다
자꾸 구현에 집중하려고 하지말고, 학습하려고하는 목표에 집중하자(UI를 막 열심히 만들고 있을떄 느낀점)
delegate 패턴

# 로또에서 내가 얻은 것
개발 방법
	- 요구사항을 나열한다
	- 메시지를 뽑아낸다
	- 메시지에서 중복적으로 등장하는 단어들을 객체로 만든다  
	- 이를 메시지에 연결한다  
	- 해당 메서드들을 객체에 직접 구현한다(TDD로)  
	- 구현(코드작성)에서 나오는 피드백들은 즉각 반영한다  
		- 너무 과하게 생각만 하지말자. 생각나는대로 바로바로 코드로 작성해보는 것도 중요하다.  
	> 뭔가 이상하거나 애매한 상황(테스트하기 힘들거나, 억지로 끼워맞추거나, 중복되거나 등등)이 발생한다면 끊임없이 의심해본다  
명확하지 않은 기준법으로 자꾸 클래스를 생성하려는 행위는 그만하자
pure함을 유지하려고 클래스를 계속 분리하는건 안좋은 행위이다
pure함을 유지하려다보니 객체간의 의사소통의 구조가 명확하지 않았고, 객체의 행위에 순서가 필요했다 == 복잡했다
객체의 메시지 전달에 거쳐야하는 객체들이 너무 많아지면 별로다
필요가 있을 때 클래스를 분리하자  
디미터의 법칙을 적용하자(*)  
테스트가 어려우면, 개발을 하는데 뭔가 모호하거나 짜증나는 상황이 나오면 설계를 의심해보자
private 메서드를 테스트해야 할 상황이 나온다면 설계를 의심해본다
신뢰할 수 있는 객체를 계속 만들고, 그것들을 wrapping해서 사용함으로써 고수준의 객체들을 얻을 수 있다
설계를 하고, 도메인을 뽑고, 해당 도메인들에 대한 테스트들을 만들면서 개발한다
Value Object, 일급 객체를 적극 활용한다
static Map을 써서 VO 재사용성을 높일 수 있다
VO는 equals, hashCode를 재구현한다. 값이 같으면 같은 오브젝트여야 한다.
collection뿐만 아니라 map도 일급컬렉션으로 사용할 수 있다
메서드를 최소한의 단위로 유지하는 연습을 많이 한다. 그러면 클래스 분리도 얻을 수 있다.
너무 머리속으로 생각만 하지말고 코드로 작성하면서 피드백을 많이 받자.
디미터의 법칙을 지키다보면 메서드가 제자리를 찾아가는 경험을 하게 된다
적절한 자료구조를 잘 활용하면 추가적인 구현을 줄일 수 있다
생성자 대신 정적 팩토리 메서드를 사용하여 역할을 더 잘 드러낼 수 있다
객체를 사용하는 쪽에서 복잡한 느낌이 없게끔 해야한다? 여러 객체가 많이 얽혀있는 복잡한 형태일 경우 더 안좋다.

- 해결되지 못한 궁금증
일급객체도 VO인가?
List vs varargs 파라미터와 리턴값들은 어떻게 하면 좋을까? 2개를 받는 혼란만 줄이면 내가 어떻게 선언하든 상관없을까?
private 메서드의 위치는?

# 사다리게임
객체는 해당 객체만 봐도 알아보기 쉬워야한다. 다른 객체에서 뭔가를 해줘야 한다면, 코드로 명확히 드러나야 한다.  
문서로 표현되어야 할 룰이 있어서는 안된다  
도메인에 대한 이해를 더 확실하게 했어야 했다. 사다리 게임의 특징도 모르고 설계를 하다니.  
너무 완벽하게 머리속으로 구현하고 코딩하려고 하지말고, 어느정도 구상이 그려지면 바로 코딩해보자  
> 전체적인 큰 그림이 아니라 작은부분에 대한 그림이라도, 일단 그것부터 코딩해보자. 피드백을 얻을 수 있다  

내가 뭔가 대단한, 남들과는 다른 뭔가를 만들수 있다는 생각을 버리자  
남들이 다 이해할만한, 복잡하지 않은, 쉽게 읽히는 코드를 만드는것이 목표이고, 그것은 매우 어려운 과정이고, 내가 정복해야 할 과정이다  
항상 너무 많은걸 만족하려고 하지도 말고(시작부터 너무 많은 생각을 하니까 복잡해지는 것이고, 집중도 못하는 것이다)  
필요한 요구사항을 만족하는 부분에만 집중하자  

설계시간이 너무 길어지면 짜증이나고 집중력이 떨어진다  

클래스의 구조가 변경되어야 할때  
- 변경할 기능으로 테스트를 작성한다  
- 기존의 안쓰는 테스트들을 삭제한다  
- 테스트들을 모두 통과시킨다  
- 해당 클래스의 (구)기능들을 전부 @Deprecated로 만든다  
- 해당 클래스를 사용하던 테스트들을 찾아가 구기능 사용하는 부분을 전부 신기능을 사용하도록 변경한다

코드를 통해 계속 피드백을 받자  
생각만 주구장창 하지말고 코드를 통해 피드백을 받으니 개발 속도가 빨라졌다  
테스트를 통과시키기 위해선 끔찍한 죄악을 저질러도 괜찮다  
> 나중에 중복 제거만 잘해주면 ㅎ.ㅎ  

Todo List(Task List)를 만들어서 옆에 계속 두고 개발하는 습관을 기르자  
메모장도 있으면 좋겠다(투두리스트 + 메모장 같은 플러그인 어디 없나?)  

# QNA
cookie에 담긴 Authorization 헤더값을 복호화해서 userid, password를 얻어낸 뒤 로그인 -> 세션에 저장한다  
UserService에는 mockito의 when thenReturn을 쓰면 된다  
AcceptanceTest에서 contents 검증까지 해야할까? DOM검증은 아니니까 괜찮지않을까?
repository.save 로직을 가진 서비스 메서드에서 `저장`을 테스트 할 필요는 없다  
html 리턴의 경우 응답이 200이다(다른 응답은 올 수 없는걸까?)  

repository를 mock을 써서 테스트 안하지말고 메모리 db를 써서 통합테스트 하는 것이 좋다  
(classicist 의 장점을 좀 더 가져감)  

json의 응답은 스프링의 ResponseEntity를 사용한다  
@RestController를 사용하면 메서드에서 리턴한 타입에 자동으로 ResponseEntity를 래핑한다  
(메서드에서 직접 ResponeEntity를 리턴하고 있다면 래핑하지 않는다)  

- GET : 조회한 엔티티 리턴, HttpStatus.OK  
    > List를 오브젝트로 한번 래핑해서 respose로 내려주는 것이 좋다  
    > 나중에 메타데이터 등을 추가할일이 있을수가 있는데, 이때 하위호환성을 깨지 않기 위함이다  
    > 하위호환성을 떠나서도 []를 그대로 내려주는 것은 안티패턴이다  
    ```java
    public class ListResponse<T> {
        private List<T> list;
        private Integer page;
        private Integer size;

        private Integer totalPages;
        private Long totalElements;

        public ListResponse() {
        }

        public ListResponse(Page<T> result) {
            list = result.getContent();
            page = result.getNumber();
            size = result.getSize();
            totalPages = result.getTotalPages();
            totalElements = result.getTotalElements();
        }
    }
    ```
- CREATE : void 리턴, HttpStatus.CREATED, location header 리턴  
- UPDATE : 변경된 엔티티 리턴, HttpStatus.OK  
- DELETE : ?  

testRestTemplate를 써서 예외를 테스트할때는 리턴 오브젝트의 타입을 Void, String 으로 줘야한다  
예외가 발생했을때 나오는 json으로 오브젝트 매핑이 안되서 다른 오류가 발생하기 때문이다  

get은 import.sql에 등록된 데이터를 기준으로 테스트하고,  
create, update, delete는 반환한 location 기준으로,.. 한다  
get도 바꿔야할까?  
CRUD로 테스트를 작성한다고 가정하면, GET도 여기에 종속되지 않는게 맞아보인다  

Acceptance Test 하나씩 작성해가면서 service, domain을 작성한다
Acceptance Test 작성 -> Controller 작성(이떄 service가 필요하게 됨)  
-> Service Test 먼저 작성 -> Service 작성(이떄 domain이 필요하게 됨)  
-> Domain Test 먼저 작성 -> Domain 작성  

서비스는 mock을 사용해서 테스트하는 것이 좋다.  
db 자체만 해도 힘든데, 여기에 외부의 인프라스트럭쳐 까지 관련되면 테스트가 힘들어질 가능성이 크다  
그리고 테스트 자체도 느려서, 피드백 받는 속도가 느려서 개발 속도가 떨어진다  
> mock 픽스쳐의 경우 setUp으로 상단에서(setUp) 한번에 선언하는 것도 괜찮은 것 같다
> (실제 리파지토리 사용할 때 상단에서 db에 값넣는 것 처럼)  
> mock에서 repository stub에 대한 thenReturn을 작성할 때 테스트가 구현에 매우 의존적인 느낌을 처음에 받았었는데,  
> 다시 생각해보니.. 리파지토리라 괜찮을 것 같다(다른 외부 인프라스트럭쳐여도)  
> 다른 코드처럼 전투적 리팩토링이 일어나는 구간이 아니기 떄문이다  

인수테스트에서 모든 부분에 대해 통합테스트를 진행하는게 좋다  
여기선 사실상 롤백이 힘드니까 필요한 픽스쳐들을 생성해서 테스트해보는게 좋다(import.sql 보단)  
> 이때 너무 특정 상황에 의존적인 Acceptance Test를 작성하지 않도록 해야한다  
> 가령, 1번 게시글을 조회하고, 1번 게시글을 삭제하는 등의 행위는 너무 강력한 acceptance test이다  
> database가 깨끗하든, 깨끗하지 않던간에 그 api는 성공해야 하지 않는가?  

DataJpaTest의 경우 매 테스트마다 픽스쳐들을 롤백하긴 하지만,  
내부에서 트랜잭션을 다르게 가져가거나 사용하지 않는 등의 행위를 할 경우 그 부분은 롤백이 안될 수 있다  

fixture는 그냥 원래 이름 그대로 사용함(question, answer 등등)  
service에서 메서드 수행 결과는 returned = returned  
api 호출 결과는 response(+return type) = response, responseQuestion  
복수형은 s를 붙임 = responseQuestions  

api 수행 후 repository를 조회해서 검증할 수 있다  
목록 api 호출 후 repository 에서 조회한 레코드 개수와 비교한다거나 등등(delete 는 잘 Optional이 empty인지 체크 등)  

// 힘들다
1. mockito를 통한 stub을 하게 될 경우 내부 구현에 굉장히 의존적이게 되는 듯 한데....  
> setUp에서 단체로 정의해놓으면 조금 편할까?  

2. mock의 thenReturn으로 사용할 엔티티는 어디서 리턴해야할까? 함수는 어느정도까지 받는걸 가능하게 놔둬야할까?  

3. 엔티티를 그대로 받게 해야할까, 아이디를 받게 해야할까?
> 도메인에서는 엔티티를 받는게 맞는것 같다  
> 서비스, 레파지토리에서는?

4. 메서드 수행후에 뭘 반환해줘야할까?
서비스레벨에선? 무조건 Entity나 DTO 반환?
API레벨에선? CERATE, DELTE는 VOID?  

5. answer 상세에 관한 사항은 사실 요구사항이 아니다  
create의 locaiton 헤더때문에 추가하는건 좀 아닌것 같은데, 어떻게 해야하는지?