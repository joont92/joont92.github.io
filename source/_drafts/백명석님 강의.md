1. Why Clean Code  
- 우리는 매번 새로운 코드를 작성하기보단 읽는 일을 많이 한다  
- 개발하기 전에 내가 만들것에 대해 그려보는 자세를 가져야한다  
    - 앞 부분에서 시간이 많이 드는 것 같지만, 결과적으로 뒷 부분의 시간을 줄여준다  
    - 처음엔 이런 습관 형성에 시간이 걸리겠지만, 나중엔 더 잘하게 될 것이다  
- 마틴 파울러의 말  
    > 돌아가는 코드는 아무나 짤 수 있다.  
    > 사람이 이해할 수 있는 코드는 잘 교육되고 훈련된 소프트웨어 엔지니어만 만들 수 있다.  

2. Why OOP  
- 내 코드를 나 아닌 다른 사람이 유지보수 할껀데, 그 사람은 총이 있고, 미친 사람이다  
- 총을 안맞으려면 유지보수가 쉽고 읽히기 좋은 코드를 만들어야 한다  
- 그러려면 응집도가 높고, 결합도가 낮은 클래스로 구성된 프로그램을 만들어야 함   
    - 응집도가 높다는 말은 하나가 변경되면 이 클래스 하나에서 다 변경된다는 말이고, 결합도가 낮다는 말은 이 클래스가 변경되어도 외부에 영향을 주지 않는다는 말이다  
    - 이런 프로그램을 만드는 방법은 객체지향 밖에 없음  
- 필요한 데이터만 가진 하나의 객체를 만듦  
- 근데 사실 졸라 어렵다  
    - 그래서 대부분 잘 못한다. 자괴감 가질 필요는 없다  
    - 객체지향적으로 생각이 잘 흘러가는 사람은 천운을 가진 사람이다  
    - 그 반면 절차지향은 쉬워서, 대부분 절차지향을 많이 한다  
- 그렇다고 무조건 OOP를 해야하나?  
    - 마틴파울러의 말에 의하면, 구성원 모두가 OOP를 인지한다면 OOP가 당연히 좋지만, 그게 아니라면.. 애석하게도..  
    - 계속해서 사용되어야 할 코드는 OOP로 하는게 좋다  
    - 이벤트성으로 사용되거나, 단순한 시스템이라면 절차지향적으로 해도 된다  
        - 하지만 회사에서 만드는 코드는 단순한 것이 없다  
        - 처음에만 단순해보이는 것이지, 시간이 지나면 단순하지 않게 된다  
        - 변하지 않는 것은 절대 없다. 그러므로 무조건 OOP 해야한다  

3. Object/Role/Resposibility  
- 클래스 이름은 `무엇, 역할`이 보여야하지 `어떻게`가 보이면 안된다  
- 역할이 책임보다 더 큰 개념이고, 객체는 역할을 가진다  
- WriteArticleService는 되지만 ArticleService는 잘못된 네이밍이다  
    - 객체를 데이터로 봤기 때문이다. 기능으로 봐야한다  

4. 객체지향 설계 과정  
- 클래스 모델링 방법  
    1. 어떠어떠한 상태들을 가지는 객체를 선별한다(클래스 다이어그램)  
    2. 객체간 메세지를 주고받는 과정을 그려본다(커뮤니케이션 다이어그램)  
    3. 위 2개를 반복한다  
- 하나의 클래스에 다 때려넣으면 지옥이 펼쳐지므로, 분리하는 것이 좋다  
    - 유닛테스트 하기가 매우 힘듦  
    - 분리된 것을 사용할 때 인터페이스로 한번 래핑하면 훨씬 유연해지고 쉬워진다  
    - 비즈니스 로직을 가지는 곳과, 도메인 로직을 가지는 곳을 나눠야 한다  
        - 비즈니스 로직 : 서비스  
        - 도메인 로직 : 모델  

5. Encapsulation  
- private로 하고 getter setter 줄꺼면 public이랑 다를게 없다  
- private으로 하고 기능만 제공해야 한다  
- 객체의 속성을 가지고 외부에서 판단하는 것이 아니라, 객체에게 직접 물어봐야한다   

command는 내부 상태를 변경하고 반환하는것이 없음
query는 내부상태를 변경하지 않고 상태를 반환함

인터페이스를 써야하는 이유?
- 인터페이스의 구현체가 1개 뿐인일은 절대 없다
- 테스트가 쉽다
- 부가적인 기능을 넣기가 쉽다(데코레이터)
- 

상속을 통한 재사용은 재사용이 아니다
재사용은 인터페이스 재사용을 말하는 것이다
인터페이스를 사용하는 코드가 재사용된다
인터페이스를 사용하는 로직은 굉장히 고수준의 로직이고, 구현체는 저수준의 로직이다.
저수준의 로직이 변경되어도 ..

FtpLogCollector가 DBLogCollector로 변경되어도 인터페이스를 사용하는 부분은 변경될것이 없다
즉, 사용하는것이 변경되어도 인터페이스가 재사용된다. 라는 것이다!  
(정확히는 인터페이스를 사용하는 곳이 재사용된다)  

상속은 재사용이 아니라 의존성이 높아지는것이다. 상속은 가장 강한 의존성이다. 

상세에 빠지다 보면 원래 로직을 까먹게 된다

재사용되어야 하는 인터페이스는 팩토리로 받으면 된다
팩토리는 더러워도 되지만 비즈니스 로직은 더러우면 안된다. 재사용되어야 하므로.
스프링을 사용하면 constructor 등을 선언하고, IOC 컨테이너가 외부에서 의존관계에 해당하는 애들을 주입해준다
그리고 이렇게 구성해놓으면 테스트가 편해진다. 외부에서 테스트 의존을 넣어줘도 되고..

DI가 없이 팩토리 클래스로 의존객체를 가져왔다면 테스트가 매우 힘들어진다. 내부의 팩토리 메서드를 제공하기가 매우 힘들기 때문이다.
스프링의 IOC 컨테이너가 DI로 이를 주입해줌으로써, 위의 불편함을 공짜로 해소가능하게 된다.  

스프링의 가장 좋은점은 트랜잭션 처리나 AOP가 아니라 DI이다.  

객체들간의 결합을 약하게 하려면  
1. 클래스에서 다른 클래스를 직접 사용하는 것을 없애고,  
2. 만약 사용한다고 하면 매개변수로 던지게끔 하고  
3. 여기서 인터페이스로 추상화해서 재사용성을 높이는 방식으로 가야한다  
근데 이렇게 하려면 결국 제 3자가 필요하게 되는데, 여기서 스프링의 DI가 아주 빛을 발하는 것이다.  

스프링이 제공하는 기능을 따라 개발하다보면 DI를 따르게 되어있다
그렇게 하면 하나의 큰 클래스에 모든 로직을 떄려넣지 않게되고, 기능단위로 나누고, 추상화하고(인터페이스로)
이를 JUnit으로 쉽게 테스트하고.. 뭐 그렇게 되는 것이다.
우리가 원하는 객체지향 설계를 아주 쉽게 하게 해준다. DI가 그들의 의존성을 투명하게 관리해주기 때문에.

남한테 보여주기 챙피한걸 보여주면 극복할 수 있고, 남겨두면 그대로 챙피한 것이 된다  


------------------------------  

Time 이라는 클래스로 abstraction 한번 해서 받고있다  

abstraction 안해주면 변경 발생 시 클라이언트쪽에 코드를 많이 바꿔줘야함. 굉장히 힘들 수 있고, 누락할수도 있다.  

상속은 라이브러리 사용하듯이 쉽게 사용할 수 있다.  
변경에 취약함. 부모의 코드를 copy&paste해서 조금 바꾸는 식으로 해버릴수도 있다  
상속을 사용하면 비즈니스 룰을 위반하는 사례가 발생할 수 있다(쌩까고 부모의 기능을 호출해버리기)  

inheritance보단 delegation을 먼저 고려해보는 것이 좋다.  
inheritance가 아니여도 충분히 기능을 재사용 할 수 있기 떄문이다.  

-------------------------------

comment가 없이도 명확하게 이해할 수 있게끔  

작은 메서드가 많이 생기긴 하지만, 함수 네이밍이 명확하고 자신의 의도를 잘 전달한다면, 이름만 보고도 알 수 있다면,  
함수를 내부를 굳이 읽어보지 않아도 알 수 있어야 함  

클래스는 일련의 변수들이 동작하는 기능의 집합   
큰 함수도 파라미터와 그 함수내의 로컬변수들이 동작하는 기능의 집합  
즉, 큰 함수는 클래스로 추출할 수 있다  

리팩토링 과정에서 테스트가 매우 중요하다, 변경변경 마다 테스트를 돌려가면서 한다  

메서드의 여러곳에서 사용되는 변수들은 field variable로 올리면 메서드를 분리할 때 파라미터를 달고 다니지 않아도 된다  
함수는 작은 개수의 파라미터를 가져야된다는 조건을 충족시킴  

비슷한 부분에서 다른 부분을 추출해서 동일하게 만듦  
그리고 중복을 메서드로 분리함  
변수로 뺀 선언이 한곳에서만 쓰이고 있다면 메서드 파라미터로 inline함  
중괄호가 있으면 이건 1가지 이상의 일을 한다는 뜻이다 라고 생각해야함. 즉, 최대한 괄호가 없어야함    

리팩토링 했지만 함수가 여러가지 일을 할 수 있다.  
그렇다고 그 함수가 한가지 일을 할때까지 계속해서 분리해야 하는 것은 아니다.  
(함수의 이름과 함수의 행동이 같을 필요는 없다)  

여러 스텝들을 포함한 함수가 있다고 그것이 3가지 일을 하는 것이 아니라,  
그 여러 스텝들이 모여서 하나의 스텝이 되는 것이다. 즉 1가지 일이 되는 것임  
(이를 충족하려면 자신보다 한단계 낮은 스텝들만을 포함하고 있어야 한다)  
예를 들어,  
로그인 아래 2가지 스텝이 있는데, 그 스텝들의 추상화 수준이 갖고, 그 스텝들이 로그인 바로 아래 추상화 수준이라면,  
그러면 그 두가지 일은 로그인이라는 한가지 일을 수행하는 것이다.  
메서드 내부에 여러가지 일들의 추상화 수준이 같지 않다면 메서드 추출을 통해 빼내어야 한다    
리프레이징(함수의 이름이 함수의 모든 행동을 나타내는것) 까지 추상화 할필요는 없다  
To부정사를 사용해서 함수들을 분리해나갈 수 있다  

--------------------------

잘 짜여진 산문처럼 읽기좋은 코드가 되어야 한다 (마틴 파울러)  

그러려면 연습이 굉장히 잘되있어야 한다  
태권도 품세가 실전에서 잘 안나오는 이유는 연습이 제대로 안되어있기 때문이다  
변화라는건 항상 퇴행하는 속성이 있다  
그러므로 항상 집중해서 의식하고, 연습해야 한다  

캐릭터레이제이션(?) 테스트  
함수의 결과로 나오는 출력결과를 눈으로 하나하나 비교하면 너무 시간이 오래 걸리고, 정확성도 보장할 수 없다  

```java
private PrintStream out;

@Before
public void setUp() throws FileNotFoundException{
    out = System.out; // console print 저장해둠
    System.setOut(new PrintStream(new FileOutputStream("lead")));
}

@After
public void tearDown(){
    System.setOut(out);
    new File("lead").delete();
}
```

함수의 결과를 저장해놓은 파일을 하나 지정한다  
@Before를 통해 표준 출력을 특정 파일로 바꾼다(함수 실행의 결과가 이 파일로 저장될 것이다)  
함수 실행 후 두 파일을 라인단위로 돌면서 같은지 비교한다  
테스트가 끝나면 해당 파일을 삭제한다  

er 붙는 클래스명은 좋지 않다고 한다. 명확하지 않은 경우가 많다고 함  

필드를 전부 extract 해놓고, 불필요한 애들을 지워나가면 된다  
그게 쉽다.  

메서드를 추출하면서,  
그 메서드 내에서만 사용되는 변수라면 로컬 변수로 사용하고,  
다른곳에서도 사용하는 변수라면 매개변수로 사용하는 것이 좋다.  
(이 메서드는 하나의 클래스로 빠질 수도 있다)  
클래스내에서 변경되지 않을 변수는 클래스 필드 변수로, 변경되는 애들은 매개변수로?  
클래스로 빠지게 되면 역할이 분리되니까, 기존의 클래스 이름이 바뀔수도 있다(더 명확하게)  

원칙을 잘 따르다보면, 디자인이 예뻐진다.  
20줄이면 큰 함수라고 보면 된다.  

여러 사람이 보는 코드이므로, 위의 작업들을 계속 해주는게 좋다(상대방을 위해서)  
남을 위한 작업이라 남에게만 도움될 것 같지만, 결국은 나에게 도움이 된다  

- extract till you drop  
리프레이징이 되기 전까지 함수를 extract한다  
그러면 메서드가 굉장히 많아지는데, 이러면 메서드 그룹핑이 가능하게 된다  
(이러므로써 4줄 이하의 메서드로만 구성된 클래스를 만들 수 있게된다)  
그로면 이를 더 쉽게 클래스로 나눌수 있게 된다  

처음에는 이름을 완벽하게 지을 수 없다  
개발을 진행하면서, 요구사항을 더 받으면서 명확해 질 때 이름을 더 명확하게 지으면 된다  