1. Why Clean Code  
- 우리는 매번 새로운 코드를 작성하기보단 읽는 일을 많이 한다  
- 개발하기 전에 내가 만들것에 대해 그려보는 자세를 가져야한다  
    - 앞 부분에서 시간이 많이 드는 것 같지만, 결과적으로 뒷 부분의 시간을 줄여준다  
    - 처음엔 이런 습관 형성에 시간이 걸리겠지만, 나중엔 더 잘하게 될 것이다  
- 마틴 파울러의 말  
    > 돌아가는 코드는 아무나 짤 수 있다.  
    > 사람이 이해할 수 있는 코드는 잘 교육되고 훈련된 소프트웨어 엔지니어만 만들 수 있다.  

2. Why OOP  
- 내 코드를 나 아닌 다른 사람이 유지보수 할껀데, 그 사람은 총이 있고, 미친 사람이다  
- 총을 안맞으려면 유지보수가 쉽고 읽히기 좋은 코드를 만들어야 한다  
- 그러려면 응집도가 높고, 결합도가 낮은 클래스로 구성된 프로그램을 만들어야 함   
    - 응집도가 높다는 말은 하나가 변경되면 이 클래스 하나에서 다 변경된다는 말이고, 결합도가 낮다는 말은 이 클래스가 변경되어도 외부에 영향을 주지 않는다는 말이다  
    - 이런 프로그램을 만드는 방법은 객체지향 밖에 없음  
- 필요한 데이터만 가진 하나의 객체를 만듦  
- 근데 사실 졸라 어렵다  
    - 그래서 대부분 잘 못한다. 자괴감 가질 필요는 없다  
    - 객체지향적으로 생각이 잘 흘러가는 사람은 천운을 가진 사람이다  
    - 그 반면 절차지향은 쉬워서, 대부분 절차지향을 많이 한다  
- 그렇다고 무조건 OOP를 해야하나?  
    - 마틴파울러의 말에 의하면, 구성원 모두가 OOP를 인지한다면 OOP가 당연히 좋지만, 그게 아니라면.. 애석하게도..  
    - 계속해서 사용되어야 할 코드는 OOP로 하는게 좋다  
    - 이벤트성으로 사용되거나, 단순한 시스템이라면 절차지향적으로 해도 된다  
        - 하지만 회사에서 만드는 코드는 단순한 것이 없다  
        - 처음에만 단순해보이는 것이지, 시간이 지나면 단순하지 않게 된다  
        - 변하지 않는 것은 절대 없다. 그러므로 무조건 OOP 해야한다  

3. Object/Role/Resposibility  
- 클래스 이름은 `무엇, 역할`이 보여야하지 `어떻게`가 보이면 안된다  
- 역할이 책임보다 더 큰 개념이고, 객체는 역할을 가진다  
- WriteArticleService는 되지만 ArticleService는 잘못된 네이밍이다  
    - 객체는 데이터로 봤기 때문이다. 기능으로 봐야한다  

4. 객체지향 설계 과정  
- 클래스 모델링 방법  
    1. 어떠어떠한 상태들을 가지는 객체를 선별한다(클래스 다이어그램)  
    1. 객체간 메세지를 주고받는 과정을 그려본다(커뮤니케이션 다이어그램)  
    1. 위 2개를 반복한다  
- 하나의 클래스에 다 때려넣으면 지옥이 펼쳐지므로, 분리하는 것이 좋다  
    - 유닛테스트 하기가 매우 힘듦  
    - 분리된 것을 사용할 때 인터페이스로 한번 래핑하면 훨씬 유연해지고 쉬워진다  
    - 비즈니스 로직을 가지는 곳과, 도메인 로직을 가지는 곳을 나눠야 한다  
        - 비즈니스 로직 : 서비스  
        - 도메인 로직 : 모델  

5. Encapsulation  
- private로 하고 getter setter 줄꺼면 public이랑 다를게 없다  
- private으로 하고 기능만 제공해야 한다  
- 객체의 속성을 가지고 외부에서 판단하는 것이 아니라, 객체에게 직접 물어봐야한다   

command는 내부 상태를 변경하고 반환하는것이 없음
query는 내부상태를 변경하지 않고 상태를 반환함

인터페이스를 써야하는 이유?
- 인터페이스의 구현체가 1개 뿐인일은 절대 없다
- 테스트가 쉽다
- 부가적인 기능을 넣기가 쉽다(데코레이터)
- 

상속을 통한 재사용은 재사용이 아니다
재사용은 인터페이스 재사용을 말하는 것이다
인터페이스를 사용하는 코드가 재사용된다
인터페이스를 사용하는 로직은 굉장히 고수준의 로직이고, 구현체는 저수준의 로직이다.
저수준의 로직이 변경되어도 ..

FtpLogCollector가 DBLogCollector로 변경되어도 인터페이스를 사용하는 부분은 변경될것이 없다
즉, 사용하는것이 변경되어도 인터페이스가 재사용된다. 라는 것이다!

상속은 재사용이 아니라 의존성이 높아지는것이다. 상속은 가장 강한 의존성이다. 

상세에 빠지다 보면 원래 로직을 까먹게 된다

재사용되어야 하는 인터페이스는 팩토리로 받으면 된다
팩토리는 더러워도 되지만 비즈니스 로직은 더러우면 안된다. 재사용되어야 하므로.
스프링을 사용하면 constructor 등을 선언하고, IOC 컨테이너가 외부에서 의존관계에 해당하는 애들을 주입해준다
그리고 이렇게 구성해놓으면 테스트가 편해진다. 외부에서 테스트 의존을 넣어줘도 되고..

DI가 없이 팩토리 클래스로 의존객체를 가져왔다면 테스트가 매우 힘들어진다. 내부의 팩토리 메서드를 제공하기가 매우 힘들기 때문이다.
스프링의 IOC 컨테이너가 DI로 이를 주입해줌으로써, 위의 불편함을 공짜로 해소가능하게 된다.  

스프링의 가장 좋은점은 트랜잭션, AOP가 아니라 DI이다.  

객체들간의 결합을 약하게 하려면  
1. 클래스에서 다른 클래스를 직접 사용하는 것을 없애고,  
2. 만약 사용한다고 하면 매개변수로 던지게끔 하고  
3. 여기서 인터페이스로 추상화해서 재사용성을 높이는 방식으로 가야한다  
근데 이렇게 하려면 결국 제 3자가 필요하게 되는데, 여기서 스프링의 DI가 아주 및을 발하는 것이다.  

스프링이 제공하는 기능을 따라 개발하다보면 DI를 따르게 되어있다
그렇게 하면 하나의 큰 클래스에 모든 로직을 떄려넣지 않게되고, 기능단위로 나누고, 추상화하고(인터페이스로)
이를 JUnit으로 쉽게 테스트하고.. 뭐 그렇게 되는 것이다.
우리가 원하는 객체지향 설계를 아주 쉽게 하게 해준다. DI가 그들의 의존성을 투명하게 관리해주기 때문에.

남한테 보여주기 챙피한걸 보여주면 극복할 수 있고, 남겨두면 그대로 챙피한 것이 된다  


------------------------------  

Time 이라는 클래스로 abstraction 한번 해서 받고있다  

클라이언트쪽에 코드를 많이 바꿔줘야함. 굉장히 힘들 수 있고, 누락할수도 있다.  

상속은 라이브러리 사용하듯이 쉽게 사용할 수 있다.  
변경에 취약함. 부모의 코드를 copy&paste해서 조금 바꾸는 식으로 해버릴수도 있다  
상속을 사용하면 비즈니스 룰을 위반하는 사례가 발생할 수 있다(쌩까고 부모의 기능을 호출해버리기)  

inheritance보단 delegation을 먼저 고려해보는 것이 좋다.  
inheritance가 아니여도 충분히 기능을 재사용 할 수 있기 떄문이다.  